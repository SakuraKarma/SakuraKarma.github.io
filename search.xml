<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2020年浙江理工大学校赛同步赛 E yesky wine展销会</title>
    <url>/2020/07/08/2020%E5%B9%B4%E6%B5%99%E6%B1%9F%E7%90%86%E5%B7%A5%E5%A4%A7%E5%AD%A6%E6%A0%A1%E8%B5%9B%E5%90%8C%E6%AD%A5%E8%B5%9B-E-yesky-wine%E5%B1%95%E9%94%80%E4%BC%9A/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你n个坐标，你需要让每个坐标的差值为k，你可以移动这些坐标来完成这个目的，请问最少移动多少。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>看到这个题目的时候。。真的没啥思路。</p>
<p>还好大佬抬我一手。。感谢大佬</p>
<p>当时还有点理解的，后来比赛完之后有人问了我一下这个题目。</p>
<p>被考住了。。还是感觉不够理解，为啥一定是最优解。</p>
<p>后面看到别人博客，自己试着推了一下，感觉自己差不多懂了。</p>
<p>假设，我们先以$k,2k,3k,…,nk$为基准，想要每个点都是这个状态，于是我们可以用每个点的坐标做差，得到每个点的差值$x_i-i*k$，求之前需要对坐标数组进行排序。</p>
<p>得到每个点的差值之后，我们肯定是不能就是按照$k,2k,3k,…,nk$这个基准来，因为我们可以让这些k相关点进行一个移动，至少可以移动到一个点上来，我们就假设以这个点展开，那么这个点就叫做基准点。</p>
<p>那么我们就需要找到这个基准点。</p>
<p>假设存在一些差值，分别是$…,a-bk,c-dk,e-fk,g-hk,i-jk,…$，都是按照大小进行排序的。</p>
<p>假设我们取$c-dk$这个差值，也就是以c为基准点，将其他所有的值，进行偏移$c-dk$。</p>
<p>加入c在dk的左边，即差值为负数，即整体向右移，或者说k相关点向左移。</p>
<p>对于他左边的差值，都是减小$c-dk$的，（这个差值都是取绝对值的，以后省略）。</p>
<p>对于他右边的差值，如果差值小于0的话，也是减小$c-dk$的，如果差值大于0的话，就是增加$c-dk$的。</p>
<p>因为差值减小是取绝对值的，所以可能减小也可能增大，因为他左边的点的差值的绝对值都比他大，所以他左边的点都是差值减小的，他右边的点的差值的绝对值都比他要小，实际上是差值增大的，但是差值增大就是绝对增大的。</p>
<p>如果在c在dk的右边同理，可以得到差不多的结果。</p>
<p>假设c在dk左边，令$c-dk$为$Δx$,他左边的点个数记为$n_1$，右边小于0的点个数记为$n_2$，其他的点个数记为$n_3$。</p>
<p>那么便可以得到减小的值是$n_1\times Δx$，增加的值是$n_2\times (Δx-|x_i|)+n_3\timesΔx$。</p>
<p>假设原本的所有差值的和为s，那么最后得到的结果便是$s+|n_1-(n_2+n_3)|\times Δx-n_2\times |x_i|$。</p>
<p>其中$|n_1-(n_2+n_3) |$就是基准点左右两边的数的个数的差值。</p>
<p>显然，当基准点为中位数的时候，差值为0或者为1。</p>
<p>由于当你取的基准点偏离中位数的时候，显然第一个式子会比第二个式子要大得多，只要我们将增加的值取得最小，也就是最优解了。</p>
<p>当c在dk右边的时候可以得到相类似的结果。</p>
<p>所以我们只需要取中位数即可。</p>
<p>最后的结果就是每个点的差值减去中位数的差值然后取绝对值相加即可。</p>
<p>（可能证明不是很严谨。。但是我也尽力了。</p>
<p>贴一个我认为比较严谨的数学方式证明的链接。</p>
<p><a href="https://blog.csdn.net/zstuyyyyccccbbbb/article/details/106876910" target="_blank" rel="noopener">链接</a>。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">6</span>;</span><br><span class="line">ll x[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> n, k;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; x[i];</span><br><span class="line">	&#125;</span><br><span class="line">	sort(x + <span class="number">1</span>, x + <span class="number">1</span> + n);</span><br><span class="line">	<span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		x[i] -= i * k;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(x + <span class="number">1</span>, x + <span class="number">1</span> + n);</span><br><span class="line">	ll t = x[(n + <span class="number">1</span>) / <span class="number">2</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)	ans += <span class="built_in">abs</span>(x[i] - t);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>2020年“联想杯” A Archmage 题解</title>
    <url>/2020/07/08/2020-%E5%B9%B4-%E2%80%9C%E8%81%94%E6%83%B3%E6%9D%AF%E2%80%9D-A-Archmage-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://acm.ecnu.edu.cn/contest/270/problem/A/" target="_blank" rel="noopener">题目大意</a></h3><p>你有初始的n点法力值，有m个回合，在回合初，你可以花费x点法力值，制造一个水球，在回合结束时，你可以回复y点法力值。问最多水球数量。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>哇。。这个是真的卡了我好久。。</p>
<p>一直没想到正确的思路。。</p>
<p>结果一看题解。。</p>
<p>我们首先可以分两种情况。</p>
<p>1、$y\ge x$</p>
<p>显然，每回合回复的法力值都足够消耗，答案显然是m。</p>
<p>2、$y&lt;x$</p>
<p>这里很难想。</p>
<p>我刚开始想的时候，是想到答案为$(n+m*y)/x$,后来发现不对，就没往这方面想了。</p>
<p>结果是$(n+(m-1)*y)/x$。</p>
<p>对于每一回合来说，我上回合回复的y，我之后的回合总能够使用到，但是我第m回合的时候，回复的法力值相当于是无用的，所以实际上增加的应该是$(m-1)*y$。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		ll n, m, x, y;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		<span class="keyword">if</span> (y &gt;= x) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ll ans = (n + (m - <span class="number">1</span>) * y) / x;</span><br><span class="line">		ans = <span class="built_in">min</span>(ans, m);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>51NOD-1625 夹克爷发红包 题解</title>
    <url>/2020/07/08/51NOD-1625-%E5%A4%B9%E5%85%8B%E7%88%B7%E5%8F%91%E7%BA%A2%E5%8C%85-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://www.51nod.com/Challenge/Problem.html#problemId=1625" target="_blank" rel="noopener">题目大意</a></h3><p>给你一个$n*m$的矩阵，矩阵中存在初始值，现在你可以进行$k$次操作，将任意一行或者一列每一个数都赋值为$x$，问你矩阵最大和为多少。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>刚开始我是想，用贪心，计算出每一行，每一列的修改值，然后从小到大的修改。</p>
<p>想了想，发现很麻烦，而且还不一定正确。。</p>
<p>直接懵了，想了好久，没想出来。。</p>
<p>去看了题解。。</p>
<p>用状态压缩的方法，枚举每一行的情况，因为n的范围不大，最大也就是$2^{10}$。</p>
<p>状压，用我自己的话来说，就是用一个数的二进制来表示每一位的情况，所以说其实是相当暴力的。</p>
<p>可以用这一位为1来表示选，为0的表示不选。</p>
<p>因为行确定了，而列与列之间不会互相影响，这样只需要枚举出最大值即可。</p>
<p>（这方法好妙啊。。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll num[<span class="number">20</span>][<span class="number">300</span>],dx[<span class="number">300</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m, x, k;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; k;</span><br><span class="line">	ll sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)	</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; num[i][j],sum+=num[i][j];</span><br><span class="line">	&#125;</span><br><span class="line">	ll ans = sum;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++) &#123;</span><br><span class="line">		ll res, cnt;</span><br><span class="line">		res = cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i &amp; (<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))) &#123;<span class="comment">//判断第j位是不是为1</span></span><br><span class="line">				cnt++;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> g = <span class="number">1</span>; g &lt;= m; g++)	res += x - num[j][g];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (cnt &gt; k)	<span class="keyword">continue</span>;</span><br><span class="line">		cnt = k - cnt;</span><br><span class="line">		<span class="built_in">memset</span>(dx, <span class="number">0</span>, <span class="keyword">sizeof</span>(dx));</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> g = <span class="number">1</span>; g &lt;= n; g++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (i &amp; (<span class="number">1</span> &lt;&lt; (g - <span class="number">1</span>)))	<span class="keyword">continue</span>;</span><br><span class="line">				dx[j] += x - num[g][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		sort(dx + <span class="number">1</span>, dx + <span class="number">1</span> + m, greater&lt;ll&gt;());<span class="comment">//十年OI一场空，不开longlong见祖宗，我又忘了。。</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m &amp;&amp; j &lt;= cnt; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (dx[j] &lt; <span class="number">0</span>)	<span class="keyword">break</span>;</span><br><span class="line">			res += dx[j];</span><br><span class="line">		&#125;</span><br><span class="line">		ans = <span class="built_in">max</span>(ans, sum + res);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>状压</tag>
        <tag>暴力</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>A*算法</title>
    <url>/2020/07/08/Astar%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>把Dijkstra算法（靠近初始点的结点）和BFS算法（靠近目标点的结点）的信息块结合起来。在讨论A*的标准术语中，g(n)表示从初始结点到任意结点n的代价，h(n)表示从结点n到目标点的启发式评估代价（heuristic estimated cost）。</p>
<p>当从初始点向目标点移动时，A*权衡这两者。每次进行主循环时，它检查f(n)最小的结点n，其中$f(n) = g(n) + h(n)$。</p>
<p>A*主要作为寻路算法作用在游戏上。</p>
<a id="more"></a>

<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>到这里，学长给我们上的课就到此结束了。</p>
<p>说实话，还是挺感谢学长们的，讲了好多东西啊。</p>
<p>还需要继续去掌握和巩固。</p>
<p>但是这个A*是真的难懂。</p>
<p>用我的理解来说，就是正向的一个Dijkstra与反向的BFS（最佳优先搜索）结合，用f(n)作为优先级来判断。</p>
<p>这个BFS存在一个启发式函数，这个启发式函数就是从节点n开始到目标节点的最小值。</p>
<p>这个算法网上没啥题，也没啥教程，听学长讲了一遍。</p>
<p>说实话，还是相当懵。</p>
<p>这里就贴一个详解吧。</p>
<p><a href="https://blog.csdn.net/coutamg/article/details/53923717" target="_blank" rel="noopener">A*</a>。</p>
<h3 id="典型例题"><a href="#典型例题" class="headerlink" title="典型例题"></a>典型例题</h3><p><a href="http://poj.org/problem?id=2449" target="_blank" rel="noopener">POJ-2449 Remmarguts’ Date</a></p>
<h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h4><p>给你一个n个节点，m条边的图，给你起点s，和终点t，求第k短路。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>网上说貌似可以用spfa，我用的A*。</p>
<p>先反向跑一遍Dijkstra，得出距离，也就是$h(n)$。</p>
<p>然后以$f(n)$为优先级跑一遍Dijkstra。</p>
<p>应该算是典型A*模板题。</p>
<h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>, M = <span class="number">1e5</span> + <span class="number">5</span>, INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> cnt1, cnt2, head1[N], head2[N], vis[N], dis[N], n, k;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> to, val, next;</span><br><span class="line">&#125;Map1[M],Map2[M];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> u, c;</span><br><span class="line">	node(<span class="keyword">int</span> a = <span class="number">0</span>,<span class="keyword">int</span> b = <span class="number">0</span>):u(a),c(b)&#123;&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> node&amp; a) <span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> c &gt; a.c;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">heap</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> g, h, num;</span><br><span class="line">	heap(<span class="keyword">int</span> a = <span class="number">0</span>,<span class="keyword">int</span> b = <span class="number">0</span>,<span class="keyword">int</span> c = <span class="number">0</span>):g(a),h(b),num(c)&#123;&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> heap&amp; a) <span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (g + h) &gt; (a.g + a.h);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build1</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">	Map1[++cnt1].to = v, Map1[cnt1].val = val;</span><br><span class="line">	Map1[cnt1].next = head1[u], head1[u] = cnt1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">	Map2[++cnt2].to = v, Map2[cnt2].val = val;</span><br><span class="line">	Map2[cnt2].next = head2[u], head2[u] = cnt2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dis[i] = INF;</span><br><span class="line">	dis[s] = <span class="number">0</span>;</span><br><span class="line">	priority_queue&lt;node&gt;q2;</span><br><span class="line">	q2.push(node(s, <span class="number">0</span>));</span><br><span class="line">	node t;</span><br><span class="line">	<span class="keyword">while</span> (!q2.empty()) &#123;</span><br><span class="line">		t = q2.top();</span><br><span class="line">		q2.pop();</span><br><span class="line">		<span class="keyword">int</span> u = t.u;</span><br><span class="line">		<span class="keyword">if</span> (vis[u])	<span class="keyword">continue</span>;</span><br><span class="line">		vis[u] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = head2[u]; ~i; i = Map2[i].next) &#123;</span><br><span class="line">			<span class="keyword">int</span> x = Map2[i].to;</span><br><span class="line">			<span class="keyword">int</span> c = Map2[i].val;</span><br><span class="line">			<span class="keyword">if</span> (!vis[x]&amp;&amp;dis[x] &gt; dis[u] + c)</span><br><span class="line">				dis[x] = dis[u] + c, q2.push(node(x, dis[x]));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Astar</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">	Dijkstra(e);</span><br><span class="line">	priority_queue&lt;heap&gt;q1;</span><br><span class="line">	q1.push(heap(<span class="number">0</span>, dis[s], s));</span><br><span class="line">	heap t;</span><br><span class="line">	<span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!q1.empty()) &#123;</span><br><span class="line">		t = q1.top();</span><br><span class="line">		q1.pop();</span><br><span class="line">		<span class="keyword">if</span> (t.num == e) &#123;</span><br><span class="line">			c++;</span><br><span class="line">			<span class="keyword">if</span> (c &gt;= k) &#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; t.g &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = head1[t.num]; ~i; i = Map1[i].next) &#123;</span><br><span class="line">			<span class="keyword">int</span> x = Map1[i].to;</span><br><span class="line">			<span class="keyword">int</span> c = Map1[i].val;</span><br><span class="line">			q1.push(heap(t.g + c, dis[x], x));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="built_in">memset</span>(head1, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head1));</span><br><span class="line">	<span class="built_in">memset</span>(head2, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head2));</span><br><span class="line">	cnt1 = cnt2 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> l, r, c;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r &gt;&gt; c;</span><br><span class="line">		build1(l, r, c),build2(r, l, c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> s, t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; s &gt;&gt; t &gt;&gt; k;</span><br><span class="line">	<span class="keyword">if</span> (s == t)	k++;</span><br><span class="line">	Astar(s, t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>A*</tag>
      </tags>
  </entry>
  <entry>
    <title>AC自动机</title>
    <url>/2020/07/08/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
    <content><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>AC自动机，正如他的名字，能够让你自动AC（误</p>
<p>其实是一个匹配字符串的算法。</p>
<p>简单来说，就是在trie树上用KMP的思想。</p>
<p>（当然，你也可以理解为就是用了KMP。。</p>
<p>因为本来trie树是可以用来匹配字符串的，但是因为匹配失败的时候都需要从头开始，会导致浪费了很多时间，加大了时间复杂度。</p>
<p>所以，就提出来了AC自动机。</p>
<p>原理就是和KMP的next数组类似，使用一个fail数组，来记录匹配失败之后，需要回溯到哪个地方。</p>
<p>这样便能减少很多复杂度。</p>
<p>时间复杂度为$O(n)$($n$为文本长度)</p>
<p>（AC自动机怎么不能帮助我自动AC啊。。</p>
<a id="more"></a>

<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><h4 id="1、建树"><a href="#1、建树" class="headerlink" title="1、建树"></a>1、建树</h4><p>这里和trie树是一样的，我就不多赘述了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> trie[N][<span class="number">30</span>], cnt[N], fail[N], tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = s.length(),now = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> id = s[i] - <span class="string">'a'</span>;</span><br><span class="line">		<span class="keyword">if</span> (!trie[now][id])	trie[now][id] = ++tot;</span><br><span class="line">		now = trie[now][id];</span><br><span class="line">	&#125;</span><br><span class="line">	cnt[now]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、获取fail数组"><a href="#2、获取fail数组" class="headerlink" title="2、获取fail数组"></a>2、获取fail数组</h4><p>这个fail数组就类似于KMP中的next数组，当你匹配失败的时候，能通过回溯的方式，来回到fail所指向的那个节点，通过这样的方式来减小时间复杂度。</p>
<p>而fail指针指向是与当前字符相同并且该字符所在的前缀构成现在字符的最长后缀。</p>
<p>用bfs的方式来获取fail数组。</p>
<p>这里以$aba,abcd,bca,bad$为例。</p>
<p><img src="https://ae01.alicdn.com/kf/H0eb39b789d55425faba9342f12634e3ex.jpg" alt=""></p>
<p>首先，第一层的节点的fail肯定是指向根节点的。</p>
<p>此外，对于遍历的节点来说。</p>
<p>如果遍历的节点存在指向的子节点的话，那么该子节点的fail为他的父节点的fail的节点指向相同节点的节点。</p>
<p>（有点绕啊。。不懂的看看代码吧。</p>
<p>如果遍历的节点不存在指向的子节点的话，那么令该节点指向他的fail的节点指向的相同节点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Getfail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)<span class="comment">//第一层的直接指向根节点</span></span><br><span class="line">		<span class="keyword">if</span>(trie[<span class="number">0</span>][i])</span><br><span class="line">		fail[trie[<span class="number">0</span>][i]] = <span class="number">0</span>, q.push(trie[<span class="number">0</span>][i]);</span><br><span class="line">	<span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> now = q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (trie[now][i]) &#123;<span class="comment">//如果存在指向的子节点</span></span><br><span class="line">				fail[trie[now][i]] = trie[fail[now]][i];</span><br><span class="line">                <span class="comment">//他子节点的fail为他的父节点，也就是now的fail的指向相同节点的节点</span></span><br><span class="line">				q.push(trie[now][i]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> trie[now][i] = trie[fail[now]][i];</span><br><span class="line">            <span class="comment">//如果不存在指向的子节点</span></span><br><span class="line">            <span class="comment">//那么直接让该节点指向他自己fail的节点的指向的相同节点</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、查询"><a href="#3、查询" class="headerlink" title="3、查询"></a>3、查询</h4><p>从根节点开始一步步进行匹配。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quiry</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> now = <span class="number">0</span>, ans = <span class="number">0</span>, len = s.length();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> id = s[i] - <span class="string">'a'</span>;</span><br><span class="line">		now = trie[now][id];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = now; j &amp;&amp; cnt[j] != <span class="number">-1</span>; j = fail[j])<span class="comment">//从now开始一直向下寻找，直到匹配失败（指向根节点或者已经被匹配过）</span></span><br><span class="line">			ans += cnt[j], cnt[j] = <span class="number">-1</span>;<span class="comment">//将匹配过的节点进行标记</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4、last优化"><a href="#4、last优化" class="headerlink" title="4、last优化"></a>4、last优化</h4><p>不会last优化。。</p>
<p>这边记录一下，了解<a href="https://www.cnblogs.com/sclbgw7/p/9875671.html" target="_blank" rel="noopener">点击这里</a>。</p>
<h3 id="典型例题"><a href="#典型例题" class="headerlink" title="典型例题"></a>典型例题</h3><p>1、<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2222" target="_blank" rel="noopener">HDU-2222 Keywords Search</a></p>
<h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h4><p>给你一串字符串，问你里面最多有多少个关键词。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>AC自动机模板题。</p>
<p>就是卡cin，cout。</p>
<p>真的难受。</p>
<h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> trie[N][<span class="number">30</span>], cnt[N], fail[N], tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = s.length(),now = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> id = s[i] - <span class="string">'a'</span>;</span><br><span class="line">		<span class="keyword">if</span> (!trie[now][id])	trie[now][id] = ++tot;</span><br><span class="line">		now = trie[now][id];</span><br><span class="line">	&#125;</span><br><span class="line">	cnt[now]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Getfail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">		<span class="keyword">if</span>(trie[<span class="number">0</span>][i])</span><br><span class="line">		fail[trie[<span class="number">0</span>][i]] = <span class="number">0</span>, q.push(trie[<span class="number">0</span>][i]);</span><br><span class="line">	<span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> now = q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (trie[now][i]) &#123;</span><br><span class="line">				fail[trie[now][i]] = trie[fail[now]][i];</span><br><span class="line">				q.push(trie[now][i]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> trie[now][i] = trie[fail[now]][i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quiry</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> now = <span class="number">0</span>, ans = <span class="number">0</span>, len = s.length();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> id = s[i] - <span class="string">'a'</span>;</span><br><span class="line">		now = trie[now][id];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = now; j &amp;&amp; cnt[j] != <span class="number">-1</span>; j = fail[j])</span><br><span class="line">			ans += cnt[j], cnt[j] = <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		tot = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(trie, <span class="number">0</span>, <span class="keyword">sizeof</span>(trie));</span><br><span class="line">		<span class="built_in">memset</span>(fail, <span class="number">0</span>, <span class="keyword">sizeof</span>(fail));</span><br><span class="line">		<span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">		<span class="built_in">string</span> s;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">			insert(s);</span><br><span class="line">		&#125;</span><br><span class="line">		Getfail();</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; quiry(s) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2896" target="_blank" rel="noopener">HDU-2896 病毒侵袭</a></p>
<h4 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h4><p>给你多个字符串，每个字符串按$1-M$编号，输入多个病毒特征码，按照$1-N$，问你每个字符串中存在的特征码。</p>
<h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>这个题目究极恶心，卡内存卡到吐。。</p>
<p>题目要求每个字符都是ASCII码可见字符（不包括回车）。</p>
<p>所以最大的就是$127-32=95$,我刚开始以为要开到128。</p>
<p>其他的就是模板了。</p>
<p>还要注意病毒的编号是从小到大输出的，可以用优先队列。</p>
<h4 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">7e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> trie[N][<span class="number">100</span>], cnt[N], fail[N], tot,flag[N];</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> s,<span class="keyword">int</span> g)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = s.length(), now = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> id = s[i] - <span class="string">' '</span>;</span><br><span class="line">		<span class="keyword">if</span> (!trie[now][id])	trie[now][id] = ++tot;</span><br><span class="line">		now = trie[now][id];</span><br><span class="line">	&#125;</span><br><span class="line">	cnt[now] = g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Getfail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">96</span>; i++)</span><br><span class="line">		<span class="keyword">if</span> (trie[<span class="number">0</span>][i])</span><br><span class="line">			fail[trie[<span class="number">0</span>][i]] = <span class="number">0</span>, q.push(trie[<span class="number">0</span>][i]);</span><br><span class="line">	<span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> now = q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">96</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (trie[now][i]) &#123;</span><br><span class="line">				fail[trie[now][i]] = trie[fail[now]][i];</span><br><span class="line">				q.push(trie[now][i]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> trie[now][i] = trie[fail[now]][i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quiry</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> now = <span class="number">0</span>, len = s.length();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> id = s[i] - <span class="string">' '</span>;</span><br><span class="line">		now = trie[now][id];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = now; j &amp;&amp; flag[j] != <span class="number">-1</span>; j = fail[j]) &#123;</span><br><span class="line">			<span class="keyword">if</span> (cnt[j] &gt; <span class="number">0</span>)	ans.push(cnt[j]);</span><br><span class="line">			flag[j] = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> n,m;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n) &#123;</span><br><span class="line">		tot = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(trie, <span class="number">0</span>, <span class="keyword">sizeof</span>(trie));</span><br><span class="line">		<span class="built_in">memset</span>(fail, <span class="number">0</span>, <span class="keyword">sizeof</span>(fail));</span><br><span class="line">		<span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">		<span class="built_in">memset</span>(flag, <span class="number">0</span>, <span class="keyword">sizeof</span>(flag));</span><br><span class="line">		<span class="built_in">string</span> s;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">			insert(s, i);</span><br><span class="line">		&#125;</span><br><span class="line">		Getfail();</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">		<span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">			quiry(s);</span><br><span class="line">			<span class="keyword">if</span> (!ans.empty()) &#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"web "</span> &lt;&lt; i &lt;&lt; <span class="string">":"</span>;</span><br><span class="line">				<span class="keyword">while</span> (!ans.empty()) &#123;</span><br><span class="line">					<span class="built_in">cout</span> &lt;&lt;<span class="string">" "</span>&lt;&lt; ans.top();</span><br><span class="line">					ans.pop();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">				c++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">memset</span>(flag, <span class="number">0</span>, <span class="keyword">sizeof</span>(flag));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"total: "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>ACWing-344 观光之旅 题解</title>
    <url>/2020/07/08/ACWing-344-%E8%A7%82%E5%85%89%E4%B9%8B%E6%97%85-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://www.acwing.com/problem/content/description/346/" target="_blank" rel="noopener">题目大意</a></h3><p>给定一张无向图，求图中一个至少包含3个点的环，环上的节点不重复，并且环上的边的长度之和最小。</p>
<p>你需要输出最小环的方案，若最小环不唯一，输出任意一个均可。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>模板题。。</p>
<p>比最小环模板多了一个记录路径的过程。</p>
<p>（没啥好说的，还是看代码吧。。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e8</span>;</span><br><span class="line"><span class="keyword">int</span> Map[<span class="number">200</span>][<span class="number">200</span>], dis[<span class="number">200</span>][<span class="number">200</span>],ne[<span class="number">200</span>][<span class="number">200</span>],n,path[<span class="number">200</span>];</span><br><span class="line"><span class="comment">//ne[i][j]表示从i到j的经过的第一个节点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> mins = INF,cnt;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; k; j++) &#123;</span><br><span class="line">				<span class="keyword">int</span> tmp = dis[i][j] + Map[i][k] + Map[j][k];</span><br><span class="line">				<span class="keyword">if</span> (tmp &lt; mins) &#123;</span><br><span class="line">					mins = tmp;</span><br><span class="line">					cnt = <span class="number">0</span>;</span><br><span class="line">					<span class="keyword">int</span> p = i;</span><br><span class="line">					<span class="keyword">while</span> (p != j) &#123;<span class="comment">//输出从i到j的路径</span></span><br><span class="line">						path[cnt++] = p;</span><br><span class="line">						p = ne[p][j];</span><br><span class="line">					&#125;</span><br><span class="line">					path[cnt++] = j;</span><br><span class="line">					path[cnt++] = k;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">				<span class="keyword">int</span> tmp = dis[i][k] + dis[k][j];</span><br><span class="line">				<span class="keyword">if</span> (tmp &lt; dis[i][j]) &#123;</span><br><span class="line">					dis[i][j] = tmp;</span><br><span class="line">					ne[i][j] = ne[i][k];<span class="comment">//记录路径</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (mins == INF)	<span class="built_in">cout</span> &lt;&lt; <span class="string">"No solution."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">			<span class="built_in">string</span> s = i == cnt - <span class="number">1</span> ? <span class="string">"\n"</span> : <span class="string">" "</span>;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; path[i] &lt;&lt; s;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">			Map[i][j] = dis[i][j] = INF,ne[i][j] = j;</span><br><span class="line">		Map[i][i] = dis[i][i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> x, y, l;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; l;</span><br><span class="line">		Map[x][y] = dis[x][y] = Map[y][x] = dis[y][x] = l;</span><br><span class="line">	&#125;</span><br><span class="line">	Floyd();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Floyd</tag>
        <tag>最小环</tag>
        <tag>记录路径</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-1169B Pairs 题解</title>
    <url>/2020/07/08/CF-1169B-Pairs-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://vjudge.net/problem/CodeForces-1169B/origin" target="_blank" rel="noopener">题目大意</a></h3><p>给定你m对整数对（x[i],y[i]），请问是否存在x和y，使得n对中每一对中至少有一个数是x和y之中的一个。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>（我是真的蠢啊。。。</p>
<p>每一对都要是x，y中的一个，那么x就只有两种情况，第一对其中的任意一个。</p>
<p>这个需要只需要枚举y两次即可。</p>
<p>（就是这个卡了我好久。。</p>
<p>只要x加上y减去y和x一起出现的次数加起来等于m即可。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"><span class="built_in">map</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; M;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">int</span> a, b;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">	cnt[a]++;</span><br><span class="line">	cnt[b]++;</span><br><span class="line">	M[make_pair(a, b)]++;</span><br><span class="line">	M[make_pair(b, a)]++;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> x, y;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		cnt[x]++;</span><br><span class="line">        cnt[y]++;</span><br><span class="line">		M[make_pair(x,y)]++;</span><br><span class="line">		M[make_pair(y,x)]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i != a&amp;&amp; cnt[i] + cnt[a] - M[make_pair(i, a)] == m) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i!=b&amp;&amp;cnt[i] + cnt[b] - M[make_pair(i, b)] == m) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-1060D  Social Circles 题解</title>
    <url>/2020/07/08/CF-1060D-Social-Circles-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://codeforces.com/problemset/problem/1060/D" target="_blank" rel="noopener">题目大意</a></h3><p>有n个客人，他们围绕着1个或者多个圈而坐。每一个人都需要左边空li个人，右边ri个人（空位可以重叠）。请问最少需要多少个座位。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>（想了好久没想到思路，后来发现是理解错了。。</p>
<p>其实就是蠢了。想着左边连左边了。</p>
<p>看了题解，发现就是贪心。。</p>
<p>每个人就是左边连着另外一个人的右边，那么我只要让他们的差值最小即可，这样浪费的座位数越小，也就是按照大小排序之后，取左边和右边中的最大值+1，便是两人之间一条边的最小贡献。（如果选出的恰好是同一个人的时候，就是一个人单独一个圈，也是相同的方法）</p>
<p>（zbw大佬说的对，贪心确实要多做题。。</p>
<p>第一次做到这种贪心。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> l[N], r[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)	<span class="built_in">cin</span> &gt;&gt; l[i] &gt;&gt; r[i];</span><br><span class="line">	sort(l + <span class="number">1</span>, l + <span class="number">1</span> + n);</span><br><span class="line">	sort(r + <span class="number">1</span>, r + <span class="number">1</span> + n);</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;<span class="comment">//注意数据范围</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		ans += <span class="built_in">max</span>(l[i], r[i]) + <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-1000C Covered Points Count 题解</title>
    <url>/2020/07/08/CF-1000C-Covered-Points-Count-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://codeforces.com/problemset/problem/1000/C" target="_blank" rel="noopener">题目大意</a></h3><p>在一个数轴上，给你n个线段，每个线段可以相交，重合，问你被覆盖$1$~$n$次的点每个有多少。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>上次上课讲到了离散化差分，去搜了搜，就找到了这个题目。。</p>
<p>因为线段的端点数值很大，$1·10^{18}$，但是n的数据范围不大。</p>
<p>所以可以使用离散化，</p>
<p>那么差分之后的数组代表着一段的覆盖次数，这一段的长度为相邻两点的差。</p>
<p>线段可以重合，需要去重。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">500</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	ll x, y;</span><br><span class="line">&#125;p[N];</span><br><span class="line">ll pos[N &lt;&lt; <span class="number">1</span>], num[N &lt;&lt; <span class="number">1</span>], cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> n,c = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; p[i].x &gt;&gt; p[i].y;</span><br><span class="line">		pos[++c] = p[i].x,pos[++c] = p[i].y + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(pos + <span class="number">1</span>, pos + <span class="number">1</span> + c);</span><br><span class="line">	<span class="keyword">int</span> l = unique(pos + <span class="number">1</span>, pos + <span class="number">1</span> + c) - pos - <span class="number">1</span>;<span class="comment">//去重</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = lower_bound(pos + <span class="number">1</span>, pos + <span class="number">1</span> + l, p[i].x) - pos;<span class="comment">//注意，lower_bound的返回值为与传入的数组起始地址的相对位置，所以num是从1开始的。</span></span><br><span class="line">		<span class="keyword">int</span> y = lower_bound(pos + <span class="number">1</span>, pos + <span class="number">1</span> + l, p[i].y + <span class="number">1</span>) - pos;<span class="comment">//查找y+1</span></span><br><span class="line">		num[x]++, num[y]--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; l; i++) &#123;</span><br><span class="line">		num[i] += num[i - <span class="number">1</span>];<span class="comment">//这一段的覆盖数量</span></span><br><span class="line">		cnt[num[i]] += pos[i+<span class="number">1</span>]-pos[i];<span class="comment">//这一段的长度</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)	<span class="built_in">printf</span>(<span class="string">"%lld%c"</span>, cnt[i], i == n ? <span class="string">'\n'</span> : <span class="string">' '</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>差分</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-1195C Basketball Exercise 题解</title>
    <url>/2020/07/08/CF-1195C-Basketball-Exercise-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你两个序列a和b，你可以从中任意选取其中的数字，但是你不能取相邻的两个数字，问所取的数字的最大和。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>典型的线性DP题。。</p>
<p>但是写的DP题少啊。。DP还是相当苦手。</p>
<p>需要多刷点题。。不过最近没啥时间，要期末考了。。等暑假吧。</p>
<p>我们可以用$dp[i][j][h]$来表示第i列到序列最右端的最大和，其中j代表第几行，h代表这一位取或者而不取。</p>
<p>那么我们便可以得到状态转移方程。</p>
<p>假如我第i位不取，那么无论是第1行，还是第2行，都是右边所有情况的最大值，因为我这一位不取，不会影响到后面的取舍，所以只需要取其中的最大值即可。</p>
<p>$dp[i][1][0] = dp[i][2][0] = max(max(dp[i + 1][1][0], dp[i + 1][1][1]), max(dp[i + 1][2][0], dp[i + 1][2][1]))$</p>
<p>假如我第i位取，那么对第一行来说，我不能取第一行后面相邻的那个数，但是对第二行的取舍是没有影响的，所以取这三种情况的最大值并且加上该位上的值即可。</p>
<p>$dp[i][1][1] = max(dp[i + 1][1][0], max(dp[i + 1][2][0], dp[i + 1][2][1])) + num[i][1]$</p>
<p>对于第二行来说是类似的，我不能取第二行后面相邻的那个数，但是对第一行的取舍是没有没有影响的，所以也是取这三种情况的最大值加上该位上的值即可。</p>
<p>$dp[i][2][1] = max(dp[i + 1][2][0], max(dp[i + 1][1][0], dp[i + 1][1][1])) + num[i][2]$</p>
<p>但是需要注意，我们需要从右边开始倒序转移，因为重叠的子问题都是与右边的情况有关的。</p>
<p>最后的结果就是第一列中第一行取或不取，第二行取或不取四种情况中的最大值。</p>
<p>即$max(max(dp[1][1][0], dp[1][1][1]), max(dp[1][2][0], dp[1][2][1]))$。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll dp[N][<span class="number">3</span>][<span class="number">2</span>],num[N][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)	<span class="built_in">cin</span>&gt;&gt;num[i][<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)	<span class="built_in">cin</span>&gt;&gt;num[i][<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">		dp[i][<span class="number">1</span>][<span class="number">0</span>] = dp[i][<span class="number">2</span>][<span class="number">0</span>] = <span class="built_in">max</span>(<span class="built_in">max</span>(dp[i + <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>], dp[i + <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>]), <span class="built_in">max</span>(dp[i + <span class="number">1</span>][<span class="number">2</span>][<span class="number">0</span>], dp[i + <span class="number">1</span>][<span class="number">2</span>][<span class="number">1</span>]));<span class="comment">//这一位没取的情况</span></span><br><span class="line">		dp[i][<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>], <span class="built_in">max</span>(dp[i + <span class="number">1</span>][<span class="number">2</span>][<span class="number">0</span>], dp[i + <span class="number">1</span>][<span class="number">2</span>][<span class="number">1</span>])) + num[i][<span class="number">1</span>];<span class="comment">//这一位第1行取了的情况</span></span><br><span class="line">		dp[i][<span class="number">2</span>][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][<span class="number">2</span>][<span class="number">0</span>], <span class="built_in">max</span>(dp[i + <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>], dp[i + <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>])) + num[i][<span class="number">2</span>];<span class="comment">//这一位第2行取了的情况</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">max</span>(<span class="built_in">max</span>(dp[<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>], dp[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>]), <span class="built_in">max</span>(dp[<span class="number">1</span>][<span class="number">2</span>][<span class="number">0</span>], dp[<span class="number">1</span>][<span class="number">2</span>][<span class="number">1</span>])) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线性DP</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-1217D Coloring Edges 题解</title>
    <url>/2020/07/08/CF-1217D-Coloring-Edges-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://codeforces.com/problemset/problem/1217/D" target="_blank" rel="noopener">题目大意</a></h3><p>小明是一个国王，他的国家有n个城市。</p>
<p>现在小明想为这n个城市制造m条路径（路径都是有向的），现在小明有k种不同种类的材料，可以用来制造路径。</p>
<p>无自环，无重复边。</p>
<p>在制造路径的时候，小明不想看到一个环的路径都是由一种材料制造成的，这样小明就会生气。</p>
<p>现在问你这个k最小值应该是多少呢。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>（来补一下题解</p>
<p>题目的要求是每个环的路径的材料不能完全相同，那么我们可以将不是环的点的k值赋为1，在环中的最多也是2。</p>
<p>那么存在环k最大为2，不存在则k为1。</p>
<p>首先，我们可以使用拓扑排序来判环。</p>
<p>（写这题之前完全就没听过。。</p>
<p>判断是否有环之后，如果不存在环，则每个点都为1。</p>
<p>如果存在环，那么可以用dfs来在环内赋值。</p>
<p>有一个很巧妙的方法来赋值。</p>
<p>（我也是看到了别人的题解才想到的。。</p>
<p>就是如果这个点比其他点大，就赋为1，否则赋为2。</p>
<p>显然，在一个环中，是不可能出现单增或者单降的，所以整个环必然不可能是同一种颜色。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;Map[<span class="number">5050</span>];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q, p;</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">5050</span>][<span class="number">5050</span>];</span><br><span class="line"><span class="keyword">int</span> l[<span class="number">5050</span>], r[<span class="number">5050</span>], in[<span class="number">5050</span>], mark[<span class="number">5050</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; l[i] &gt;&gt; r[i];</span><br><span class="line">		Map[l[i]].push_back(r[i]);</span><br><span class="line">		in[r[i]]++;</span><br><span class="line">		ans[l[i]][r[i]] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;<span class="comment">//拓扑排序</span></span><br><span class="line">		<span class="keyword">if</span> (!in[i]) &#123;</span><br><span class="line">			mark[i] = <span class="number">1</span>;</span><br><span class="line">			q.push(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> node = q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		p.push(node);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> it = Map[node].<span class="built_in">begin</span>(); it != Map[node].<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">			in[*it]--;</span><br><span class="line">			<span class="keyword">if</span> (!in[*it]) &#123;</span><br><span class="line">				mark[*it] = <span class="number">1</span>;</span><br><span class="line">				q.push(*it);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (p.<span class="built_in">size</span>() == n)	flag = <span class="number">1</span>;<span class="comment">//判断是否有环</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!mark[i]) &#123;</span><br><span class="line">				q.push(i);				</span><br><span class="line">				<span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">					<span class="keyword">int</span> m = q.front();</span><br><span class="line">					q.pop();</span><br><span class="line">					mark[m] = <span class="number">1</span>;</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">auto</span> it = Map[m].<span class="built_in">begin</span>(); it != Map[m].<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">						<span class="keyword">if</span> (m &gt; (*it))	ans[m][*it] = <span class="number">1</span>;</span><br><span class="line">						<span class="keyword">else</span> ans[m][*it] = <span class="number">2</span>;</span><br><span class="line">						<span class="keyword">if</span>(!mark[*it])	q.push(*it);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (flag)	<span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans[l[i]][r[i]];</span><br><span class="line">		<span class="keyword">if</span> (i != m - <span class="number">1</span>)	<span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-1221C Perfect Team 题解</title>
    <url>/2020/07/08/CF-1221C-Perfect-Team-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://vjudge.net/problem/CodeForces-1221C/origin" target="_blank" rel="noopener">题目大意</a></h3><p>每个队伍有三种人，c，m，x，其中x可以被c和m替换掉，输入c，m，x的数量，请问最多可以组成多少个队伍。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>（其实我只想到的贪心的思路，TLE了。。</p>
<p>这里说一下吧。</p>
<p>首先优先使用c，m，x，直到其中有一个为0的时候结束。如果c或者m为0，则无法继续。</p>
<p>如果x为0，则可以使用c或者m代替x，用数量多的来代替，使c，m趋向相同。</p>
<p>思路大概就是这样，但是超时了。。</p>
<p>（不甘心啊啊</p>
<p>看了看别人大佬的思路。。</p>
<p>最大团队数为$min(c,m)$，此外，构成团队还需要3个人，所以还要和$(c+m+x)/3$取$min$。</p>
<p>这个还能推广到n个人的队伍。</p>
<p>$min(min(c,m),(c+m+x)/3)$</p>
<p>我的思路是，先用完x之后，剩下的就是$(c+m)/3$了，加上即可。</p>
<p>（其实是一样的。。这个除以3就是取平均的意思</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> a, b, c;</span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">		<span class="keyword">int</span> m = <span class="built_in">min</span>(a, b);</span><br><span class="line">		m = <span class="built_in">min</span>(m, c);</span><br><span class="line">		a -= m, b -= m, c -= m, ans += m;</span><br><span class="line">		<span class="keyword">if</span> (!a || !b) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (a &gt;= <span class="number">2</span> * b)	ans += b;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (b &gt;= <span class="number">2</span> * a)	ans += a;</span><br><span class="line">			<span class="keyword">else</span> ans += (a + b) / <span class="number">3</span>;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>公式</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-1206D Shortest Cycle 题解</title>
    <url>/2020/07/08/CF-1206D-Shortest-Cycle-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforces.com/problemset/problem/1206/D" target="_blank" rel="noopener">题目大意</a></h3><p>给你n个数，如果两个数之间进行与运算的结果不为0，即ai&amp;aj≠0，则说明两点之间有一条无向边。问最小环的权值，如果不存在则输出-1。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>（比赛的时候看到这个题目完全是懵的。。直接跳了</p>
<p>学长简直是魔鬼啊。。又考了一个我不会的。</p>
<p>自闭ing。。</p>
<p>也好，又学了点新知识。</p>
<p>首先用Floyd是可以求最小环的，但是n的范围为1e5，不可能就这么简单的用FLoyd。</p>
<p>（其实之前完全不知道Floyd可以求最小环。。</p>
<p>a的范围为1e18，也就是说最多二进制60位。</p>
<p>由题意可得，ai&amp;aj≠0就可以确定一条无向边，所以对于非0点来说，只要有一位同时存在三个1，那么那三个点就必然成环。即n&gt;(60+60)，就必定最小环是3。</p>
<p>如果n&lt;120，就可以直接建图，用<a href="https://www.cnblogs.com/FuTaimeng/p/5610406.html" target="_blank" rel="noopener">Floyd求最小环</a>。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>,INF = <span class="number">1e8</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[N];</span><br><span class="line"><span class="keyword">int</span> Map[<span class="number">200</span>][<span class="number">200</span>], dis[<span class="number">200</span>][<span class="number">200</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,cnt = <span class="number">0</span> ;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> m;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">		<span class="keyword">if</span> (m)	a[cnt++] = m;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (cnt &gt; <span class="number">120</span>) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="number">3</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) &#123;<span class="comment">//初始化</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++)</span><br><span class="line">			Map[i][j] = dis[i][j] = INF;</span><br><span class="line">		Map[i][i] = dis[i][i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; cnt; j++)</span><br><span class="line">			<span class="keyword">if</span> ((a[i] &amp; a[j]) != <span class="number">0</span>)</span><br><span class="line">				Map[i][j] = Map[j][i] = dis[j][i] = dis[i][j] = <span class="number">1</span>;<span class="comment">//建图</span></span><br><span class="line">	<span class="keyword">int</span> m = INF;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cnt; k++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;<span class="comment">//求最小环</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; k; j++) &#123;</span><br><span class="line">				m = <span class="built_in">min</span>(m, Map[i][k] + Map[k][j] + dis[i][j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) &#123;<span class="comment">//正常的Floyd</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++) &#123;</span><br><span class="line">				dis[i][j] = <span class="built_in">min</span>(dis[i][j], dis[i][k] + dis[k][j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (m == INF)	<span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; m;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Floyd</tag>
        <tag>最小环</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-1243B2 Character Swap (Hard Version) 题解</title>
    <url>/2020/07/13/CF-1234B2-Character-Swap-(Hard-Version)-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforces.com/contest/1243/problem/B2" target="_blank" rel="noopener">题目大意</a></h3><p>给你一个长度为n的两个字符串，你可以交换$s1[i],s2[j]$，最多可以交换2n次，需要你判断能否使两字符串相同，能的话输出交换顺序。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>说实话这个题目还真不难。。</p>
<p>但是我就是没想到啊啊啊。</p>
<p>感觉自己脑袋越来越不好用了。</p>
<p>这个字符串长度不长，可以直接用模拟。</p>
<p>模拟两个字符串的交换过程，并且记录交换顺序即可。</p>
<p>当他们两个位置相同的时候不需要去交换。</p>
<p>然后交换的时候分两种情况，具体看代码吧。</p>
<p>顺便记录一下，了解到了一个新算法：sunday算法，用来匹配字符串的，有机会之后再补。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;v;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		<span class="keyword">char</span> s1[<span class="number">100</span>], s2[<span class="number">100</span>];</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; s1+<span class="number">1</span> &gt;&gt; s2+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> cnt[<span class="number">200</span>];</span><br><span class="line">		<span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">		v.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			cnt[s1[i]]++, cnt[s2[i]]++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="string">'a'</span>; i &lt;= <span class="string">'z'</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (cnt[i] &amp; <span class="number">1</span>) &#123;</span><br><span class="line">				flag = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"No"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Yes"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (s1[i] != s2[i]) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">					<span class="keyword">if</span> (s1[i] == s1[j]) &#123;</span><br><span class="line">						swap(s2[i], s1[j]);</span><br><span class="line">						v.push_back(make_pair(j, i));</span><br><span class="line">						c++;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (s1[i] == s2[j]) &#123;</span><br><span class="line">						swap(s1[i + <span class="number">1</span>], s2[j]);</span><br><span class="line">						v.push_back(make_pair(i+<span class="number">1</span>, j));</span><br><span class="line">						swap(s2[i], s1[i + <span class="number">1</span>]);</span><br><span class="line">						v.push_back(make_pair(i+<span class="number">1</span>, i));</span><br><span class="line">						c += <span class="number">2</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> x : v) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; x.first &lt;&lt; <span class="string">' '</span> &lt;&lt; x.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-1251C Minimize The Integer 题解</title>
    <url>/2020/07/10/CF-1251C-Minimize-The-Integer-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="">题目大意</a></h3><p>给你一串数字序列，如果两个数奇偶性不同，就可以交换位置，问这一串数字序列最小值是多少。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>属实没想到这个题的正解。。</p>
<p>卡了我好久。</p>
<p>想的时候就没啥好思路。</p>
<p>好久没写题了。。脑子有点僵化了。（其实本来就不是很好用</p>
<p>因为只能交换奇偶性不同的数字的位置。</p>
<p>那么奇数列和偶数列中的每一个元素的相对位置是不变的，</p>
<p>所以只需要判断哪个小，便填入那个小的数即可。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (c == <span class="string">'1'</span> || c == <span class="string">'3'</span> || c == <span class="string">'5'</span> || c == <span class="string">'7'</span> || c == <span class="string">'9'</span>)	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;q1, q2, q3;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="built_in">string</span> s;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">		<span class="keyword">int</span> l = s.length();</span><br><span class="line">		q1.<span class="built_in">clear</span>();</span><br><span class="line">		q2.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (check(s[i]))	q1.push_back(s[i]);</span><br><span class="line">			<span class="keyword">else</span> q2.push_back(s[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> i, j;</span><br><span class="line">		i = j = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; q1.<span class="built_in">size</span>() &amp;&amp; j &lt; q2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (q1[i] &lt; q2[j])	<span class="built_in">cout</span> &lt;&lt; q1[i], i++;</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; q2[j], j++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; q1.<span class="built_in">size</span>())	<span class="keyword">for</span> (<span class="keyword">int</span> g = i; g &lt; q1.<span class="built_in">size</span>(); g++)	<span class="built_in">cout</span> &lt;&lt; q1[g];</span><br><span class="line">		<span class="keyword">if</span> (j &lt; q2.<span class="built_in">size</span>())	<span class="keyword">for</span> (<span class="keyword">int</span> g = j; g &lt; q2.<span class="built_in">size</span>(); g++)	<span class="built_in">cout</span> &lt;&lt; q2[g];</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-1260C Infinite Fence 题解</title>
    <url>/2020/07/13/CF-1260C-Infinite-Fence-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforces.com/problemset/problem/1260/C" target="_blank" rel="noopener">题目大意</a></h3><p>从0开始有$10^{100}$堵墙，当序号为b的倍数时，涂成蓝色，当序号为r的倍数时，涂成红色，当既是b的倍数又是r的倍数时，可以任意选择颜色。问连续相同颜色的墙的数量是否大于k。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这个题是真的坑。。</p>
<p>我想了好久，但是我的思路一直wa。。</p>
<p>没想到什么好的方法，最后还是去看了题解。。</p>
<p>发现我的思路很接近正解了，就是找的区间不一样。</p>
<p>正解的区间是两个区间起点最近的一个区间，我是$[b,2b]$。。</p>
<p>其实这种题还是挺考验数学思维的。</p>
<p>首先，我们假设r小于b。</p>
<p>显然，最长的连续的区间肯定是在两个b的倍数之间的。</p>
<p>那么对于r来说，最长的区间长度就是b-1。</p>
<p>接下来就需要找到r的区间了。</p>
<p>设b的区间为$[n_1b,n_2b]$。</p>
<p>设距离左端点最近的距离为l。</p>
<p>那么则有$n_1b+t=kr$，由拓欧得，式子可以变为$n_1b+kr=t$，当$gcd(b,r)|t$时有解，t最小为$gcd(b,r)$。</p>
<p>得到r的区间长度为$(b-1)-gcd(b,r)$。</p>
<p>所以这个区间的红色木板的个数为$\frac{(b-1)-gcd(b,r)}{r}+1$,显然，这个也是最大的连续的个数。</p>
<p>判断这个与k的大小关系即可。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !b ? a: gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t,m;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		ll r, b, k;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; r &gt;&gt; b &gt;&gt; k;</span><br><span class="line">		<span class="keyword">if</span> (r &gt; b)	swap(r, b);</span><br><span class="line">		ll ans = (b - <span class="number">1</span> - gcd(r, b)) / r + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (ans&gt;=k)	<span class="built_in">cout</span> &lt;&lt; <span class="string">"REBEL"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"OBEY"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-1287C Garland 题解</title>
    <url>/2020/07/08/CF-1287C-Garland-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforc.es/contest/1287/problem/C" target="_blank" rel="noopener">题目大意</a></h3><p>给你一个数列，数列中每一个数不能重复，大小为1~n，0则表示该位置为空，需要填上数字。问你如何填满数列，使相邻两个数奇偶性不同的个数最小。求这个最小值。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这个题目有两个方法，一个是DP，一个是贪心。</p>
<p>贪心代码太麻烦了，就不用贪心了。</p>
<p>我们可以用dp[i] [j] [flag]表示，前i位中有j个偶数并且当前为奇数或偶数的最优解，即最小的个数。当flag为0时，为偶数，flag为1时，为奇数。</p>
<p>（三维DP。。第一次写这种题。。完全没有思路，看的别人大佬的代码。。</p>
<p>这样就可以得出状态转移方程</p>
<blockquote>
<p>当该位为奇数或者为0时</p>
<p>dp[i] [j] [1] = min(dp[i] [j] [1],dp[i-1] [j] [1]);（前一个数为奇数时）</p>
<p>dp[i] [j] [1] = min(dp[i] [j] [1],dp[i-1] [j] [0]+1);（前一个数为偶数时）</p>
<p>当该位为偶数或者为0时</p>
<p>dp[i] [j+1] [0] = min(dp[i] [j+1] [0],dp[i-1] [j] [0]);（前一个数为偶数时）</p>
<p>dp[i] [j+1] [0] = min(dp[i] [j+1] [0],dp[i-1] [j] [1]+1);（前一个数为奇数时）</p>
</blockquote>
<p>（太难想了吧。。根本想不到</p>
<p>答案为min(dp[n] [n/2] [1],dp[n] [n/2] [0])。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num[<span class="number">110</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">110</span>][<span class="number">110</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; num[i];</span><br><span class="line">	<span class="built_in">memset</span>(dp, <span class="number">127</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="comment">//补充知识</span></span><br><span class="line">    <span class="comment">//一般用memset只赋值0，1，-1，127</span></span><br><span class="line">    <span class="comment">//127表示填充最大值，即INF</span></span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n / <span class="number">2</span> ; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (num[i] % <span class="number">2</span> == <span class="number">0</span> || !num[i]) &#123;</span><br><span class="line">				dp[i][j + <span class="number">1</span>][<span class="number">0</span>] = <span class="built_in">min</span>(dp[i][j + <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][j][<span class="number">0</span>]);<span class="comment">//前一个数为偶数时</span></span><br><span class="line">				dp[i][j + <span class="number">1</span>][<span class="number">0</span>] = <span class="built_in">min</span>(dp[i][j + <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][j][<span class="number">1</span>] + <span class="number">1</span>);<span class="comment">//前一个数为奇数时</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (num[i] % <span class="number">2</span> == <span class="number">1</span> || !num[i]) &#123;</span><br><span class="line">				dp[i][j][<span class="number">1</span>] = <span class="built_in">min</span>(dp[i][j][<span class="number">1</span>], dp[i - <span class="number">1</span>][j][<span class="number">1</span>]);<span class="comment">//前一个数为奇数时</span></span><br><span class="line">				dp[i][j][<span class="number">1</span>] = <span class="built_in">min</span>(dp[i][j][<span class="number">1</span>], dp[i - <span class="number">1</span>][j][<span class="number">0</span>] + <span class="number">1</span>);<span class="comment">//前一个数为偶数时</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">min</span>(dp[n][n / <span class="number">2</span>][<span class="number">1</span>], dp[n][n / <span class="number">2</span>][<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-1251B Binary Palindromes 题解</title>
    <url>/2020/07/08/CF-1251B-Binary-Palindromes-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你n个01串，你可以交换每个串中任意一个数字的位置，无论是不是同一个串，问能构成多少个回文串。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>吐了。。</p>
<p>刚刚看到这个题目的时候，数据这么小，我以为是一些时间复杂度比较大的算法。</p>
<p>自己直接去模拟去了。</p>
<p>结果不好模拟，没啥思路。。</p>
<p>卡了好久，去看了眼题解。</p>
<p>发现自己就根本没往这方面想。。</p>
<p>我们可以统计所有串中的0和1的数量。</p>
<p>可以分为三种情况。</p>
<p>1、0为偶，1为偶</p>
<blockquote>
<p>显然，这些串是由l个偶长度串和m个奇长度串（m为偶数）构成的，不管m是否为0，都可以满足条件，所以n个串都可以是回文串。</p>
</blockquote>
<p>2、0为奇，1为偶（0为偶，1为奇）</p>
<blockquote>
<p>这些串是由l个偶长度串和m个奇长度串（m为奇数）构成的，可以把其中的奇数的插到一个奇长度串的中间，可以等价于第一种情况，所以n个串都可以是回文串。</p>
</blockquote>
<p>3、0为奇，1为奇</p>
<blockquote>
<p>这些串也是由l个偶长度串和m个奇长度串（m为偶数）构成的，但是如果m为0是不行的，会有一个串无法构成回文串，所以需要判断一下m是否小于2，因为m为2*k</p>
</blockquote>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">t</span>&#123;</span></span><br><span class="line">	<span class="built_in">string</span> s;</span><br><span class="line">	<span class="keyword">int</span> l;</span><br><span class="line">&#125;s[<span class="number">55</span>];<span class="comment">//之前写法留下来的，懒得改了，其实不需要这么麻烦的</span></span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		<span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)	<span class="built_in">cin</span> &gt;&gt; s[i].s, s[i].l = s[i].s.length();</span><br><span class="line">		<span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (s[i].l &amp; <span class="number">1</span>)	c++;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s[i].l; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (s[i].s[j] == <span class="string">'1'</span>)	cnt[<span class="number">1</span>]++;</span><br><span class="line">				<span class="keyword">else</span> cnt[<span class="number">0</span>]++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ((cnt[<span class="number">1</span>] &amp; <span class="number">1</span>) &amp;&amp; (cnt[<span class="number">0</span>] &amp; <span class="number">1</span>) &amp;&amp; c &lt; <span class="number">2</span>)	n--;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-12D Ball 题解</title>
    <url>/2020/07/08/CF-12D-Ball-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://codeforces.com/problemset/problem/12/D" target="_blank" rel="noopener">题目大意</a></h3><p>在一个舞会上，有许多女士，每个女士有三个属性（b，l，r），如果存在其他的女士三项属性都比她要高，那么她就会选择死亡。问有多少人会死亡。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这道题可以用线段树做，也可以用树状数组做，线段树太麻烦了，还是用树状数组写吧。</p>
<p>（其实是线段树不是很会。。</p>
<p>按b的大小来从大到小排序，记录下位置，以这个位置为下标构造树状数组，数组的值为r的值。</p>
<p>然后按l的大小从大到小排序，就已经确定一个属性了。</p>
<p>剩下的关系就通过线段树来判断。</p>
<p>（网上好像还有用map做的，代码不长，看不懂。。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> t[N], n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">it</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	<span class="keyword">int</span> l;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">&#125;p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">//单点修改</span></span><br><span class="line">	<span class="keyword">while</span> (pos &lt;= n) &#123;</span><br><span class="line">		t[pos] = <span class="built_in">max</span>(t[pos], x);</span><br><span class="line">		pos += lowbit(pos);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findmax</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;<span class="comment">//查询区间的最大值</span></span><br><span class="line">	<span class="keyword">int</span> M = <span class="number">-1e9</span>;</span><br><span class="line">	<span class="keyword">while</span> (pos) &#123;</span><br><span class="line">		M = <span class="built_in">max</span>(M, t[pos]);</span><br><span class="line">		pos -= lowbit(pos);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> M;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp1</span><span class="params">(it a, it b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.b &gt; b.b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp2</span><span class="params">(it a, it b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.l &gt; b.l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p[i].b);</span><br><span class="line">    <span class="comment">/*使用cin超时了，如果要使用cin的话</span></span><br><span class="line"><span class="comment">    需要加上ios::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">	cin.tie(0);</span></span><br><span class="line"><span class="comment">	cout.tie(0);</span></span><br><span class="line"><span class="comment">	换行用"\n"</span></span><br><span class="line"><span class="comment">	原理自行百度*/</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p[i].l);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p[i].r);</span><br><span class="line">	sort(p + <span class="number">1</span>, p + <span class="number">1</span> + n, cmp1);<span class="comment">//按x从大到小</span></span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;<span class="comment">//记录树状数组下标</span></span><br><span class="line">		<span class="keyword">if</span> (p[i].b == p[i - <span class="number">1</span>].b)	p[i].id = p[i - <span class="number">1</span>].id;<span class="comment">//判重</span></span><br><span class="line">		<span class="keyword">else</span> p[i].id = ++cnt;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(p + <span class="number">1</span>, p + <span class="number">1</span> + n, cmp2);<span class="comment">//按y从大到小</span></span><br><span class="line">	<span class="keyword">int</span> j,ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j = i; j &lt;= n &amp;&amp; p[j].l == p[i].l; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (findmax(p[j].id - <span class="number">1</span>) &gt; p[j].r)	ans++;</span><br><span class="line">            <span class="comment">//比她b要大的人中，如果存在最大值比她自己的r大的话，答案加一</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (j = i; j &lt;= n &amp;&amp; p[j].l == p[i].l; j++)</span><br><span class="line">			modify(p[j].id, p[j].r);</span><br><span class="line">		i = j;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-293A Weird Game 题解</title>
    <url>/2020/07/08/CF-293A-Weird-Game-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://codeforces.com/problemset/problem/293/A" target="_blank" rel="noopener">题目大意</a></h3><p>输入两串长度为2*n的0,1序列，一串是Y的，一串是A的。Y先手，A后手，每人可以任意选一个位置，选了之后两人都不能再选这个位置，比较他们的选择的串的大小。每人都是最优选择。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>很明显的博弈题目。。但是WA了我好几发。</p>
<p>（确实博弈相当苦手</p>
<p>分四种情况</p>
<blockquote>
<p>1、1–1，这个肯定是优先选的，这样自己能选一个1，又能让对方少一个1.</p>
<p>2、1–0，这个除了1–1Y会优先选择，可以让Y多一个1.</p>
<p>3、0–1，这个除了1–1A会优先选择，可以让A多一个1.</p>
<p>4、0–0，这个肯定是最后选的。</p>
</blockquote>
<p>把2记为ans1，3记为ans2。</p>
<p>如果1–1为奇数的话，就相当于第二种情况多加了一个，因为Y是先手，会优先选择这个。也就是ans1++。</p>
<p>答案情况也分为四种</p>
<blockquote>
<p>1、ans1&gt;ans2 这个情况，Y的1的数量大于A的1的数量，Y获胜。</p>
<p>2、ans1==ans2 这个情况，Y的1的数量等于A的1的数量，平局。</p>
<p>3、ans1==ans2-1 这个情况，A多了一个0–1，因为Y为先手，可以取掉这个，使Y和A相等，平局。（这个情况卡了我好久啊啊）</p>
<p>4、ans1&lt;ans2-1 这个情况，Y的1数量小于A的数量，且差值大于1，故A获胜。</p>
</blockquote>
<p>（博弈是真的难。。感觉自己智商不够。。太难想了</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> ch1[N], ch2[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; ch1 &gt;&gt; ch2;</span><br><span class="line">	<span class="keyword">int</span> ans1, ans2, cnt;</span><br><span class="line">	ans1 = ans2 = cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ch1[i] == <span class="string">'1'</span> &amp;&amp; ch2[i] == <span class="string">'0'</span>)	ans1++;</span><br><span class="line">		<span class="keyword">if</span> (ch1[i] == <span class="string">'0'</span> &amp;&amp; ch2[i] == <span class="string">'1'</span>)	ans2++;</span><br><span class="line">		<span class="keyword">if</span> (ch1[i] == <span class="string">'1'</span> &amp;&amp; ch2[i] == <span class="string">'1'</span>)	cnt++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (cnt % <span class="number">2</span> != <span class="number">0</span>)	ans1 ++;</span><br><span class="line">	<span class="keyword">if</span> (ans1 &gt; ans2)	<span class="built_in">cout</span> &lt;&lt; <span class="string">"First"</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (ans2 &gt; ans1 + <span class="number">1</span>)	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Second"</span>;</span><br><span class="line">	<span class="keyword">else</span>  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Draw"</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-1353D Constructing the Array 题解</title>
    <url>/2020/07/08/CF-1353D-Constructing-the-Array-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforc.es/problemset/problem/1353/D" target="_blank" rel="noopener">题目大意</a></h3><p>给你一个长度为n的数组，这个数组中每一位都为0，你需要选择仅由0组成的最长子数组，如果最大长度相同的话，选择最左边那一个。</p>
<p>对你每一个选择的子数组来说，如果长度为奇，则$a[\frac{l+r}{2}]$赋值为$i$。如果长度为偶，则$a[\frac{l+r-1}{2}]$赋值为$i$。$i$为进行的第几步。</p>
<a id="more"></a>

<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>这题本来没什么思路的。。。</p>
<p>群里大佬提醒了一下可以用优先队列</p>
<p>我就试了一下，一遍过了。。</p>
<p>其实思路很简单，构造一个按照长度由长到短，相等的时候优先靠左的优先队列。</p>
<p>定义一个结构体，储存$l,r,len$。优先队列的类型即为这个结构体。</p>
<p>起点为$l = 1,r = n,len = n$。</p>
<p>每次从队列中取出一个，按照题意分为左右两块区域。</p>
<p>然后一步一步插入即可。</p>
<p>需要手写一个判断的类函数。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">a</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> l, r, len;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(a n, a m)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (n.len == m.len)	<span class="keyword">return</span> n.l &gt; m.l;</span><br><span class="line">		<span class="keyword">return</span> n.len &lt; m.len;<span class="comment">//注意，和排序的时候是相反的</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;a, <span class="built_in">vector</span>&lt;a&gt;, cmp&gt; q;<span class="comment">//优先队列</span></span><br><span class="line"><span class="keyword">int</span> num[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		a m;</span><br><span class="line">		m.l = <span class="number">1</span>, m.r = n, m.len = n;</span><br><span class="line">		q.push(m);</span><br><span class="line">		<span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="keyword">sizeof</span>(num));</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			a t = q.top();</span><br><span class="line">			q.pop();</span><br><span class="line">			<span class="keyword">int</span> mid = (t.l + t.r) / <span class="number">2</span>;</span><br><span class="line">			num[mid] = i;</span><br><span class="line">			a m1, m2;</span><br><span class="line">			m1.l = t.l, m1.r = mid - <span class="number">1</span>, m1.len = mid - t.l;</span><br><span class="line">			m2.l = mid + <span class="number">1</span>, m2.r = t.r, m2.len = t.r - mid;</span><br><span class="line">			q.push(m1);</span><br><span class="line">			q.push(m2);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="built_in">string</span> s = i == n ? <span class="string">"\n"</span> : <span class="string">" "</span>;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; num[i] &lt;&lt; s;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (!q.empty())	q.pop();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>优先队列</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-455A Boredom 题解</title>
    <url>/2020/07/08/CF-455A-Boredom-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://codeforces.com/problemset/problem/455/A" target="_blank" rel="noopener">题目大意</a></h3><p>给你一个数组a，里面有n个整数。你每次可以选择数组中的一个元素ak，从数组中删掉它，再删掉所有值等于ak + 1 或者 ak - 1的元素，这样你可以得到 ak 分。你可以重复进行多次该操作，请问你最后最多能得多少分？</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>每个数字都分为两种情况，选和不选。</p>
<p>（这样其实和01背包有点类似</p>
<p>这样我们可以用一个数组，储存每个数字的出现次数。</p>
<p>用DP的思想，令数组dp[i]为1~i的最大分数。</p>
<p>对于每一个数来说，分为两种情况</p>
<blockquote>
<p>1、选这个数 那么i-1这个数就不能选，dp[i]=dp[i-2]+cnt[i]*i。</p>
<p>2、不选这个数 那么dp[i]=dp[i-1]。</p>
</blockquote>
<p>得出状态转移方程dp[i]=max(dp[i-1],dp[i-2]+cnt[i]*i)。</p>
<p>答案为dp[n]。</p>
<p>（DP苦手啊。。</p>
<p>本来可以一遍过的。。</p>
<p>结果没考虑数据范围，卡了我半个多小时。。</p>
<p>一定要注意啊啊啊</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,m=<span class="number">-1e9</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> a;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">		cnt[a]++;</span><br><span class="line">		m = <span class="built_in">max</span>(m, a);</span><br><span class="line">	&#125;</span><br><span class="line">	dp[<span class="number">1</span>] = cnt[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">2</span>; i &lt;= m; i++) &#123;</span><br><span class="line">		dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">2</span>] + cnt[i] * i, dp[i - <span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; dp[m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-466C Number of Ways 题解</title>
    <url>/2020/07/14/CF-466C-Number-of-Ways-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforces.com/problemset/problem/466/C" target="_blank" rel="noopener">题目大意</a></h3><p>给你n个数，问你有多少种方式将其分为大小相同的三份$[l,i],[i,j],[j,r]$。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>之前写这个题目的时候完全没有思路。</p>
<p>比完一看题解。。。这个方法是真的妙。</p>
<p>我们可以先用前缀和，然后从一开始暴力枚举。</p>
<p>当枚举的前面部分的和为总和的三分之二时，则后面部分则必为总和的三分之一，这时只需要加上前面的和为总和三分之一的个数即可。</p>
<p>当枚举的前面的部分为总和的三分之一的时候，只需要统计个数。</p>
<p>需要注意这两条语句的个数，为三分之一的时候必须要在后面，不然会重复统计。</p>
<p>数据有点大，注意开ll。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll sum[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> a;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">		sum[i] = sum[i - <span class="number">1</span>] + a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (sum[n] % <span class="number">3</span> != <span class="number">0</span> || n &lt; <span class="number">3</span>) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	ll ans, c;</span><br><span class="line">	ans = c = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (sum[i] == sum[n] / <span class="number">3</span> * <span class="number">2</span>)	ans += c;</span><br><span class="line">		<span class="keyword">if</span> (sum[i] == sum[n] / <span class="number">3</span>)	c++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-634E1/2 Three Blocks Palindrome (easy/hard version) 题解</title>
    <url>/2020/07/08/CF-634E12-Three-Blocks-Palindrome-(easyhard-version)-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforc.es/contest/1335/problem/E1" target="_blank" rel="noopener">题目大意</a></h3><p>定义一个三段串为一种序列，每一个序列为x个a，y个b，x个a组成，x，y大于等于0.</p>
<p><img src="https://ae01.alicdn.com/kf/Hf028e3af9072427888a4f2963736ff3ek.png" alt=""></p>
<p>可以是全为a这样一种数字，或者是2个x个a夹着y个b，也就是一种对称的数字夹着另一种数字。</p>
<p>求这种序列的最长长度。</p>
<a id="more"></a>

<p>（说实话，我写的时候可能题目都没看懂。。</p>
<p>导致往最长回文子序列去想了。。。以后还是要注意看题。</p>
<p>有一次div2的A，光看懂题就看了半个多小时。</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>用vector数组去记录每一个数字的位置。</p>
<p>分两种情况去考虑：</p>
<p>第一种：全为一种数字</p>
<blockquote>
<p>很简单，只用判断哪一种数字的v.size()最大即可。</p>
</blockquote>
<p>第二种：一种数字夹着另一种数字</p>
<blockquote>
<p>设每一种数字的数量为cnt=v.size()。</p>
<p>那么左右两边最大长度为c=cnt/2。</p>
<p>如果c&lt;=1，那么就不用考虑，直接continue。</p>
<p>cnt分为奇数和偶数。</p>
<p>当cnt为奇数的时候，左区间为0 ~ c-1，右区间为c+1 ~ cnt-1。</p>
<p>当cnt为偶数的时候，左区间为0 ~ c-1，右区间为c ~ cnt-1。</p>
<p>但实际上，我们可以将他们都表示为左区间为0 ~ c-1，右区间为cnt-c ~ cnt-1。</p>
<p>论证如下：(其实看规律也看得出)</p>
<p>当cnt为奇数的时候，cnt-c=2*c+1-c=c+1。</p>
<p>当cnt为偶数的时候，cnt-c=2*c-c=c。</p>
<p>第一个状态就是从区间[v.[c-1]+1~v.[cnt-c]-1]中找出出现最多次数的数字的个数为M。</p>
<p>用n数组表示大小为i的数字的个数。</p>
<p>那么答案为M+2*c。</p>
<p>之后的状态便是枚举长度，从j = c-1开始，枚举到1。</p>
<p>不断更新答案，答案为M+2*j。</p>
</blockquote>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p>主要还是看代码吧。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> num[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v[<span class="number">220</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">200</span>; i++)	v[i].<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; num[i];</span><br><span class="line">			v[num[i]].push_back(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">-1e9</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">200</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> cnt = v[i].<span class="built_in">size</span>(), c;</span><br><span class="line">			ans = <span class="built_in">max</span>(ans, cnt);</span><br><span class="line">			c = cnt / <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span> (cnt &lt;= <span class="number">1</span>)	<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">int</span> n[<span class="number">220</span>] = &#123; <span class="number">0</span> &#125;, M = <span class="number">-1e9</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = v[i][c - <span class="number">1</span>] + <span class="number">1</span>; j &lt; v[i][cnt - c]; j++) &#123;</span><br><span class="line">				n[num[j]]++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">200</span>; j++)	M = <span class="built_in">max</span>(M, n[j]);</span><br><span class="line">			ans = <span class="built_in">max</span>(ans, M + <span class="number">2</span> * c);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = c - <span class="number">1</span>; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> g = v[i][j - <span class="number">1</span>] + <span class="number">1</span>; g &lt; v[i][j]; g++)	n[num[g]]++;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> g = v[i][cnt - j - <span class="number">1</span>] + <span class="number">1</span>; g &lt; v[i][cnt - j]; g++)	n[num[g]]++;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> g = <span class="number">1</span>; g &lt;= <span class="number">200</span>; g++)	M = <span class="built_in">max</span>(M, n[g]);</span><br><span class="line">				ans = <span class="built_in">max</span>(ans, M + <span class="number">2</span> * j);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-484A Bits 题解</title>
    <url>/2020/07/15/CF-484A-Bits-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforces.com/problemset/problem/484/A" target="_blank" rel="noopener">题目大意</a></h3><p>给你一个范围$[l,r]$，问在这个范围中二进制中1最多且最小的数是什么。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>想了几种方法都是错的。。</p>
<p>想到了可以用全是1的数来计算。</p>
<p>但是没想到这个方法。。</p>
<p>感觉写题就总是抓不住那重要的一点。。</p>
<p>不过写题还是有好处，确实位运算不是很熟悉。</p>
<p>暴露了很多自己的弱点。</p>
<p>先假设一个全是1的数，如果这个数在范围中，那么这个数就是答案。</p>
<p>如果把第i位换成0，这个数会小于l，则这一位是不能换的。</p>
<p>否则就将这一位换成0。</p>
<p>这个方法真的好妙啊。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		ll l, r;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">		ll ans = (<span class="number">1L</span>L &lt;&lt; <span class="number">63</span>) - <span class="number">1L</span>L;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">62</span>; ~i; i--) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ans &gt;= l &amp;&amp; ans &lt;= r)	<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">if</span> ((ans ^ (<span class="number">1L</span>L &lt;&lt; i)) &lt; l)	<span class="keyword">continue</span>;</span><br><span class="line">			ans ^= (<span class="number">1L</span>L &lt;&lt; i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-636D Constant Palindrome Sum 题解</title>
    <url>/2020/07/08/CF-636D-Constant-Palindrome-Sum-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforces.ml/contest/1343/problem/D" target="_blank" rel="noopener">题目大意</a></h3><p>给你n个不超过k的数（n为偶数），要求a[i]+a[n-i+1]都等于一个数x，你可以替换任意一个数，使其变成1到k中任意一个数，问你最少替换多少个数，使数组满足条件。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>（我写到这里用了45分钟，后面就动不了了。。。我还是太菜了。。</p>
<p>我是没想到用差分。。</p>
<p>用一个数组d[i]来表示，x为i时，需要替换多少个数字。</p>
<p>令sum=a[i]+a[n-i+1]，maxn=max（a[i]，a[n-i+1]），minn=min（a[i]，a[n-i+1]）。</p>
<p>我们取极端情况，当大的那个数字为1时，在修改一个数字的时候，和最小，为minn+1。</p>
<p>当小的那个数字为k时，在修改一个数字的时候，和最大，为maxn+k。</p>
<p>所以</p>
<blockquote>
<p>1、x在[2,minn]时，需要修改两个数字，d[2]+=2，d[minn+1] -=2。</p>
<p>2、x在[minn+1,maxn+k]时，需要修改一个数字，d[minn+1]++，d[maxn+k+1]- -。</p>
<p>3、x在[maxn+k+1,2 * k]时，需要修改两个数字，d[maxn+k+1]+=2，d[2 * k+1]-=2（这个可以不用）。</p>
<p>4、x为sum时，不需要修改，但是sum在第二种情况中已经被修改了，所以需要补上来 ，d[sum]- -，d[sum+1]++。</p>
</blockquote>
<p>整理后</p>
<blockquote>
<p>d[2] += 2;<br>d[minn+1]- -;<br>d[maxn + k + 1]++;<br>d[sum]- -;<br>d[sum + 1]++;</p>
</blockquote>
<p>然后从2到2*k跑一边差分取最小值即可。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> num[N],d[<span class="number">2</span>*N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">int</span> n,k;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">		<span class="keyword">int</span> sum, maxn, minn;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; num[i];</span><br><span class="line">			<span class="keyword">if</span> (i &gt; n / <span class="number">2</span>) &#123;</span><br><span class="line">				sum = num[i] + num[n - i + <span class="number">1</span>];</span><br><span class="line">				maxn = <span class="built_in">max</span>(num[i], num[n - i + <span class="number">1</span>]);</span><br><span class="line">				minn = <span class="built_in">min</span>(num[i], num[n - i + <span class="number">1</span>]);</span><br><span class="line">				d[<span class="number">2</span>] += <span class="number">2</span>;<span class="comment">//差分</span></span><br><span class="line">				d[minn+<span class="number">1</span>]--;</span><br><span class="line">				d[maxn + k + <span class="number">1</span>]++;</span><br><span class="line">				d[sum]--;</span><br><span class="line">				d[sum + <span class="number">1</span>]++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">1e9</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">2</span> * k; i++) &#123;</span><br><span class="line">			d[i] += d[i - <span class="number">1</span>];</span><br><span class="line">			ans = <span class="built_in">min</span>(ans, d[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title>CF 888D Almost Identity Permutations 题解</title>
    <url>/2020/07/08/CF-888D-Almost-Identity-Permutations-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://codeforces.com/problemset/problem/888/D" target="_blank" rel="noopener">题目大意</a></h3><p>将n封信件的信和信封全部打乱之后，至少有n-k封信装在了原来的信封里的情况有多少？</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>一看题意觉得不难，就是计算不同的排列种类。</p>
<p>后来发现。。</p>
<p>我不会算啊。</p>
<p>其实因为数据不大，所以可以手推有多少种差排方式。</p>
<p>但是为了以后留下知识漏洞，这里补一下差排公式。</p>
<p>设$D(i)$为$i$个数的差排种类数量，$D(1)=0$,$D(2) = 1$。<br>$$<br>D(i)=(n-1)*(D(n-1)+D(n-2))<br>$$<br><a href="https://blog.csdn.net/bengshakalakaka/article/details/83420150" target="_blank" rel="noopener">推导过程</a>由此去。</p>
<p>知道错排公式就很简单了。</p>
<blockquote>
<p>有1个信封错排时，答案为$1$。</p>
<p>有2个信封错排时，答案为$1*C_n^2$。</p>
<p>有3个信封错排时，答案为$2*C_n^3$。</p>
<p>有4个信封错排时，答案为$9*C_n^4$。</p>
</blockquote>
<p>因为是至少$n-k$个，所以累加即可。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> n, k;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line">	<span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">		ans = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (k == <span class="number">2</span>) &#123;</span><br><span class="line">		ans = <span class="number">1</span> + (n * (n - <span class="number">1</span>)) / <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (k == <span class="number">3</span>) &#123;</span><br><span class="line">		ans = <span class="number">1</span> + (n * (n - <span class="number">1</span>)) / <span class="number">2</span> + (n * (n - <span class="number">1</span>) * (n - <span class="number">2</span>)) / <span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (k == <span class="number">4</span>) &#123;</span><br><span class="line">		ans = <span class="number">1</span> + (n * (n - <span class="number">1</span>)) / <span class="number">2</span> + (n * (n - <span class="number">1</span>) * (n - <span class="number">2</span>)) / <span class="number">3</span> + (<span class="number">9</span> * n * (n - <span class="number">1</span>) * (n - <span class="number">2</span>) * (n - <span class="number">3</span>)) / <span class="number">24</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>公式</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-919D Substring 题解</title>
    <url>/2020/07/15/CF-919D-Substring-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你一个n个点，m条边的有向图，给你一个字符串，分别代表每一个点的值，定义一个路的大小为这个路上出现的最多的字母个数，问这个图的最大值是否可以无限大，可以则输出-1，否则求这个图中所有路中的最大值。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这个题目还是有点难度的。</p>
<p>其实一开始是想到了需要用拓扑排序来判环，但是不知道如何求出最大路。</p>
<p>刚开始写的时候是理解成了最长路，后来发现不一定是最长的。</p>
<p>想了半天，都没想到dp的状态是咋写。</p>
<p>还是dp的题目写的不够多啊。 </p>
<p>后面还是学长指点了我一下，就大致懂了。</p>
<p>可以用$dp[i][j]$来表示第i个点，字母j的最多的数量。</p>
<p>这样，在拓扑排序的过程中不断更新，最后枚举出最大值即可。</p>
<p>这个题目的解法还是很妙啊。</p>
<p>需要注意，只有起点需要初始化。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;Map[N];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> in[N];</span><br><span class="line"><span class="keyword">int</span> dp[N][<span class="number">200</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="built_in">string</span> s;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> a, b;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">		Map[a].push_back(b);</span><br><span class="line">		in[b]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!in[i]) &#123;</span><br><span class="line">			q.push(i);</span><br><span class="line">			dp[i][s[i<span class="number">-1</span>]]++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> t = q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		c++;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> x : Map[t]) &#123;</span><br><span class="line">			in[x]--;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="string">'a'</span>; i &lt;= <span class="string">'z'</span>; i++)</span><br><span class="line">				dp[x][i] = <span class="built_in">max</span>(dp[x][i], dp[t][i]+(<span class="keyword">int</span>)(s[x<span class="number">-1</span>]==i));</span><br><span class="line">			<span class="keyword">if</span> (!in[x])	q.push(x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="string">'a'</span>; j &lt;= <span class="string">'z'</span>; j++)</span><br><span class="line">			ans = <span class="built_in">max</span>(ans, dp[i][j]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (c == n)	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-636E Weights Distributing 题解</title>
    <url>/2020/07/08/CF-636E-Weights-Distributing-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforces.ml/problemset/problem/1343/E" target="_blank" rel="noopener">题目大意</a></h3><p>给你一个n个点m条边的无向图，同时给你每条边的权值，你需要从a到b再到c，问你如何安排权值，使路径最短，求最短路径。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>可以分为两种情况</p>
<blockquote>
<p>第一种情况，a，b，c之间没有重复，a-&gt;b-&gt;c。</p>
<p>第二种情况，a，b，c之间有重复的点，a-&gt;x-&gt;b-&gt;x-&gt;c。</p>
</blockquote>
<p>其实两种情况是一样的，无论有没有重复的点，都可以使用第二种情况。</p>
<p>可以使用三个数组dis1[i]，dis2[i]，dis3[i]，分别来表示a，b，c到i节点最少需要走多少条边。</p>
<p>这样，这个题目就转变成了一个BFS的题目。</p>
<p>（搜索是真的不会，。。多练。。</p>
<p>将边权值从小到大排序后，可以使用前缀和，优化计算。</p>
<p>使用贪心的思想，因为b那段距离需要走两遍，所以优先给他最小的距离。</p>
<p>答案为num[dis1[i]+dis2[i]+dis3[i]]+num[dis2[i]]的最小值。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span>  vis[N], dis1[N], dis2[N], dis3[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> num[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> dis[])</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">	q.push(node);</span><br><span class="line">	vis[node] = <span class="number">1</span>;</span><br><span class="line">	dis[node] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		<span class="keyword">int</span> n = q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> x : v[n]) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!vis[x]) &#123;</span><br><span class="line">				q.push(x);</span><br><span class="line">				vis[x] = <span class="number">1</span>;</span><br><span class="line">				dis[x] = dis[n] + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n, m, a, b, c;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)	v[i].<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)	<span class="built_in">cin</span>&gt;&gt;num[i];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> l, r;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">			v[l].push_back(r);</span><br><span class="line">			v[r].push_back(l);</span><br><span class="line">		&#125;</span><br><span class="line">		sort(num + <span class="number">1</span>, num + <span class="number">1</span> + m);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)	num[i] += num[i - <span class="number">1</span>];<span class="comment">//前缀和</span></span><br><span class="line">		bfs(a, dis1);</span><br><span class="line">		bfs(b, dis2);</span><br><span class="line">		bfs(c, dis3);</span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1e18</span>;<span class="comment">//需要开long long，数据有点大		</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (dis1[i] + dis2[i] + dis3[i] &gt; m)	<span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//如果需要走的边数大于m，直接continue</span></span><br><span class="line">			ans = <span class="built_in">min</span>(ans, num[dis1[i] + dis2[i] + dis3[i]] + num[dis2[i]]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-992B Nastya Studies Informatics 题解</title>
    <url>/2020/07/14/CF-992B-Nastya-Studies-Informatics-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforces.com/problemset/problem/992/B?f0a28=1" target="_blank" rel="noopener">题目大意</a></h3><p>给你一个区间$[l,r]$，求其中有多少点对$(a,b)$，满足$gcd(a,b)=x,lcm(a,b)=y$。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>说实话，刚开始看到这个题目的时候，觉得这个题目应该不难。</p>
<p>wa了几发之后，人都傻了。</p>
<p>不过还是给我磨过去了，没有看题解。</p>
<p>说实话，我一直都有这种写不出看题解的习惯。</p>
<p>真的不好，但是还是有点难改。。</p>
<p>最近真的注意力不集中。。烦死了</p>
<p>写题也写不出来。</p>
<p>究极自闭。</p>
<p>首先，我们可以根据$a\times b=x\times y$这个性质，可以枚举a来确定b，这时只需要判断是否满足条件即可。</p>
<p>但是这个枚举，我之前就是从l枚举到r，当b&lt;a的时候推出，超时了。。</p>
<p>后来想到，a可以是x的倍数，然后就按照倍数枚举，就过了。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll l, r, x, y;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r &gt;&gt; x &gt;&gt; y;</span><br><span class="line">	ll mul = x * y, cnt = <span class="number">0</span>;</span><br><span class="line">	ll a = x, b;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; a &lt;= r; i++) &#123;</span><br><span class="line">		a = x * i;</span><br><span class="line">		b = mul / a;</span><br><span class="line">		<span class="keyword">if</span> (b &lt; a)	<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (a &gt;= l &amp;&amp; a &lt;= r &amp;&amp; b &gt;= l &amp;&amp; b &lt;= r &amp;&amp; b * a == mul &amp;&amp; gcd(b, a) == x) &#123;</span><br><span class="line">			<span class="keyword">if</span> (a == b)	cnt++;</span><br><span class="line">			<span class="keyword">else</span> cnt += <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>CFR-634E Restorer Distance 题解</title>
    <url>/2020/07/08/CFR-634E-Restorer-Distance-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforc.es/contest/1355/problem/E" target="_blank" rel="noopener">题目大意</a></h3><p>给你n个墙壁的高度，你可以花a块钱让墙壁高度减一，也可以花r块钱让墙壁高度减一，还可以花m块钱让高的墙壁转移一个高度给矮的墙壁，问你让墙壁的高度全都相等所花费的最小代价为多少。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>看到题目就知道是我不会写的题目。。</p>
<p>（其实之前是听过三分的，但是没有去学过。。</p>
<p>刚好补题的时候去学一下三分。</p>
<p>三分其实和二分很相似，都是将一块区间分隔开来，二分是分成两份，三分是分成三份，通过一步步排除区间来缩小时间复杂度。</p>
<p>但是二分适用于单调函数，三分适用于二次函数，可以用来求出二次函数的最值。</p>
<p>对于三分来说，凹函数和凸函数的情况是不一样的。</p>
<p>那对于这个题目来说，我们可以用三分来搜索某一个高度来使其他的墙等于这个高度的代价最小，很显然，这个关于h的函数是一个凹函数。</p>
<p>在计算花费时，我们可以先算出添加的数量和减少的数量，如果$m&lt;a+r$，那么肯定优先选择m，然后剩下的乘以a或者r。</p>
<p>否则直接按照a和r来计算。</p>
<p><a href="https://www.cnblogs.com/lukelmouse/p/12545973.html" target="_blank" rel="noopener">三分模板</a></p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> h[N],n,a,R,m;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">check</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">	ll add, minu, ans;</span><br><span class="line">	add = minu = ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (t &gt;= h[i])	add += t - h[i];<span class="comment">//需要添加的数量</span></span><br><span class="line">		<span class="keyword">else</span> minu += h[i] - t;<span class="comment">//需要减小的数量</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (m &lt; a + R) &#123;</span><br><span class="line">		ll x = <span class="built_in">min</span>(add, minu);</span><br><span class="line">		ans += x * m;</span><br><span class="line">		<span class="keyword">if</span> (add &gt;= minu)	ans += a * (add - x);</span><br><span class="line">		<span class="keyword">else</span> ans += R * (minu - x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> ans += add * a + minu * R;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; a &gt;&gt; R &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)	<span class="built_in">cin</span> &gt;&gt; h[i],r = <span class="built_in">max</span>(r,h[i]);<span class="comment">//区间的最大值为高度的最大值</span></span><br><span class="line">	<span class="keyword">while</span> (l &lt; r) &#123;<span class="comment">//l==r的时候退出</span></span><br><span class="line">		<span class="keyword">int</span> mid1 = l + (r - l) / <span class="number">3</span>, mid2 = r - (r - l) / <span class="number">3</span>;</span><br><span class="line">		<span class="keyword">if</span> (check(mid1) &gt;= check(mid2))	l = mid1 + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> r = mid2 - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; check(l) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>三分</tag>
      </tags>
  </entry>
  <entry>
    <title>CFR-643C Count Triangles 题解</title>
    <url>/2020/07/08/CFR-643C-Count-Triangles-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforc.es/contest/1355/problem/C" target="_blank" rel="noopener">题目大意</a></h3><p>给你四个数字$A,B,C,D$，$A≤x≤B≤y≤C≤z≤D$，其中$x,y,z$为三角形的三边，问$xyz$能够严格构成的三角形有多少个。（三顶点不共线）</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这次比赛就离谱，C题1800，D题1400。。</p>
<p>因为数据范围为$5·10^5$，所以复杂度尽量要控制在$O(n)$左右。</p>
<p>我们可以枚举x，$x∈[A,B]，y∈[B,C]$，将x作为常数，那么z的最大值范围为$[B-x-1,C-x-1]$。</p>
<p>分情况讨论</p>
<p>当$B-x-1≥D$时，显然y取任何值，z都是满足要求的。</p>
<blockquote>
<p>$ans =  (C-B+1)*(zr-zl+1)$</p>
</blockquote>
<p>当$B-x-1&lt;D$时，我们可以分为两部分来计算</p>
<p>1、在$[C,D]$中的部分，令$l = max(zl,C),r = min(zr,D)$。</p>
<p>在其中的部分，构成了一个以$l-C+1$为首项，$r-C+1$为末项的一个公差为1的等差数列，所以我们可以用等差数列求和公式来求和。</p>
<blockquote>
<p>$ans = (r-l+1)*(l-C+1+r-C+1)/2$</p>
</blockquote>
<p>2、在$[D+1,zr]$的部分</p>
<blockquote>
<p>$ans = (zr-D)*(D-C+1)$</p>
</blockquote>
<p>（哇。。这种数学题对我来说是真的苦手，数论咋办啊。。</p>
<p>区间问题一般都能杀我。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	ll A, B, C, D;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; A &gt;&gt; B &gt;&gt; C &gt;&gt; D;</span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> x = A; x &lt;= B; x++) &#123;</span><br><span class="line">		ll zl = x + B - <span class="number">1</span>, zr = x + C - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (zl &gt;= D)	ans += (D - C + <span class="number">1</span>) * (C - B + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			ll l = <span class="built_in">max</span>(zl, C), r = <span class="built_in">min</span>(zr, D);</span><br><span class="line">			ans += (r - l + <span class="number">1</span>) * (l - C + <span class="number">1</span> + r - C + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span> (zr &gt; D)	ans += (zr - D) * (D - C + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>CH-0104 起床困难综合症 题解</title>
    <url>/2020/07/08/CH-0104-%E8%B5%B7%E5%BA%8A%E5%9B%B0%E9%9A%BE%E7%BB%BC%E5%90%88%E7%97%87-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://noi-test.zzstep.com/contest/0x00%E3%80%8C%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95%E3%80%8D%E4%BE%8B%E9%A2%98/0104%20%E8%B5%B7%E5%BA%8A%E5%9B%B0%E9%9A%BE%E7%BB%BC%E5%90%88%E7%97%87" target="_blank" rel="noopener">题目大意</a></h3><p>让你在$[0,m]$中选一个数字，在经过n次位运算之后，（&amp;，|，^），问求出的最大值为多少。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这个题目是蓝书上的原题，最近开始补蓝书了。</p>
<p>如果可以的话，我会尽量把上面比较好，比较经典的题目都会重新写一遍。</p>
<p>这题是一道十分经典的位运算题。</p>
<p>首先，根据位运算的特性，即每一位的运算只与这一位有关，与其他位无关。</p>
<p>那么我们可以用每一位上的1和0来进行比较，判断该位上选0还是1更优。</p>
<p>如果初始为0的运算后能得到1，那么肯定选0。</p>
<p>如果初始为1的运算后能得到1，且得到的值t不会超过m，那么就可以选1。</p>
<p>其余情况都选择0。</p>
<p>遍历的话需要从高位到低位（但是跑出来的话从低到高也是对的，不知道是不是数据太水了。。</p>
<p>假如0的话每一位都是0，假如1的话每一位都是1。</p>
<p>m为1000 0000。</p>
<p>如果逆序的话，你可以得到1000 0000。</p>
<p>如果正序的话，你可以得到0111 1111。</p>
<p>很显然，逆序的值会大一些，所以需要逆序。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="built_in">string</span> s;</span><br><span class="line">	<span class="keyword">int</span> k;</span><br><span class="line">	<span class="keyword">int</span> ans0 = <span class="number">0</span>, ans1 = <span class="number">0x7FFFFFFF</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; s &gt;&gt; k;</span><br><span class="line">		<span class="keyword">if</span> (s == <span class="string">"AND"</span>)	ans0 &amp;= k, ans1 &amp;= k;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="string">"OR"</span>)	ans0 |= k, ans1 |= k;</span><br><span class="line">		<span class="keyword">else</span> ans0 ^= k, ans1 ^= k;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">1</span>; i--) &#123;<span class="comment">//逆序的贡献大一些，所以需要逆序</span></span><br><span class="line">		<span class="keyword">int</span> t = <span class="number">1</span> &lt;&lt; (i<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">if</span> ((ans0&gt;&gt;(i<span class="number">-1</span>)) &amp; <span class="number">1</span>)	ans += t;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ((ans1 &gt;&gt; (i - <span class="number">1</span>)) &amp; <span class="number">1</span> &amp;&amp; m &gt;= t)ans += t, m -= t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>CFR-644F Spy-string 题解</title>
    <url>/2020/07/08/CFR-644F-Spy-string-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforc.es/contest/1360/problem/F" target="_blank" rel="noopener">题目大意</a></h3><p>给你n个长度为m的字符串，问你能否找到一个字符串，使这个字符串与每个字符串最多只有一位不同。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>其实一开始想到了暴力。</p>
<p>这个数据这么小，肯定可以暴力。</p>
<p>刚开始想着以第一个字符串为基准，去判断其他的字符串。 </p>
<p>结果错误的计算了时间复杂度，以为会TLE，就卡住了。。</p>
<p>刚好也没时间了。</p>
<p>（还是写的慢了。。</p>
<p>我们以第一个字符串为基准，更改它的每一位，这样最多也就与第一个字符串有一位不同。</p>
<p>再去判断除了第一个字符串以外的字符串是否不同的位数超过2位。</p>
<p>如果超过两位，就不行，重新枚举。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> Map[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (Map[i][j] != Map[<span class="number">1</span>][j])	cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (cnt &gt; <span class="number">1</span>)	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)	<span class="built_in">cin</span> &gt;&gt; Map[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">			<span class="keyword">char</span> t = Map[<span class="number">1</span>][i];</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">char</span> j = <span class="string">'a'</span>; j &lt;= <span class="string">'z'</span>; j++) &#123;</span><br><span class="line">				Map[<span class="number">1</span>][i] = j;</span><br><span class="line">				<span class="keyword">if</span> (check()) &#123;</span><br><span class="line">					flag = <span class="number">1</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (flag == <span class="number">1</span>)	<span class="keyword">break</span>;</span><br><span class="line">			Map[<span class="number">1</span>][i] = t;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (flag) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)	<span class="built_in">cout</span> &lt;&lt; Map[<span class="number">1</span>][i];</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>暴力</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>CFR-644D Buying Shovels 题解</title>
    <url>/2020/07/08/CFR-644D-Buying-Shovels%20%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforc.es/contest/1360/problem/D" target="_blank" rel="noopener">题目大意</a></h3><p> 你需要买n个东西，给你k个数$1-K$,代表你能一次买k个，你需要选择一个数，且只能选择一个数，让次数最少。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>服了。。</p>
<p>写的时候真的觉得自己可能是智障。。</p>
<p>愣是卡死在这个题目了。</p>
<p>明明纯暴力水题。。</p>
<p>吐了。</p>
<p>（还是自己太菜了。。哭</p>
<p>对于n来说，假设存在某个数i，能使n整除i，那么代价就是$min(i,n/i)$。</p>
<p>那么我只需要找到最小的i即可。</p>
<p>遍历的范围只需要从1到sqrt(n)即可。</p>
<p>注意还要考虑另一边。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n % i == <span class="number">0</span>)	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n, k;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">		<span class="keyword">if</span> (k &gt;= n) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> ans = n;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i*i&lt;=n; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (n / i &lt;= k) &#123;</span><br><span class="line">					ans = <span class="built_in">min</span>(ans,i);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (i &lt;= k) &#123;</span><br><span class="line">					ans = <span class="built_in">min</span>(ans, n / i);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title>CFR-644G A/B Matrix 题解</title>
    <url>/2020/07/08/CFR-644G-AB-Matrix-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforc.es/contest/1360/problem/G" target="_blank" rel="noopener">题目大意</a></h3><p>给你一个n*m的矩阵，初始都为0，需要满足每一行有a个1，每一列有b个1，问你这个矩阵是否存在。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>很明显，1的数量等于$n\times a$,也等于$m\times b$。</p>
<p>所以$n\times a==m\times b$。</p>
<p>那么满足这个条件的矩阵一定存在。</p>
<p>剩下的就是需要构造矩阵了。</p>
<p>我们可以以行为单位循环的构造矩阵，使每一列的1的数量平均的增加。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">60</span>],Map[<span class="number">60</span>][<span class="number">60</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n, m, a, b;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; a &gt;&gt; b;</span><br><span class="line">		<span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">		<span class="built_in">memset</span>(Map, <span class="number">0</span>, <span class="keyword">sizeof</span>(Map));</span><br><span class="line">		<span class="keyword">if</span> (n * a != m * b) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> t = a;</span><br><span class="line">			<span class="keyword">for</span> (; j &lt;= m+<span class="number">1</span> &amp;&amp; t; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (j == m + <span class="number">1</span>)	j = <span class="number">1</span>;</span><br><span class="line">				Map[i][j] = <span class="number">1</span>, t--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; Map[i][j];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>暴力</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>CH-0201 费解的开关 题解</title>
    <url>/2020/07/08/CH-0201-%E8%B4%B9%E8%A7%A3%E7%9A%84%E5%BC%80%E5%85%B3-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://noi-test.zzstep.com/contest/0x00「基本算法」例题/0201%20费解的开关" target="_blank" rel="noopener">题目大意</a></h3><p>给你一个5*5的01矩阵，1代表开，0代表关，你可以进行一种操作，让自己和上下左右的地方01交换，问你最少需要多少次操作使矩阵内全为1。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>用状压来表示第一行的状态，最多就$2^5=32$种。</p>
<p>确定第一行以后，之后的每一行都只需要将前一行的0,按成1即可。</p>
<p>最后判断最后一行是否全为1即可。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> Map[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> ans, tmp[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> i ,<span class="keyword">int</span> j)</span> </span>&#123;<span class="comment">//进行操作</span></span><br><span class="line">	tmp[i][j] ^= <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span>)	tmp[i - <span class="number">1</span>][j] ^= <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (i + <span class="number">1</span> &lt;  <span class="number">5</span>)	tmp[i + <span class="number">1</span>][j] ^= <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span>)	tmp[i][j - <span class="number">1</span>] ^= <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (j + <span class="number">1</span> &lt;  <span class="number">5</span>)	tmp[i][j + <span class="number">1</span>] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getans</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> &amp;cnt)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (tmp[i - <span class="number">1</span>][j])	slove(i, j),cnt++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (i == <span class="number">4</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)	<span class="keyword">if</span> (tmp[<span class="number">4</span>][j])	<span class="keyword">return</span>;</span><br><span class="line">		ans = <span class="built_in">min</span>(ans, cnt);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	getans(i + <span class="number">1</span>, cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		ans = <span class="number">1e9</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)	<span class="built_in">cin</span> &gt;&gt; Map[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; <span class="number">5</span>); i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> g = <span class="number">0</span>; g &lt; <span class="number">5</span>; g++)	tmp[j][g] = (Map[j][g] - <span class="string">'0'</span>)^<span class="number">1</span>;<span class="comment">//眼瞎，题目看错了，以为是全为0。。</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) </span><br><span class="line">				<span class="keyword">if</span> (i &amp; (<span class="number">1</span> &lt;&lt; j))	slove(<span class="number">0</span>, j),cnt++;</span><br><span class="line">			getans(<span class="number">1</span>,cnt);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (ans &gt; <span class="number">6</span>)	<span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>状压</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title>Dijkstra及其堆优化</title>
    <url>/2020/07/08/Dijkstra%E5%8F%8A%E5%85%B6%E5%A0%86%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>Dijkstra算法使用了广度优先搜索解决赋权有向图或者无向图的单源最短路径问题，算法最终得到一个最短路径树。该算法常用于路由算法或者作为其他图算法的一个子模块。</p>
<a id="more"></a>

<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>Dijkstra采用了一种贪心的方法，每次找离起点最近的一个点，并且用这个点来更新与他相邻的点的到起点的距离。</p>
<p>用$dis[i]$来表示与起点的距离。</p>
<p>因为每次需要找到离起点最近的点，也就是$dis[i]$最小的点，需要用一个循环，会浪费一定的时间。</p>
<p>所以我们可以使用优先队列来进行优化，也就是Dijkstra的堆优化。</p>
<p><a href="https://blog.csdn.net/qq_35644234/article/details/60870719#commentBox" target="_blank" rel="noopener">Dijkstra详解</a>。</p>
<p>1、Dijkstra模板</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">110</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> Map[MAX][MAX],dis[MAX],mark[MAX];</span><br><span class="line"><span class="keyword">int</span>	n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= f;i++)&#123;</span><br><span class="line">		mark[i]=<span class="number">0</span>;</span><br><span class="line">		dis[i]=Map[s][i];</span><br><span class="line">	&#125;</span><br><span class="line">	mark[s]=<span class="number">1</span>;</span><br><span class="line">	dis[s]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> node;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> <span class="built_in">min</span> =INF;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(!mark[i]&amp;&amp;dis[i]&lt;<span class="built_in">min</span>)&#123;</span><br><span class="line">				<span class="built_in">min</span>=dis[i];</span><br><span class="line">				node=i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		mark[node]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">			<span class="keyword">int</span> tmp=<span class="built_in">min</span>+Map[node][i];</span><br><span class="line">			tmp=tmp&gt;INF?INF:tmp;</span><br><span class="line">			<span class="keyword">if</span>(!mark[i]&amp;&amp;dis[i]&gt;tmp)	dis[i]=tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dis[f];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= MAX;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= MAX;j++)&#123;</span><br><span class="line">			Map[i][j]=INF;</span><br><span class="line">		&#125;</span><br><span class="line">		Map[i][i]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m))&#123;</span><br><span class="line">		<span class="keyword">if</span>(!n||!m)	<span class="keyword">break</span>;</span><br><span class="line">		init();</span><br><span class="line">		<span class="keyword">int</span> l,r,dis;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;l,&amp;r,&amp;dis);</span><br><span class="line">			<span class="keyword">if</span>(Map[l][r]&gt;dis||Map[r][l]&gt;dis)</span><br><span class="line">				Map[l][r]=Map[r][l]=dis; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> ans=dijkstra(<span class="number">1</span>,n);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、Dijkstra堆优化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span> + <span class="number">5</span>, INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> head[N], cnt, vis[N], dis[N], n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> to, val, next;</span><br><span class="line">&#125;Map[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> u, c;</span><br><span class="line">	node(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>) :u(a), c(b) &#123; &#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> node&amp; a) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> c &gt; a.c;<span class="comment">//小顶堆</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)	dis[i] = INF;</span><br><span class="line">	dis[s] = <span class="number">0</span>;</span><br><span class="line">	priority_queue&lt;node&gt;q;</span><br><span class="line">	q.push(node(s, <span class="number">0</span>));</span><br><span class="line">	node t;</span><br><span class="line">	<span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">		t = q.top();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">int</span> u = t.u;</span><br><span class="line">		<span class="keyword">if</span> (vis[u])	<span class="keyword">continue</span>;</span><br><span class="line">		vis[u] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = Map[i].next) &#123;</span><br><span class="line">			<span class="keyword">int</span> x = Map[i].to;</span><br><span class="line">			<span class="keyword">int</span> c = Map[i].val;</span><br><span class="line">			<span class="keyword">if</span> (!vis[x] &amp;&amp; dis[x] &gt; dis[u] + c) &#123;</span><br><span class="line">				dis[x] = dis[u] + c, q.push(node(x, dis[x]));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">	Map[++cnt].to = v, Map[cnt].val = val;</span><br><span class="line">	Map[cnt].next = head[u], head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> u, v, val;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; val;</span><br><span class="line">		build(u, v, val);</span><br><span class="line">	&#125;</span><br><span class="line">	Dijkstra(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; dis[n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Dijkstra</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>EOJ 2020.7 C OLED 题解</title>
    <url>/2020/07/24/EOJ-2020.7-C-OLED-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://acm.ecnu.edu.cn/contest/292/problem/C/" target="_blank" rel="noopener">题目大意</a></h3><p>有一个$a\times b$的矩阵，中间含有一个$n\times m$的01矩阵，这个矩阵可以在大的矩阵中间移动（平移），移动不能重复，矩阵中的1可以使大矩阵这个位置加一，求大矩阵中每个位置的相对比例。即该点的值比上所有位置的最大值，乘以100。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>其实原本的题目并没有我写的大意这么容易理解。。。</p>
<p>看了半天没看懂啥意思。</p>
<p>由于小矩阵是可以进行移动的，那个可以以小矩阵中的1为对象。</p>
<p>发现他的移动区域是一块确定的空间。</p>
<p>对这块空间进行加一。</p>
<p>那么就可以使用二维差分了。</p>
<p>（应该算是模板题了。</p>
<p>取出小矩阵中的每个1，对于他的区间进行加1。</p>
<p>最后进行前缀和，求出每一位的值并输出即可。</p>
<p>其实读懂了题还挺简单的。</p>
<p>但是我还是第一次做二维差分和前缀和的。。</p>
<p>虽然之前学了一点。</p>
<p>推荐一下这个大佬写的二维差分和二维前缀和的<a href="https://www.cnblogs.com/LMCC1108/p/10753451.html" target="_blank" rel="noopener">博客</a>，讲的很好。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dif[<span class="number">4000</span>][<span class="number">3000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> a, b, n, m;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; a &gt;&gt; b;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">			<span class="keyword">int</span> num;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">			<span class="keyword">if</span> (num) &#123;</span><br><span class="line">				<span class="keyword">int</span> x = b - m + j, y = a - n + i;</span><br><span class="line">				dif[i][j]++;</span><br><span class="line">				dif[i][x + <span class="number">1</span>]--;</span><br><span class="line">				dif[y + <span class="number">1</span>][j]--;</span><br><span class="line">				dif[y + <span class="number">1</span>][x + <span class="number">1</span>]++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> M = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= b; j++) &#123;</span><br><span class="line">			dif[i][j] += dif[i - <span class="number">1</span>][j] + dif[i][j - <span class="number">1</span>] - dif[i - <span class="number">1</span>][j - <span class="number">1</span>];<span class="comment">//对差分数组进行求前缀和，得到这一位修改了多少</span></span><br><span class="line">			M = <span class="built_in">max</span>(M, dif[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= b; j++) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d%c"</span>, <span class="number">100</span> * dif[i][j] / M, j == b ? <span class="string">'\n'</span> : <span class="string">' '</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>二维前缀和</tag>
        <tag>二维差分</tag>
      </tags>
  </entry>
  <entry>
    <title>EOJ Monthly 2020.3 B 与矩阵 题解</title>
    <url>/2020/07/08/EOJ-Monthly-2020.3-B-%E4%B8%8E%E7%9F%A9%E9%98%B5-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://acm.ecnu.edu.cn/contest/255/problem/B/" target="_blank" rel="noopener">题目大意</a></h3><p>与矩阵是一个 n×n 的矩阵。规定矩阵中的第 i 行第 j 列记为 (i,j) 。</p>
<p>生成一个与矩阵的方式是，先生成一个长度为 n 的数列 a1,a2,…,an−1,an ，而矩阵中 (i,j)=ai&amp;aj 。</p>
<p>其中 &amp; 是指<a href="https://en.wikipedia.org/wiki/Bitwise_operation#AND" target="_blank" rel="noopener">按位与运算</a>，其计算方式是参与运算的两数各对应的二进位相与。只有对应的两个二进位都为 1 时，结果位才为 1 。</p>
<p>Cuber QQ 发现，同一个与矩阵可能对应着一些不同的数列，不过 Cuber QQ 现在只想知道字典序最小的数列是什么样的。</p>
<p>对于两个数列$a1,a2,…,an−1,an $和 $b1,b2,…,bn−1,bn$ ，如果存在一个整数$ k (1≤k≤n) $满足 $a_{k+1}&lt;b_{k+1} $且 $a1=b1,a2=b2,…,ak=bk $，我们就认为数列 $a1,a2,…,an−1,an $的字典序要小于数列 $b1,b2,…,bn−1,bn $。</p>
<p>当然，Cuber QQ 不会这么容易让你得到答案，他会把矩阵所有的 $(i,i) (1≤i≤n) $的位置全部隐藏，只显示为 0 。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>很明显的位运算。</p>
<p>（但是不会啊。。</p>
<p>因为题目要求字典序最小，那么我们可以用贪心的思想，假设这个数为0。</p>
<p>只要哪一位出现了1，那么那一位必然为1，这样很明显求出来是最小的。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> N=<span class="number">1e9</span>+<span class="number">7</span>; </span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;a[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++)&#123;</span><br><span class="line">			ans|=a[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d%c"</span>,ans,i!=n?<span class="string">' '</span>:<span class="string">'\n'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>EOJ 2020.7 E 因数串 题解</title>
    <url>/2020/07/19/EOJ-2020.7-E-%E5%9B%A0%E6%95%B0%E4%B8%B2-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://acm.ecnu.edu.cn/contest/292/problem/E/" target="_blank" rel="noopener">题目大意</a></h3><p>因数串，指的是由正整数 $a$ 所有因数所构成的一个数列，需要满足从数列的第 $2$ 个数开始，每个数都必须由其前一个数乘以某个质数或除以某个质数得出的。</p>
<p>因数串需要保证正整数 $a$ 所有因数都会出现且只出现一次。现在 Cuber QQ 会告诉你正整数 $a$ ，你需要给出任意一个因数串。</p>
<p>其中正整数 $a=\prod _ {i=1} ^ n p_i ^ {k_i} $ 。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这个题目是真的难想，看到这个题目就其实有点懵。</p>
<p>首先，可以让这个串是由1开始的。</p>
<p>那么先以第一组为例，从$p^1$到$p^k$。</p>
<p>然后可以得到他们分别乘以$p_1^1$到$p_1^{k_1}$次方。</p>
<p>以此类推，就可以得到最终的因数串。</p>
<p>具体的原因，可以看官方题解。</p>
<blockquote>
<p>需要将所有的约数按照一定的排列，使得相邻的两个数只相差一个质因子。</p>
<p>倘若我们用广义 $X$ 进制编码的形式（大概可以这么命名吧？）来表示每一个因数，即将每一个因数都按照质因数分解的形式，每一位上的数分别表示包含某一个质数的个数。例如可能包含的质数有 $2,3,5,7$ ，则 $600=2^3\cdot 3\cdot 5^2$ 可以用 $(3120)_X$ 来表示。</p>
<p>用这样编码的好处是，我们要求“相邻的两个数只相差一个质因子”，也就是在两个数的编码中有且仅有其中的某一位相差 $1$ 。</p>
<p>这样构造的思路，我们可以从格雷码中学到一些经验，用类似格雷码的方式构造就可以得到一个合法的解了。</p>
</blockquote>
<p>真的。。这是人能想到的吗。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line">ll p[<span class="number">20</span>], k[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;ll&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; p[i] &gt;&gt; k[i];</span><br><span class="line">	&#125;</span><br><span class="line">	ll c = <span class="number">1</span>;</span><br><span class="line">	v.push_back(c);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k[<span class="number">1</span>]; i++)	c *= p[<span class="number">1</span>], v.push_back(c);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> len1 = v.<span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k[i]; j++) &#123;</span><br><span class="line">			<span class="keyword">int</span> len2 = v.<span class="built_in">size</span>();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; len1; l++)	v.push_back(v[len2 - l - <span class="number">1</span>] * p[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> x : v)	<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>EOJ Monthly 2020.3 D 钢琴演奏家 题解</title>
    <url>/2020/07/08/EOJ-Monthly-2020.3-D-%E9%92%A2%E7%90%B4%E6%BC%94%E5%A5%8F%E5%AE%B6-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://acm.ecnu.edu.cn/contest/255/problem/D/" target="_blank" rel="noopener">题目大意</a></h3><p>Cuber QQ 有一个多年的弹奏习惯，他弹奏钢琴，同一时刻一定会同时按下 m 个琴键，他喜欢不同音调交织在一起的声音，可是现在不允许了。</p>
<p>可能是因为时间的原因，钢琴不支持琴键并行（音乐带师 Cuber QQ 发明的词汇）了。通俗来说，当 Cuber QQ 同时按下 $m$ 个琴键的时候，钢琴只会发出音调最高的那个琴键的声音。</p>
<p>不甘心的 Cuber QQ 开始尝试每一个 $m$ 键的组合。他会记录下每一次钢琴发出的音调，他会统计所有演奏出的音调之和，为了验证自己有没有算错，他邀请你来帮他再算一遍。</p>
<p>需要注意的是，因为钢琴坏了，所以可能存在相同音调的琴键。</p>
<p>由于这个和可能会很大，你只需要告诉 Cuber QQ 这个和模 $10^9+7$ 的结果是多少。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>因为只会发出最高的声音，所以我们可以将其从小到大排序。</p>
<p>第$i$位的贡献为他前面的数中取$m-1$个数的组合次数，即$C_{i-1}^{m-1}$，乘上这一位的大小。</p>
<p>即$a[i]*C_{i-1}^{m-1}$。</p>
<p>由高中数学可知，组合数是可以递推的。</p>
<p>就是这样$C_i ^{m-1} = C_{i-1}^{m-1}*\frac{i}{i-(m-1)}$</p>
<p>（傻乎乎的我以为这样就简单的结束了。。</p>
<p>结果一直WA。。人都傻了</p>
<p>（因为不知道除法是不可以同余的。。</p>
<p>比完之后看了看题解。。</p>
<p>逆元是啥，快速幂我不会啊。。</p>
<p>因为除法不能取余，所以我们需要将除法变为乘法，这样就需要逆元了。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> N=<span class="number">1e9</span>+<span class="number">7</span>; </span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1000005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">slove</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span></span>&#123;<span class="comment">//快速幂</span></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(b)&#123;</span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>)	ans=ans*a%N;</span><br><span class="line">		a=a*a%N;</span><br><span class="line">		b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="keyword">int</span> n,m;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> ans=a[m],sum=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=m+<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			sum=sum*(i<span class="number">-1</span>)%N*slove(i-m,N<span class="number">-2</span>)%N;<span class="comment">//逆元</span></span><br><span class="line">			ans=(ans+(sum*<span class="number">1l</span>l*a[i])%N)%N;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>逆元</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU-1005 Number Sequence 题解</title>
    <url>/2020/07/13/HDU-1005-Number-Sequence-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1005" target="_blank" rel="noopener">题目大意</a></h3><p>定义一个等式$f(n)$.</p>
<p>$f(1) = 1, f(2) = 1, f(n) = (A * f(n - 1) + B * f(n - 2)) mod 7.$</p>
<p>输入A、B和n，求出$f(n)$.</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>之前写这种题，一看就是有规律。</p>
<p>然后以49一循环，这题简单a了。。</p>
<p>但是其实是因为杭电数据太水了。。</p>
<p>附上别人的测试数据。</p>
<blockquote>
<p>input</p>
<p>247 602 35363857<br>376 392 9671521<br>759 623 18545473<br>53 399 46626337<br>316 880 10470347<br>0 0 0</p>
<p>output</p>
<p>4<br>3<br>5<br>2<br>3</p>
</blockquote>
<p>我的代码是过不了的。。</p>
<p>所以说这题正解应该是矩阵快速幂。</p>
<p>其实矩阵快速幂和快速幂差不多，就是把数字的乘法换成矩阵的乘法即可。</p>
<p>由题目可以得到$\begin{equation}    \begin{array}{c c}     \left( \begin{array}{ccc}     f(3) \\     f(2) \\    \end{array} \right)    &amp;   = \left( \begin{array}{ccc}    a &amp; b \\    1 &amp; 0 \\    \end{array} \right)    &amp;    \left( \begin{array}{ccc}    f(2)\\    f(1) \\    \end{array} \right)    \end{array}    \end{equation}$</p>
<p>$f(3)=a\times f(2)+b\times f(1)$.</p>
<p>将公式推广到n。</p>
<p>$\begin{equation}    \begin{array}{c c}     \left( \begin{array}{ccc}     f(n) \\     f(n-1) \\    \end{array} \right)    &amp;   = \left( \begin{array}{ccc}    a &amp; b \\    1 &amp; 0 \\    \end{array} \right)^{n-2}    &amp;    \left( \begin{array}{ccc}    f(2) \\    f(1) \\    \end{array} \right)    \end{array}    \end{equation}$</p>
<p>设$A =       \left( \begin{array}{ccc}     a &amp; b \\     1 &amp; 0 \\    \end{array} \right)^{n-2}$</p>
<p>可以得到$f(n)=(A[0][0]+A[0][1])%7$。</p>
<p>所以关键就是要使用快速幂计算出A，即可得出答案。</p>
<p>补充：单位矩阵为对角线为1，其余都为0的矩阵。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> m[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">&#125;M;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(M &amp;a, M b)</span> </span>&#123;</span><br><span class="line">	M ans;</span><br><span class="line">	ans.m[<span class="number">0</span>][<span class="number">0</span>] = ans.m[<span class="number">0</span>][<span class="number">1</span>] = ans.m[<span class="number">1</span>][<span class="number">0</span>] = ans.m[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; k++)</span><br><span class="line">				ans.m[i][j] += (a.m[i][k] * b.m[k][j])%<span class="number">7</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">			a.m[i][j] = ans.m[i][j]%<span class="number">7</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qpow</span><span class="params">(M a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	M ans;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;<span class="comment">//这里换成单位矩阵会更好，之前不知道。。</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">			ans.m[i][j] = a.m[i][j] % <span class="number">7</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	n--;</span><br><span class="line">	<span class="keyword">while</span> (n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n &amp; <span class="number">1</span>) mul(ans, a);</span><br><span class="line">		n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">		mul(a, a);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (ans.m[<span class="number">0</span>][<span class="number">1</span>] + ans.m[<span class="number">0</span>][<span class="number">0</span>]) % <span class="number">7</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	M m;</span><br><span class="line">	<span class="keyword">int</span> a, b, n;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; n &amp;&amp; a || b || n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		m.m[<span class="number">0</span>][<span class="number">0</span>] = a;</span><br><span class="line">		m.m[<span class="number">0</span>][<span class="number">1</span>] = b;</span><br><span class="line">		m.m[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		m.m[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">		qpow(m, n<span class="number">-2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU-1052 Tian Ji -- The Horse Racing 题解</title>
    <url>/2020/07/08/HDU-1052-Tian-Ji----The-Horse-Racing-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1052" target="_blank" rel="noopener">题目大意</a></h3><p>田忌赛马。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>贪心。</p>
<p>（今天比赛的时候碰到了差不多的题，以前写的题目差不多忘了，现在来补一下题解。。</p>
<p>先对两个人的马匹进行从大到小的排序。</p>
<p>如果我的最好的马，打不过他最好的马，那我用我的最差的马去对他最好的马。</p>
<p>如果我的最好的马，与他的最好的马打成平手，那我就需要考虑最差的马。</p>
<p>如果我最差的马打得过他最好的马，那我直接与他最差的马对上即可。</p>
<p>如果打不过，那就用我最差的马去对上他最好的马。</p>
<p>如果我的最好的马能打得过他最好的马，那我直接获胜即可。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">2000</span>]= &#123;<span class="number">0</span>&#125;,b[<span class="number">2000</span>]= &#123;<span class="number">0</span>&#125;,n;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)&amp;&amp;n) &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;b[i]);</span><br><span class="line">        sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n,greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        sort(b+<span class="number">1</span>,b+<span class="number">1</span>+n,greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">1</span>,j=n,l,r=n;</span><br><span class="line">        <span class="keyword">for</span>(l=<span class="number">1</span>; l&lt;=r&amp;&amp;i&lt;=j;) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;b[l]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                l++;</span><br><span class="line">                cnt+=<span class="number">200</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(a[i]==b[l]) &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[j]&lt;=b[r]) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(a[j]&lt;b[l])</span><br><span class="line">                        cnt-=<span class="number">200</span>;</span><br><span class="line">                    j--;</span><br><span class="line">                    l++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cnt+=<span class="number">200</span>;</span><br><span class="line">                    r--;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j--;</span><br><span class="line">                l++;</span><br><span class="line">                cnt-=<span class="number">200</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU-1237 简单计算器 题解</title>
    <url>/2020/07/08/HDU-1237-%E7%AE%80%E5%8D%95%E8%AE%A1%E7%AE%97%E5%99%A8-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你一个中缀表达式，求出这个表达式的值。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>基础的STL栈运用。</p>
<p>需要将中缀转后缀或者前缀。</p>
<p>这个是之前的基础的题了，表达式不包括括号。</p>
<p>加括号的以后在写吧。。目前懒得去找了。</p>
<p>不过其实也差不多，就是括号需要特殊处理罢了。</p>
<p>至于分割数字和符号的话，个人比较喜欢用stringstream。</p>
<p>特别好用。</p>
<p>转表达式的方法我就不多赘述了。</p>
<p>点<a href="https://blog.csdn.net/qianyayun19921028/article/details/89228263" target="_blank" rel="noopener">这里</a>。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> priority[<span class="number">220</span>];</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt;sc;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">double</span>&gt;si;</span><br><span class="line"><span class="built_in">string</span> ans[<span class="number">220</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">solve</span><span class="params">(<span class="keyword">double</span> n1, <span class="keyword">double</span> n2, <span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ch) &#123;</span><br><span class="line">    case'+':return n1 + n2;</span><br><span class="line">    case'-':return n1 - n2;</span><br><span class="line">    case'*':return n1 * n2;</span><br><span class="line">    case'/':return n1 / n2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">stringstream</span> ss;</span><br><span class="line">    priority[<span class="string">'+'</span>] = <span class="number">0</span>;</span><br><span class="line">    priority[<span class="string">'-'</span>] = <span class="number">0</span>;</span><br><span class="line">    priority[<span class="string">'*'</span>] = <span class="number">1</span>;</span><br><span class="line">    priority[<span class="string">'/'</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (getline(<span class="built_in">cin</span>, s) &amp;&amp; s != <span class="string">"0"</span>) &#123;</span><br><span class="line">        ss.<span class="built_in">clear</span>();</span><br><span class="line">        ss &lt;&lt; s;</span><br><span class="line">        <span class="keyword">int</span>  flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (ss &gt;&gt; s) &#123;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; s &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span> ((s[<span class="number">0</span>] &gt;= <span class="string">'0'</span> &amp;&amp; s[<span class="number">0</span>] &lt;= <span class="string">'9'</span>) || s.length() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                ans[flag++] = s;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (sc.empty() || (!sc.empty() &amp;&amp; priority[s[<span class="number">0</span>]] &gt; priority[sc.top()[<span class="number">0</span>]])) &#123;</span><br><span class="line">                    sc.push(s);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (!sc.empty() &amp;&amp; priority[s[<span class="number">0</span>]] &lt;= priority[sc.top()[<span class="number">0</span>]]) &#123;</span><br><span class="line">                        ans[flag++] = sc.top();</span><br><span class="line">                        sc.pop();</span><br><span class="line">                    &#125;</span><br><span class="line">                    sc.push(s);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!sc.empty()) &#123;</span><br><span class="line">            ans[flag++] = sc.top();</span><br><span class="line">            sc.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; flag; i++) &#123;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; ans[i] &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span> ((ans[i][<span class="number">0</span>] &gt;= <span class="string">'0'</span> &amp;&amp; ans[i][<span class="number">0</span>] &lt;= <span class="string">'9'</span>) || ans[i].length() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">double</span> n = stod(ans[i]);</span><br><span class="line">                si.push(n);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">double</span> n1 = si.top();</span><br><span class="line">                si.pop();</span><br><span class="line">                <span class="keyword">double</span> n2 = si.top();</span><br><span class="line">                si.pop();</span><br><span class="line">                si.push(solve(n2, n1, ans[i][<span class="number">0</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> num = si.top();</span><br><span class="line">        si.pop();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>, num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>表达式转换</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU-1205 吃糖果 题解</title>
    <url>/2020/07/08/HDU-1205-%E5%90%83%E7%B3%96%E6%9E%9C-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1205" target="_blank" rel="noopener">题目大意</a></h3><p>有n种糖果，每种糖果有mi个，每次可以吃一颗，但是每次需要吃不同种类的糖果，问你是否能够吃完所有的糖果。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>补题ing。。</p>
<p>（这个题目卡了我好久啊。。感觉自己不太聪明。思维过于僵化了。</p>
<p>我们可以用最大数量的糖果为墙，中间有n-1个缝隙，只要除了最大数量的糖果以外的糖果的数量大于等于n-1即可保证不会有相同种类的糖果相邻。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> num[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>, m = <span class="number">-1e9</span>;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;num[i]);</span><br><span class="line">			sum += num[i];</span><br><span class="line">			m = <span class="built_in">max</span>(m, num[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		sum = sum - m;</span><br><span class="line">		<span class="keyword">if</span> (sum &gt;= m<span class="number">-1</span>)	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Yes"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"No"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU-1317 XYZZY 题解</title>
    <url>/2020/07/08/HDU-1317-XYZZY-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1317" target="_blank" rel="noopener">题目大意</a></h3><p>有n个房间，你的初始能量是100，你需要从第一个房间到达第n个房间，每个房间的能量为-100~+100之间，你每走进一个房间，你就会加上这个房间的能量，如果能量小于0就失败了。问你能否到达第n个房间。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这个图是一个有向图。首先可以用Floyd判能否达到，如果不能到达，那么肯定不行。</p>
<p>由于这个图存在正环的情况，所以需要Spfa去处理。如果存在正环，那么只用判断是否能从正环中到达n点，如果能够到达，那必定可以，否则不行。</p>
<p>其他情况只用判断从1到n点的最长路是否大于0，大于0的话就可以到达，否则不行。</p>
<p>（Spfa初体验。。应该算是Spfa的模板题了吧</p>
<p>感觉Spfa比Bellman-Ford要简单一点</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> energy[<span class="number">110</span>], vis[<span class="number">110</span>], road[<span class="number">110</span>][<span class="number">110</span>], power[<span class="number">110</span>],out[<span class="number">110</span>],n,Map[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">100</span>; k++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">100</span>; j++)</span><br><span class="line">				<span class="keyword">if</span> (road[i][k] &amp;&amp; road[k][j])	road[i][j] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(out, <span class="number">0</span>, <span class="keyword">sizeof</span>(out));</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">	<span class="built_in">memset</span>(power, <span class="number">0</span>, <span class="keyword">sizeof</span>(power));</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">	power[<span class="number">1</span>] = <span class="number">100</span>;</span><br><span class="line">	q.push(<span class="number">1</span>);</span><br><span class="line">	vis[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> f = q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		out[f]++;</span><br><span class="line">		vis[f] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (out[f] &gt;= n) <span class="keyword">return</span> road[f][n];<span class="comment">//存在正环，判断是否能够到达n点</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (Map[f][i] &amp;&amp; power[i] &lt; power[f] + energy[i] &amp;&amp; power[f] + energy[i]&gt;<span class="number">0</span>) &#123;</span><br><span class="line">				power[i] = power[f] + energy[i];</span><br><span class="line">				<span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">					q.push(i);</span><br><span class="line">					vis[i] = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> power[n] &gt; <span class="number">0</span>;<span class="comment">//判断是否大于0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(road, <span class="number">0</span>, <span class="keyword">sizeof</span>(road));</span><br><span class="line">		<span class="built_in">memset</span>(Map, <span class="number">0</span>, <span class="keyword">sizeof</span>(Map));</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> k;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; energy[i] &gt;&gt; k;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++) &#123;</span><br><span class="line">				<span class="keyword">int</span> node;</span><br><span class="line">				<span class="built_in">cin</span> &gt;&gt; node;</span><br><span class="line">				road[i][node] = <span class="number">1</span>;</span><br><span class="line">				Map[i][node] = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		floyd();</span><br><span class="line">		<span class="keyword">if</span> (!road[<span class="number">1</span>][n])	<span class="built_in">cout</span> &lt;&lt; <span class="string">"hopeless"</span> &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//判断是否能够到达</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (!spfa())	<span class="built_in">cout</span> &lt;&lt; <span class="string">"hopeless"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">else</span>  <span class="built_in">cout</span> &lt;&lt; <span class="string">"winnable"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Floyd</tag>
        <tag>最短路</tag>
        <tag>Spfa</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU-1503 Advanced Fruits题解</title>
    <url>/2020/07/08/HDU-1503-Advanced-Fruits%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1503" target="_blank" rel="noopener">题目大意</a></h3><p>给你两个字符串，问你如何按照顺序，将两个字符串合并后，输出最短的和字符串。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>本来我是想到，用LCS求出最短字符串后，用第二个字符串删去最长公共子序列，但是WA了。。。</p>
<p>后来查了题解才发现，应该顺序不能变。</p>
<p>那么这题就是一个LCS的应用，记录路径，倒序递归输出。</p>
<p>（明明是LCS，我也学了，但是就是写不出。。哎，还需要努力）</p>
<p>不是很熟悉LCS的话，可以参考以下这张图。</p>
<p><img src="https://ae01.alicdn.com/kf/H58afddd813f445b9bc8074e24ae630a3P.jpg" alt=""></p>
<p>很清楚的展示了路径。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	<span class="keyword">int</span> mark;<span class="comment">//记录状态</span></span><br><span class="line">&#125;dp[N][N];</span><br><span class="line"><span class="keyword">char</span> a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P</span><span class="params">(<span class="keyword">int</span> i ,<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i + j == <span class="number">0</span>)	<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (dp[i][j].mark == <span class="number">0</span>) &#123;</span><br><span class="line">		P(i<span class="number">-1</span>, j<span class="number">-1</span>);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (dp[i][j].mark == <span class="number">1</span>) &#123;	</span><br><span class="line">		P(i<span class="number">-1</span>, j);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		P(i, j<span class="number">-1</span>);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; b[j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; a + <span class="number">1</span> &gt;&gt; b + <span class="number">1</span>) &#123;</span><br><span class="line">		n = <span class="built_in">strlen</span>(a + <span class="number">1</span>);</span><br><span class="line">		m = <span class="built_in">strlen</span>(b + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			dp[i][<span class="number">0</span>].mark = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">				dp[<span class="number">0</span>][j].mark = <span class="number">-1</span>;</span><br><span class="line">				dp[i][j].mark = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">if</span> (dp[i - <span class="number">1</span>][j].val &gt; dp[i][j - <span class="number">1</span>].val) &#123;</span><br><span class="line">					dp[i][j].mark = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> dp[i][j].mark = <span class="number">-1</span>;</span><br><span class="line">				dp[i][j].val = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j].val, dp[i][j - <span class="number">1</span>].val);</span><br><span class="line">				<span class="keyword">if</span> (a[i] == b[j]) &#123;</span><br><span class="line">					<span class="keyword">if</span> (dp[i - <span class="number">1</span>][j - <span class="number">1</span>].val + <span class="number">1</span> &gt; dp[i][j].val) &#123;</span><br><span class="line">						dp[i][j].mark = <span class="number">0</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					dp[i][j].val = <span class="built_in">max</span>(dp[i][j].val, dp[i - <span class="number">1</span>][j - <span class="number">1</span>].val + <span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		P(n, m);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>记录路径</tag>
        <tag>LCS</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU-3631 Shortest Path 题解</title>
    <url>/2020/07/08/HDU-3631-Shortest-Path-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3631" target="_blank" rel="noopener">题目大意</a></h3><p>给你一张加权有向多重图，你可以对这张图进行两种操作</p>
<blockquote>
<p>（1）在图中标记一个顶点。<br>（2）仅通过标记的顶点找到两个顶点之间的最短路径。</p>
</blockquote>
<p>对于操作“ 0 x”，表示标记x点，如果点x已经被标记了，则输出“ ERROR! At point x“。</p>
<p>对于操作“ 1 x y”，如果未标记点x或点y，则输出“ERROR! At path x to y”；</p>
<p>如果无法通过标记顶点从x到达y，则输出“No such path”；</p>
<p>否则，输出最短路径的长度。</p>
<p>在两个连续的测试用例之间有一个空白行。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>看题意，很明显是多源最短路。</p>
<p>（但是我一开始没想到，直接用Dijkstra写了，然后TLE了。。</p>
<p>以标记点为中继点，不断更新最短距离，看是否能够只通过标记点到达。</p>
<p>不为INF就是可以到达。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> mark[<span class="number">330</span>],vis[<span class="number">330</span>],dis[<span class="number">330</span>],n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> Map[<span class="number">330</span>][<span class="number">330</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">			Map[i][j] = <span class="built_in">min</span>(Map[i][j], Map[i][k] + Map[k][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++)</span><br><span class="line">			Map[i][j] = INF;</span><br><span class="line">		Map[i][i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>  m, q,cnt = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; q &amp;&amp; n || m || q) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(mark, <span class="number">0</span>, <span class="keyword">sizeof</span>(mark));</span><br><span class="line">		init();</span><br><span class="line">		<span class="keyword">if</span> (cnt != <span class="number">1</span>)	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//注意恶心人的输出格式</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; cnt++ &lt;&lt; <span class="string">":"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> x, y;</span><br><span class="line">			<span class="keyword">long</span> <span class="keyword">long</span> d;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; d;</span><br><span class="line">			Map[x][y] = <span class="built_in">min</span>(d,Map[x][y]);<span class="comment">//多重图，注意找最小值</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> x;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; x ;</span><br><span class="line">			<span class="keyword">if</span> (x) &#123;</span><br><span class="line">				<span class="keyword">int</span> node1, node2;</span><br><span class="line">				<span class="built_in">cin</span> &gt;&gt; node1 &gt;&gt; node2;</span><br><span class="line">				<span class="keyword">if</span> (!mark[node1] || !mark[node2]) </span><br><span class="line">					<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR! At path "</span> &lt;&lt; node1 &lt;&lt; <span class="string">" to "</span> &lt;&lt; node2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> (Map[node1][node2] &gt;= INF)	<span class="built_in">cout</span> &lt;&lt; <span class="string">"No such path"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">					<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; Map[node1][node2] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">int</span> node;</span><br><span class="line">				<span class="built_in">cin</span> &gt;&gt; node;</span><br><span class="line">				<span class="keyword">if</span> (mark[node])</span><br><span class="line">					<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR! At point "</span> &lt;&lt; node &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					mark[node] = <span class="number">1</span>;</span><br><span class="line">					floyd(node);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Floyd</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU-4745 Two Rabbits 题解</title>
    <url>/2020/07/08/HDU-4745-Two-Rabbits-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4283" target="_blank" rel="noopener">题目大意</a></h3><p>给你n个数，这n个数围成一个环，有两只兔子，可以从其中任意一个数出发，一个按顺时针跳跃，一个按逆时针跳跃，但是他们需要站在相同的数上，他们不能跳过已经被踩过的数字，并且他们能踩在同一个数上。问他们最多能跳几次。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>因为他们需要踩在相同的数字上，所以其实这就是一个最长回文子序列的问题。</p>
<p>（真的难想。。</p>
<p>求最长回文子序列很简单，看代码就懂了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n; len++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= n - len + <span class="number">1</span>; l++) &#123;</span><br><span class="line">				<span class="keyword">int</span> r = l +len - <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span> (num[l] == num[r])	dp[l][r] = <span class="built_in">max</span>(dp[l][r], dp[l + <span class="number">1</span>][r - <span class="number">1</span>] + <span class="number">2</span>);</span><br><span class="line">				<span class="keyword">else</span> dp[l][r] = <span class="built_in">max</span>(dp[l + <span class="number">1</span>][r], dp[l][r - <span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>枚举长度，得到左右端点，如果左右两端相同，那就是中间区间的最长值加2,。</p>
<p>如果不相同，那要么就是左边区间添加了j，要么就是右边区间添加了i，去其中的最大值。</p>
<p>我们用$dp[l][r]$表示l到r的最长回文子序列长度。</p>
<p>有两种思路。</p>
<p>1、我们可以在1-n区间中枚举一个点i，那么就分为了$[1,i]$和$[i+1,n]$。</p>
<p>假设$[1,i]$中最长的回文子序列为$[x,y]$，$[i+1,n]$中最长的回文子序列为$[x_1,y_1]$。</p>
<p>那么一个人的路径为$x-&gt;y,x_1-&gt;y_1$，另外一个人的路径为$y-&gt;x,y_1-&gt;x_1$。</p>
<p>答案为$max(dp[1][i],dp[i+1][n])$。</p>
<p>2、因为是一个环，可以使用倍增的思路，将数组扩大两倍。</p>
<p>由题意可知，每一个人最多走n步。</p>
<p>所以只需要找到长度为n的最长回文子序列即可，这时候每个人从这个最长回文子序列的两端开始跳跃。</p>
<p>但是有一种特殊情况，当两点重合的时候，也就是从同一点出发时，这个时候找的就是长度为n-1的最长回文子序列，并且答案需要加1。</p>
<p>比如1121，我们同时以1为起点，然后$1-&gt;2-&gt;1$，答案为4。</p>
<p>也就是，起点可以不构成回文子序列。</p>
<p>答案为$max(dp[i][i+n-1],dp[i][i+n-2]+1)$。</p>
<p>（dp怎么这么难。。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2200</span>;</span><br><span class="line"><span class="keyword">int</span> num[N], dp[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span>&gt;&gt;n&amp;&amp;n) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)	</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; num[i], num[n + i] = num[i];</span><br><span class="line">		<span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)	dp[i][i] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n; len++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= <span class="number">2</span> * n - len + <span class="number">1</span>; l++) &#123;</span><br><span class="line">				<span class="keyword">int</span> r = l +len - <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span> (num[l] == num[r])	dp[l][r] = <span class="built_in">max</span>(dp[l][r], dp[l + <span class="number">1</span>][r - <span class="number">1</span>] + <span class="number">2</span>);</span><br><span class="line">				<span class="keyword">else</span> dp[l][r] = <span class="built_in">max</span>(dp[l + <span class="number">1</span>][r], dp[l][r - <span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			ans = <span class="built_in">max</span>(ans, dp[i][i + n - <span class="number">1</span>]);</span><br><span class="line">			ans = <span class="built_in">max</span>(ans, dp[i][i + n - <span class="number">2</span>] + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>区间DP</tag>
        <tag>最长回文子序列</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU-4283 You Are the One 题解</title>
    <url>/2020/07/08/HDU-4283-You-Are-the-One-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4283" target="_blank" rel="noopener">题目大意</a></h3><p>有n个人，排成一列，每个人有着自己的耐心值$a[i]$，对于每个人来说，他的快乐值等于$a[i]*(j-1)$，j为他是第几个排完队的。你可以用一个类似于栈的东西来控制他们的顺序，让一部分人进去，然后逆序出来。求最小的快乐值。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>（这道题是真的好难。。。</p>
<p>菜鸡的我，看到这题完全没思路，看完题解写的。。</p>
<p>应该是我目前做过的区间dp最难的题了。。其实也没做多少题。</p>
<p>用$dp[i][j]$来表示区间$[i,j]$中的最小的快乐值。</p>
<p>对于一个区间$[i,j]$来说，我们要想使他最优，那就需要他们的顺序是最优的。</p>
<p>在$[i,j]$区间中，我们将i单独取出来，得到区间$[i+1,j]$。</p>
<p>我们可以枚举这个i插入到的位置。</p>
<p>设这个位置为k，那么就分为了两个区间$[i+1,k]$和$[k+1,j]$。</p>
<p>对于区间$[i+1,k]$来说，他们前面没有人（指在区间$[i,j]$中），所以他的贡献就是$dp[i+1][k]$。</p>
<p>那么对于k这个点来说，因为他的位置为k，原来的位置是i，就相当于是往后面移动了$k-i$位。</p>
<p>那么他的贡献就是$a[i]*(k-i)$。</p>
<p>对于区间$[k+1,j]$来说，就是相当于后移了$k-i+1$位（因为前面有个i），需要加上前面的。</p>
<p>所以他的贡献就是$dp[k+1][j]+(k-i+1)*sum[j]-sum[k]$。</p>
<p>得到区间$[i,j]$的最优解，那么一步步从最小区间$[i,i+1]$开始推，这时候只需要考虑谁先谁后即可。</p>
<p>这样便能推到区间$[1,n]$，得到最终答案$dp[1][n]$。</p>
<p>状态转移方程为$dp[l][r] = min(dp[l][r], dp[l + 1][k] + num[l] * (k - l) + dp[k + 1][r] + (k - l + 1) * (c[r] - c[k]))$。</p>
<p>初始化$dp[i][i]=1$即可，其他的均为INF。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>,INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> dp[N][N],num[N],c[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; num[i], c[i] = c[i - <span class="number">1</span>] + num[i];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt;= n; j++)  dp[i][j] = INF;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n; len++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= n - len + <span class="number">1</span>; l++) &#123;</span><br><span class="line">				<span class="keyword">int</span> r = l + len - <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> k = l; k &lt;= r; k++) &#123;</span><br><span class="line">					<span class="keyword">int</span> t = dp[l + <span class="number">1</span>][k] + num[l] * (k - l) + dp[k + <span class="number">1</span>][r] + (k - l + <span class="number">1</span>) * (c[r] - c[k]);</span><br><span class="line">					dp[l][r] = <span class="built_in">min</span>(dp[l][r], t);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; i &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; dp[<span class="number">1</span>][n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU-6785 Permutation 题解</title>
    <url>/2020/07/27/HDU-6785-Permutation-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6785" target="_blank" rel="noopener">题目大意</a></h3><p>给你一串数字序列1~n，问你最多交换m对数字，最多能构成多少对逆序对。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>刚开始花了十分钟， a了两道，写到了这个题。</p>
<p>觉得这个题目不难。</p>
<p>写完之后，wa了一万遍。。</p>
<p>卡了好久，就没打了。</p>
<p>后面一看，发现自己思路出了点问题。</p>
<p>其实就是一个很简单的题目。</p>
<p>首先为了逆序对最多，肯定是优先交换队列首尾。</p>
<p>然后队列不断向中间移动。</p>
<p>当时不知道怎么想的，脑袋一抽，想成了第一位移动，最后一位不动了。。</p>
<p>那么首先考虑能够构造出n~1的次数，很显然是$\large \frac {n}{2}$次。</p>
<p>答案就是从1加到n-1。</p>
<p>如果$\large m&lt;\frac {n}{2}$，则说明不能全部到过来。</p>
<p>这个时候就需要自己找出公式了。</p>
<p>可以把交换m次之后的序列分为三份。</p>
<p>最前面那一份，分别与后面所有的数构成逆序对。</p>
<p>答案为n-1加到n-m。</p>
<p>中间那一份，每个都与最后面那一份构成逆序对。</p>
<p>易知中间的区间为$[m+1,n-m]$。</p>
<p>最后面的数的个数为m个。</p>
<p>所以答案为$(n-2m)*m$。</p>
<p>最后面的那一份，每个数也都与后面的数构成逆序对。</p>
<p>（之前就是忘了这个，wa了好久。</p>
<p>答案为1加到m-1。</p>
<p>我的代码思路用的是前缀和，其实用数学的等差求和也可以，应该会更快。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line">ll sum[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= <span class="number">1e6</span>; i++) &#123;</span><br><span class="line">		sum[i] = sum[i - <span class="number">1</span>] + i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		ll n, m;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">1</span> || !m) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ll ans;</span><br><span class="line">		<span class="keyword">int</span> t = n / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (t &lt;= m)	ans = sum[n - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			ans = sum[n - <span class="number">1</span>] - sum[n - m - <span class="number">1</span>] + (n - <span class="number">2</span> * m) * m + sum[m - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU-6745 Dec 题解</title>
    <url>/2020/07/20/HDU-6745-Dec-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6745" target="_blank" rel="noopener">题目大意</a></h3><p>初始有 a, b 两个正整数，每次可以从中选一个大于 1 的数减 1，最后两个都会减到 1，求在过程中两个数互质的次数最多是多少。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>刚开始还没啥思路。。</p>
<p>想了好久。</p>
<p>问了下队友。</p>
<p>顿时就懂了。</p>
<p>$dp[i][j]=max(dp[i-1][j],dp[i][j-1])$。</p>
<p>当i和j互质的时候加一。</p>
<p>其实就是一个很简单的dp。</p>
<p>（进一步说明了我dp不行啊。。</p>
<p>那个关系转移还真没想到。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1050</span>;</span><br><span class="line"><span class="keyword">int</span> dp[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">1000</span>; j++) &#123;</span><br><span class="line">			dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">1</span> || j == <span class="number">1</span>||gcd(i,j)==<span class="number">1</span>)	dp[i][j]++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> a, b;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[a][b]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU-6778 Car 题解</title>
    <url>/2020/07/26/HDU-6778-Car-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6778" target="_blank" rel="noopener">题目大意</a></h3><p>某市需要禁车，在五天中，每天可以对任意数量的尾号进行限制，但是每个尾号只能在五天内限制一次，问在所有方案中，五天内每天出来的车的最大值的最小值是多少。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>刚开始看到这个题目数据不大，就想到应该是爆搜的。</p>
<p>写完之后发现一直wa。。</p>
<p>以为是思路错了。</p>
<p>后面也没想到啥思路，其他的题目也写不出。</p>
<p>我太菜了。。</p>
<p>后面仔细看代码，自己想到应该是搜索的思路错了。</p>
<p>但是也没想到其他的方法。</p>
<p>看了大佬的代码，才知道正确的枚举思路。</p>
<p>说实话，搜索到现在都不是很会。。</p>
<p>其实就是把十种尾号枚举在五天中，总共应该是$5^{10}$。</p>
<p>跑完大概是900ms左右。</p>
<p>还需要多做题啊。。关于搜索的。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">10</span>], num[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> n, ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>, c = getchar();</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isspace</span>(c))</span><br><span class="line">        c = getchar();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">45</span>)</span><br><span class="line">        s = <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c))</span><br><span class="line">        x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (c ^ <span class="number">48</span>), c = getchar();</span><br><span class="line">    <span class="keyword">if</span> (s)</span><br><span class="line">        x = -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">10</span>) &#123;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, n - <span class="built_in">min</span>(num[<span class="number">0</span>], <span class="built_in">min</span>(<span class="built_in">min</span>(num[<span class="number">1</span>], num[<span class="number">2</span>]), <span class="built_in">min</span>(num[<span class="number">3</span>], num[<span class="number">4</span>]))));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        num[i] += cnt[x];</span><br><span class="line">        dfs(x + <span class="number">1</span>);</span><br><span class="line">        num[i] -= cnt[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">int</span> l;</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; l;</span><br><span class="line">            cnt[l % <span class="number">10</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="number">1e9</span>;</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ-1001 Exponentiation</title>
    <url>/2020/07/08/POJ-1001-Exponentiation/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你输入一些浮点数，求这些浮点数的n次方。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>需要保留很多位小数，一看就是大数模拟。</p>
<p>但是这个题目写的我脑阔痛。</p>
<p>（模拟写起来是真的很烦。。</p>
<p>不过学到了一种大数乘法的写法，也挺好的。</p>
<p>可以用一个int数组来储存每一位的值。</p>
<p>然后对于每一位的值，都乘上需要乘的值，最后进位即可。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">130</span>], m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">		ans[i] *= num;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ans[i] &gt;= <span class="number">10</span>)</span><br><span class="line">			ans[i + <span class="number">1</span>] += ans[i] / <span class="number">10</span>, ans[i] = ans[i] % <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> t = ans[m - <span class="number">1</span>], p = m - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (t) &#123;</span><br><span class="line">		ans[p++] = t % <span class="number">10</span>, t /= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	m = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">string</span> s;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s &gt;&gt; n) &#123;</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>,l = s.length(),p;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (s[i] == <span class="string">'.'</span>)	p = (l - <span class="number">1</span> - i) * n;</span><br><span class="line">			<span class="keyword">else</span> sum = sum * <span class="number">10</span> + s[i] - <span class="string">'0'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!sum) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">memset</span>(ans, <span class="number">0</span>, <span class="keyword">sizeof</span>(ans));</span><br><span class="line">		m = <span class="number">1</span>;</span><br><span class="line">		ans[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			solve(sum);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> p1, p2;</span><br><span class="line">		p1 = <span class="number">0</span>, p2 = m - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (!ans[p1]) p1++;<span class="comment">//去后缀0</span></span><br><span class="line">		<span class="keyword">while</span> (!ans[p2]) p2--;<span class="comment">//去前缀0</span></span><br><span class="line">		<span class="keyword">if</span> (p1 &gt;= p) &#123;<span class="comment">//没有小数点</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = p2; i &gt; p - <span class="number">1</span>; i--)	<span class="built_in">cout</span> &lt;&lt; ans[i];</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = p2; i &gt; p<span class="number">-1</span>; i--)	<span class="built_in">cout</span> &lt;&lt; ans[i];</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">'.'</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i =  p - <span class="number">1</span>; i &gt;= p1; i--)	<span class="built_in">cout</span> &lt;&lt; ans[i];</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>大数模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP算法</title>
    <url>/2020/07/08/KMP%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h3><p>KMP 算法是 D.E.Knuth、J,H,Morris 和 V.R.Pratt 三位神人共同提出的，称之为 Knuth-Morria-Pratt 算法，简称 KMP 算法。该算法相对于 Brute-Force（暴力）算法有比较大的改进，主要是消除了主串指针的回溯，从而使算法效率有了某种程度的提高。</p>
<p>使用KMP算法能够快速的找到目标串中的模式串。</p>
<p>时间复杂度为$O(m+n)$。</p>
<a id="more"></a>

<h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>首先，想要找到目标串中的模式串，很显然是有一种暴力方法的，就是通过j指针和k指针的不断移动，来判断是否存在该子串，如果相同，则j++，k++，如果不同，则j回退，并且向前移动一位,再继续匹配。</p>
<p>显然，这种方法十分易懂，但是时间复杂度太高了，根本不适合用于比较长的字符串比较。</p>
<p>那么，就提出来了KMP算法。</p>
<p><img src="https://ae01.alicdn.com/kf/Hb58d6979692a40508c4f18f2dd2cef09W.png" alt=""></p>
<p>显然，C与B是配对失败的，当电脑使用之前的暴力算法的时候，便会前移一位。</p>
<p><img src="https://ae01.alicdn.com/kf/Hf2c0f0e554294cee897458fbd75729f3Y.png" alt=""></p>
<p>很明显，这个前移是毫无意义的，因为第一位便无法匹配。</p>
<p>而当我们人自己来匹配的时候，当C与B匹配失败之后，很明显是不会回退到B再重新去配对的，因为前面的A已经被使用完了，而电脑不会思考，我们就需要想办法让j指针不动，而k指针回退到适当的位置，来缩短回溯的时间。</p>
<p><img src="https://ae01.alicdn.com/kf/H1c556193bc2d4b588548d4f691c0bf0ey.png" alt=""></p>
<p>这样，这个算法最重要、最核心、也最难懂的地方——next数组，便是用来实现这个功能的。</p>
<h3 id="NEXT数组"><a href="#NEXT数组" class="headerlink" title="NEXT数组"></a>NEXT数组</h3><p>next数组的定义就是，数组第i位之前的i-1位的前缀和后缀相等的最大长度。</p>
<p>例如，模式串为</p>
<p><img src="https://ae01.alicdn.com/kf/H9548945a441b4e759cba25098649e9dfd.png" alt=""></p>
<p><img src="https://ae01.alicdn.com/kf/H2a1a26c6bf9a43339b8704ec7e80e9e4H.png" alt=""></p>
<p>特殊的，为了方便计算，我们将next[0] = -1，取一个特殊数字。</p>
<p>先上代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> next[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getnext</span><span class="params">(<span class="built_in">string</span> t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>, k = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> n = t.length();</span><br><span class="line">	<span class="keyword">while</span> (j &lt; n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (k == <span class="number">-1</span> || t[j] == t[k]) &#123;</span><br><span class="line">			j++, k++;</span><br><span class="line">			next[j] = k;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> k = next[k];<span class="comment">//这句是最重要也最难懂的地方</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码十分简短，但是却并不好理解。</p>
<p>分为几种情况</p>
<blockquote>
<p>当k等于-1时，代表的是第一位之前，需要j++，k++，然后之后进行第一位的匹配。</p>
<p>当t[j]与t[k]相同的时候，j和k同时后移，记录最长的长度。</p>
<p>如果都不满足的话，则k回退，即$k = next[k]$。</p>
</blockquote>
<p>为什么是回退到$next[k]$呢？</p>
<p>因为当k需要回退的时候，说明这一位上是匹配失败的。</p>
<p>这时，匹配的最长长度是k-1，我们需要一步步的去回退，直到回退到$k=-1$，重新开始。</p>
<p>那上一步是回退到哪呢，就是长度k-1中前缀和后缀相同的位置，即$next[k-1]$。</p>
<p>也就是将之前的最长长度进行不断的削减。</p>
<p>（有一种递归的感觉</p>
<p>换句话说next数组的意义就是，当第k位匹配失败之后，k需要回退的地方。</p>
<h3 id="优化NEXT数组"><a href="#优化NEXT数组" class="headerlink" title="优化NEXT数组"></a>优化NEXT数组</h3><p>当我们计算next数组的时候，会出现一种情况。</p>
<p>就是当这一位匹配成功的时候，他的下一位也是匹配成功的时候。</p>
<p><img src="https://ae01.alicdn.com/kf/Hdf97290ceed64d4fa3ebfc6292c14659S.png" alt=""></p>
<p>很显然，在目标串与模式串进行配对的时候，当k指向第二个B时匹配失败的时候，按照我们之前计算的next数组，k是应该回退到第一个B的，但是我们就是因为j指向的那一位与B匹配失败才回退的，这个回退便毫无意义。</p>
<p>所以我们可以对next数组进行优化，当连续两位都相同的时候，便可以跳过这一位。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> next[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getnext</span><span class="params">(<span class="built_in">string</span> t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>, k = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> n = t.length();</span><br><span class="line">	<span class="keyword">while</span> (j &lt; n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (k == <span class="number">-1</span> || t[j] == t[k]) &#123;</span><br><span class="line">			j++, k++;</span><br><span class="line">			<span class="keyword">if</span> (t[j] == t[k])<span class="comment">//新增这个判断</span></span><br><span class="line">				next[j] = next[k];</span><br><span class="line">			<span class="keyword">else</span> next[j] = k;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> k = next[k];<span class="comment">//k回退</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="匹配方法"><a href="#匹配方法" class="headerlink" title="匹配方法"></a>匹配方法</h3><p>在知道next数组时候，便已经了解KMP算法的十之七八了。</p>
<p>接下来只要了解目标串与模式串的比较方法即可。</p>
<p><img src="https://ae01.alicdn.com/kf/Hc79b902f57df40cc96ec85db119ddb63P.png" alt=""></p>
<p>当我们匹配到这里的时候，从A开始。</p>
<p>显然前三位是相匹配的，j和k指针不断前移。</p>
<p>当匹配到C的时候，不相匹配了，这个时候就需要回退。</p>
<p>根据next数组，B之前最长的前缀长度为1，所以k为1。</p>
<p><img src="https://ae01.alicdn.com/kf/Haf9a762b93454170a8dc754b0219296cO.png" alt=""></p>
<p>然后重新比较C，看是否互相匹配。</p>
<p>直到匹配完成，或者目标串扫描结束。</p>
<p>直接看代码吧。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> next[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KMP</span><span class="params">(<span class="built_in">string</span> s,<span class="built_in">string</span> t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> n = s.length(),m = t.length();</span><br><span class="line">	<span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (j &lt; m &amp;&amp; k &lt; n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (k == <span class="number">-1</span> || s[j] == t[k])	j++, k++;</span><br><span class="line">		<span class="keyword">else</span> k = ne[k];</span><br><span class="line">		<span class="keyword">if</span> (k == n) &#123;<span class="comment">//如果k与n相等，则说明存在</span></span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; j - n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			flag = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!flag) <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="典型例题"><a href="#典型例题" class="headerlink" title="典型例题"></a>典型例题</h3><p>1、<a href="https://www.acwing.com/problem/content/description/833/" target="_blank" rel="noopener">ACWing-831 KMP字符串</a></p>
<h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h4><p>给定一个目标串S，以及一个模式串P，所有字符串中只包含大小写英文字母以及阿拉伯数字。</p>
<p>模式串P在目标串S中多次作为子串出现。</p>
<p>求出模式串P在目标串S中所有出现的位置的起始下标。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>典型的KMP模板题。</p>
<p>但是需要注意可以重叠。</p>
<p>所以当扫描完成一个之后，$k=next[k]$。</p>
<h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> ne[N];</span><br><span class="line"><span class="built_in">string</span> s, t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; t &gt;&gt; m &gt;&gt; s;</span><br><span class="line">	ne[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>, k = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span> (j &lt; n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (k == <span class="number">-1</span> || t[j] == t[k]) &#123;</span><br><span class="line">			j++, k++;</span><br><span class="line">			<span class="keyword">if</span> (t[j] == t[k])</span><br><span class="line">				ne[j] = ne[k];</span><br><span class="line">			<span class="keyword">else</span> ne[j] = k;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> k = ne[k];</span><br><span class="line">	&#125;</span><br><span class="line">	j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (j &lt; m &amp;&amp; k &lt; n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (k == <span class="number">-1</span> || s[j] == t[k])	j++, k++;</span><br><span class="line">		<span class="keyword">else</span> k = ne[k];</span><br><span class="line">		<span class="keyword">if</span> (k == n)	k = ne[k], <span class="built_in">cout</span> &lt;&lt; j - n &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2087" target="_blank" rel="noopener">HDU-2087 剪花布条</a></p>
<h4 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h4><p>从目标串中寻找模式串的数量。遇到#停止输入。</p>
<h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>KMP模板题。</p>
<p>但是这个题目不能重叠，和上面那一题不一样。</p>
<p>当扫描出一个时候，需要重新匹配，也就是从剩下的字符串中重新扫描匹配。</p>
<h4 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> ne[N];</span><br><span class="line"><span class="keyword">char</span> s[N], t[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s)&amp;&amp;<span class="built_in">strcmp</span>(s,<span class="string">"#"</span>)) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>, t);</span><br><span class="line">		<span class="keyword">int</span> n, m;</span><br><span class="line">		n = <span class="built_in">strlen</span>(t);</span><br><span class="line">		m = <span class="built_in">strlen</span>(s);</span><br><span class="line">		ne[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">int</span> j = <span class="number">0</span>, k = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">while</span> (j &lt; n) &#123;</span><br><span class="line">			<span class="keyword">if</span> (k == <span class="number">-1</span> || t[j] == t[k]) &#123;</span><br><span class="line">				j++, k++;</span><br><span class="line">				<span class="keyword">if</span> (t[j] == t[k])</span><br><span class="line">					ne[j] = ne[k];</span><br><span class="line">				<span class="keyword">else</span> ne[j] = k;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> k = ne[k];</span><br><span class="line">		&#125;</span><br><span class="line">		j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (j &lt; m &amp;&amp; k &lt; n) &#123;</span><br><span class="line">			<span class="keyword">if</span> (k == <span class="number">-1</span> || s[j] == t[k])	j++, k++;</span><br><span class="line">			<span class="keyword">else</span> k = ne[k];</span><br><span class="line">			<span class="keyword">if</span> (k == n) &#123;</span><br><span class="line">				ans++;</span><br><span class="line">				k = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU-6781 Solo 题解</title>
    <url>/2020/07/26/HDU-6781-Solo-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6781" target="_blank" rel="noopener">题目大意</a></h3><p>一场比赛总共有n个题，A需要a[i]分钟写出这个题目，B需要b[i]分钟写出这个题目，每个题目率先通过的人得一分，如果同时通过，记A得一分。</p>
<p>A和B都是开始做一道题，就会直到这题做完或者对手通过这题。</p>
<p>做完了不一定要立马提交，可以之后再交。</p>
<p>A知道B的做题顺序是从1到n，求A最多得几分。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>比赛的时候看到这个题目的时候就是一脸懵。</p>
<p>跑到群里看了看，大佬说这个是dp。</p>
<p>更懵了。</p>
<p>这dp的状态我都没想到。。</p>
<p>刚开始是想，在前i分钟中，前j题的得分数的最大值。</p>
<p>但是这个分钟是$10^{18}$了，开不到。</p>
<p>而且好像也不好写。</p>
<p>写不出，看了眼题解。</p>
<p>发现是前i题中，得j分的最小时间。</p>
<p>这个思路好妙啊。</p>
<p>之前看y总的dp教学视频说，一般dp的值是问题所求的量。</p>
<p>但是这个题目不一样。</p>
<p>好像目前还没做过这样的题目。</p>
<p>那么这个题目的决策就是这个题目做与不做。</p>
<p>如果做，则就需要考虑B做到这个题目所需要的时间。</p>
<p>可以用前缀和数组pre来表示B做到这个题目所需要的时间。</p>
<p>如果做，所需要的时间为$dp[i - 1] [j - 1] + 1LL * a[i]$</p>
<p>如果这个值小于等于B做到这里的时间，则可以进行状态转移。</p>
<p>$\large dp[i][j] = min(dp[i][j], t)$</p>
<p>如果这个值大于B做到这里的时间，则说明在B做完之前，A是做不完这个题目的。</p>
<p>如果不做，则状态转移为$\large dp[i][j] = min(dp[i][j], dp[i - 1][j])$。</p>
<p>（dp老苦手了。。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2020</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N];</span><br><span class="line">ll dp[N][N], pre[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="built_in">memset</span>(pre, <span class="number">0</span>, <span class="keyword">sizeof</span>(pre));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    <span class="built_in">cin</span> &gt;&gt; b[i], pre[i] = pre[i - <span class="number">1</span>] + b[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++)    dp[i][j] = <span class="number">1e18</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">                ll t = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1L</span>L * a[i];</span><br><span class="line">                <span class="keyword">if</span> (t &lt;= pre[i])    dp[i][j] = <span class="built_in">min</span>(dp[i][j], t);</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] != <span class="number">1e18</span>)    ans = <span class="built_in">max</span>(ans, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ-1845 Sumdiv 题解</title>
    <url>/2020/07/08/POJ-1845-Sumdiv-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://poj.org/problem?id=1845" target="_blank" rel="noopener">题目大意</a></h3><p>求$A^B$的所有约数之和mod9901。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>（菜鸡的我，还在补基本算法。。</p>
<p>对A进行分解质因数，表示为$p_1^{c_1}\times p_2^{c_2}\times …..\times p_n^{c_n}$。</p>
<p>那么$A^B$就是乘以一个B。</p>
<p>由我不知道的公式得</p>
<p>约数和为$(1+p_1+p_1^2+…+p_1^{c_1\times B})\times  (1+p_2+p_2^2+…+p_2^{c_2\times B})\times …\times (1+p_n+p_n^2+…+p_n^{c_n\times B})$。</p>
<p>那么题目就转变为对这些等比数列求乘积了。</p>
<p>对每一项分治可以得到一个递推公式。</p>
<p>当c为奇数的时候$sum(p,c) = (1+p+…+p^{\frac {c-1} {2}})+p^{\frac {c+1}{2}}(1+p+…+p^{\frac {c-1} {2}})=(1+p^{\frac {c+1}{2}})\times sum(p,\frac {c-1}{2})$。</p>
<p>同理，当c为偶数的时候$sum(p,c) = (1+p^\frac {c}{2})*sum(p,\frac {c}{2}-1)\ +p^c$。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>,M = <span class="number">9901</span>;</span><br><span class="line">ll prime[N], cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b, ll m)</span> </span>&#123;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)	ans = (ans * a % m) % m;</span><br><span class="line">		a = (a*a)%m;</span><br><span class="line">		b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">slove</span><span class="params">(ll a,ll b,ll m)</span> </span>&#123;</span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!b)	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (b &amp; <span class="number">1</span>)	ans = (<span class="number">1</span> + qpow(a, (b + <span class="number">1</span>) / <span class="number">2</span>, m))%m * slove(a, (b - <span class="number">1</span>) / <span class="number">2</span>,m)%m;</span><br><span class="line">	<span class="keyword">else</span>  ans = (<span class="number">1</span> + qpow(a, b / <span class="number">2</span>, m)) * slove(a, b / <span class="number">2</span> - <span class="number">1</span>,m)%m + qpow(a, b, m)%m;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a, b;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">	<span class="keyword">if</span> (!a &amp;&amp; b)	<span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (a &amp;&amp; !b)	<span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">2</span>, c = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (i * i &lt;= a) &#123;<span class="comment">//分解质因数</span></span><br><span class="line">			<span class="keyword">if</span> (a % i == <span class="number">0</span>) &#123;</span><br><span class="line">				prime[c++] = i;</span><br><span class="line">				<span class="keyword">while</span> (a % i == <span class="number">0</span>) &#123;</span><br><span class="line">					a /= i,cnt[c - <span class="number">1</span>]++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">2</span>)	i = <span class="number">3</span>;</span><br><span class="line">			<span class="keyword">else</span> i += <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (a != <span class="number">1</span>) &#123;<span class="comment">//如果a本身是质数</span></span><br><span class="line">			prime[c++] = a, cnt[c - <span class="number">1</span>]++;</span><br><span class="line">		&#125;</span><br><span class="line">		ll ans = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c; i++)</span><br><span class="line">			ans = (ans*slove(prime[i],cnt[i]*b,M)%M) % M;<span class="comment">//记住要乘以b</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>快速幂</tag>
        <tag>递推</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ-1995 Raising Modulo Numbers 题解</title>
    <url>/2020/07/08/POJ-1995-Raising-Modulo-Numbers-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://poj.org/problem?id=1995" target="_blank" rel="noopener">题目大意</a></h3><p>有t组数据，每组输入h和m，有h组a，b，计算出$ (A_1^{B_1}+A_2^{B_2}+ … +A_H^{B_H})mod M $的结果。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>没什么好说的，标准的快速幂模板题。</p>
<p>（不熟。。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;<span class="comment">//快速幂</span></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> t = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">			t= (t*a)%m;</span><br><span class="line">		a = (a * a) % m;</span><br><span class="line">		b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> h;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; m &gt;&gt; h;</span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= h; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> a, b;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">			<span class="keyword">long</span> <span class="keyword">long</span> t = <span class="number">1</span>;</span><br><span class="line">			t = qpow(a%m, b);</span><br><span class="line">			ans += (t) % m;</span><br><span class="line">			ans %= m;</span><br><span class="line">		&#125;		</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>The begin</title>
    <url>/2020/07/08/The%20begin/</url>
    <content><![CDATA[<p>这个博客是某位大佬帮我写的，以后会放上友情链接（现在还不会。。。</p>
<p>开这个博客，时不时会上传一下我写过的题目的一些题解，加深一下印象，记录一下我这个菜鸡的ACM学习历程。</p>
<p>这应该也是我博客生涯的开始吧。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World"</span> &lt;&lt; <span class="built_in">endl</span> ;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/07/08/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>stringstream使用总结</title>
    <url>/2020/07/08/stringstream%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>使用stringstream需要头文件#include &lt; sstream &gt;。</p>
<p>stringstream一般用于输入一行字符串，以空格为分隔符把该行分隔开来。</p>
<p>经常用于格式转换，相当的好用。</p>
<p>还是不太熟练，所以来总结一下。</p>
<a id="more"></a>

<h3 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">stringstream</span> ss;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">ss&lt;&lt;s;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">ss&gt;&gt;a;<span class="comment">//字符串转int或者long long</span></span><br><span class="line"><span class="keyword">double</span> b;</span><br><span class="line">ss&gt;&gt;b;<span class="comment">//字符串转float或者double</span></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">ss&lt;&lt;a;</span><br><span class="line">ss&gt;&gt;s;<span class="comment">//int转字符串</span></span><br><span class="line">ss&lt;&lt;b;</span><br><span class="line">ss&gt;&gt;s;<span class="comment">//double转字符串</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">stringstream</span> ss;</span><br><span class="line">getline(<span class="built_in">cin</span>,s);<span class="comment">//读取一行</span></span><br><span class="line">ss&lt;&lt;s;</span><br><span class="line"><span class="keyword">while</span>(ss)&#123;</span><br><span class="line">	ss&gt;&gt;s;<span class="comment">//分割字符串</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">double</span> b;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line">s=to_string(a);<span class="comment">//int转字符串</span></span><br><span class="line">s=to_string(b);<span class="keyword">double</span>转字符串</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">a=stoi(s);<span class="comment">//字符串转int</span></span><br><span class="line">b=stod(s);<span class="comment">//字符串转double</span></span><br></pre></td></tr></table></figure>

<p>如果多次使用，并且使用之后stringstream不为空，记住需要清空stringstream。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stringstream</span> ss;</span><br><span class="line">ss.<span class="built_in">clear</span>();</span><br></pre></td></tr></table></figure>

<p>如果希望按照其他的字符分割，需要将读取的方式进行修改。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> data = <span class="string">"1,2,3,4,5,6"</span>;</span><br><span class="line"><span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(data)</span></span>;<span class="comment">//或者</span></span><br><span class="line">ss&lt;&lt;data;</span><br><span class="line"><span class="built_in">string</span> item;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">while</span> (getline(ss, item, <span class="string">','</span>))</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; item &lt;&lt; <span class="string">' '</span>;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>stringstream</tag>
      </tags>
  </entry>
  <entry>
    <title>Trie树</title>
    <url>/2020/07/08/Trie%E6%A0%91/</url>
    <content><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>Trie树，又称单词查找树，字典树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。</p>
<a id="more"></a>

<p>Trie树的基本性质可以归纳为：<br>（1）根节点不包含字符，除根节点意外每个节点只包含一个字符。<br>（2）从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。<br>（3）每个节点的所有子节点包含的字符串不相同。<br>Trie树有一些特性：<br>1）根节点不包含字符，除根节点外每一个节点都只包含一个字符。<br>2）从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。<br>3）每个节点的所有子节点包含的字符都不相同。<br>4）如果字符的种数为n，则每个结点的出度为n，这也是空间换时间的体现，浪费了很多的空间。<br>5）插入查找的复杂度为O(n)，n为字符串长度。</p>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>首先，我们以ACA，ACB，AD，CEMD，CEMA五个字符串为例。</p>
<p><img src="https://ae01.alicdn.com/kf/H7150f1c375964412a4b38a2e5931f6e7G.jpg" alt=""></p>
<p>很显然，我们构建出来的Trie树就是这个样子。</p>
<h4 id="1、建树"><a href="#1、建树" class="headerlink" title="1、建树"></a>1、建树</h4><p>这边我使用的是数组的形式建树，其实用链表也是可以的。</p>
<p>我们以0为根节点，这个节点是不存放任何东西的。</p>
<p>我们从根节点开始，按照需要插入的字符串，一位一位的去判断是否指向该位。</p>
<p>当一个字符串到了结尾的时候，我们可以使用一个flag数组，来表明他是一个字符串的结尾。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> trie[N][<span class="number">26</span>],flag[N],tot;\\tot表示总结点数</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> now = <span class="number">0</span>, l = s.length();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> id = s[i] - <span class="string">'a'</span>;</span><br><span class="line">		<span class="keyword">if</span> (!trie[now][id])	trie[now][id] = ++tot;</span><br><span class="line">		now = trie[now][id];</span><br><span class="line">	&#125;</span><br><span class="line">	flag[now] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、查询"><a href="#2、查询" class="headerlink" title="2、查询"></a>2、查询</h4><p>我们可以从根节点开始查找，按s来一位一位判断，判断该节点是否存在指向这一位的节点的指针。</p>
<p>如果存在，就继续查找。</p>
<p>如果不存在，就直接返回0。</p>
<p>当你查找完成之后，如果最后一位的$flag=1$，说明存在，否则不存在。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> now = <span class="number">0</span>, l = s.length();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> id = s[i] - <span class="string">'a'</span>;</span><br><span class="line">		<span class="keyword">if</span> (!trie[now][id])	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		now = trie[now][id];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> flag[now];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="典型例题"><a href="#典型例题" class="headerlink" title="典型例题"></a>典型例题</h3><p>1、<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1251" target="_blank" rel="noopener">HDU 1251 统计难题</a></p>
<h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h4><p>Ignatius最近遇到一个难题,老师交给他很多单词(只有小写字母组成,不会有重复的单词出现),现在老师要他统计出以某个字符串为前缀的单词数量(单词本身也是自己的前缀)。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>因为题目需要求的是以某个单词为前缀的数量，那么我们只需要统计每一位的数量即可。</p>
<h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> trie[N][<span class="number">30</span>], cnt[N],tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> now = <span class="number">0</span>, l = s.length();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> id = s[i] - <span class="string">'a'</span>;</span><br><span class="line">		<span class="keyword">if</span> (!trie[now][id])	trie[now][id] = ++tot;</span><br><span class="line">		cnt[now]++;</span><br><span class="line">		now = trie[now][id];</span><br><span class="line">	&#125;</span><br><span class="line">	cnt[now]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> now = <span class="number">0</span>, l = s.length();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> id = s[i] - <span class="string">'a'</span>;</span><br><span class="line">		<span class="keyword">if</span> (!trie[now][id])	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		now = trie[now][id];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cnt[now];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">string</span> s;</span><br><span class="line">	<span class="keyword">while</span> (getline(<span class="built_in">cin</span>, s) &amp;&amp; s.length() != <span class="number">0</span>) &#123;</span><br><span class="line">		insert(s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; search(s) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1075" target="_blank" rel="noopener">HDU 1075 What Are You Talking About</a></p>
<h4 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h4><p>输入几对单词，每对单词存在着对应关系，之后输入一些句子，你需要将其中的单词进行翻译，如果不存在对应关系，则不需要翻译，标点符号不需要翻译。</p>
<h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>很明显的Trie树模板，只需要将每个单词的结尾记录一下对应的单词即可。</p>
<h4 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> trie[N][<span class="number">30</span>], tot,flag[N];</span><br><span class="line"><span class="built_in">string</span> ch[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> s1,<span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> now = <span class="number">0</span>, l = s1.length();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> id = s1[i] - <span class="string">'a'</span>;</span><br><span class="line">		<span class="keyword">if</span> (!trie[now][id])	trie[now][id] = ++tot;</span><br><span class="line">		now = trie[now][id];</span><br><span class="line">	&#125;</span><br><span class="line">	flag[now] = <span class="number">1</span>;</span><br><span class="line">	ch[now] = s2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> now = <span class="number">0</span>, l = s.length();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> id = s[i] - <span class="string">'a'</span>;</span><br><span class="line">		<span class="keyword">if</span> (!trie[now][id]) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; s;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		now = trie[now][id];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (flag[now])	<span class="built_in">cout</span> &lt;&lt; ch[now];</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">string</span> s1, s2;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; s1;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span>&gt;&gt;s1&amp;&amp;s1!=<span class="string">"END"</span>) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; s2;</span><br><span class="line">		insert(s2, s1);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cin</span>.<span class="built_in">get</span>();<span class="comment">//吸收回车</span></span><br><span class="line">	<span class="keyword">while</span> (getline(<span class="built_in">cin</span>,s1)&amp;&amp;s1!=<span class="string">"END"</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> l = s1.length();</span><br><span class="line">		<span class="keyword">if</span> (s1 == <span class="string">"START"</span>)	<span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">string</span> s;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (s1[i] &gt;= <span class="string">'a'</span> &amp;&amp; s1[i] &lt;= <span class="string">'z'</span>)	s += s1[i];</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				search(s);</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; s1[i];</span><br><span class="line">				s.<span class="built_in">clear</span>();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>区间dp</title>
    <url>/2020/07/08/%E5%8C%BA%E9%97%B4dp/</url>
    <content><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>区间dp，简单来说就是以一个子区间为最小元素，一步步递推到根区间的过程。就是通过一个个小区间的最优解来推出大区间的最优解的过程。</p>
<a id="more"></a>

<h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><p>（区间dp好难啊啊。。不是很理解啊</p>
<p>一般的思路就是，我们需要求大区间的最优解，那么我可以把这个大区间分隔成一个个小区间，找出每个小区间的最优解，然后将这一个个小区间进行合并，得到大区间的最优解。</p>
<p>一般的情况下，是通过枚举区间的长度$len$，作为阶段，然后得到一个区间的$l$和$r$，作为状态，然后在这个区间中枚举分隔点$k$，取得最优解。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n; len++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - len + <span class="number">1</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt; j; k++) &#123;</span><br><span class="line">				dpm[i][j] = <span class="built_in">min</span>(dpm[i][j], dpm[i][k] + dpm[k + <span class="number">1</span>][j] + c[j] - c[i - <span class="number">1</span>]);</span><br><span class="line">				dpM[i][j] = <span class="built_in">max</span>(dpM[i][j], dpM[i][k] + dpM[k + <span class="number">1</span>][j] + c[j] - c[i - <span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四边形优化"><a href="#四边形优化" class="headerlink" title="四边形优化"></a>四边形优化</h3><p>自己不是很会四边形优化，就不怎么详细讲解了。</p>
<p>详细讲解点<a href="https://blog.csdn.net/NOIAu/article/details/72514812" target="_blank" rel="noopener">这里</a>。</p>
<p>就讲一下我稍微懂的一点吧，以后再补吧，真的dp不能足够的理解，就很头痛。</p>
<p>如果需要证明四边形优化是否成立的话，可以使用打表的形式，观察是否$p[i][j-1]\leq p[i][j]\leq p[i+1][j]$。</p>
<p>如果成立便可以使用四边形优化。</p>
<p>对石子合并来说的，最小值可以使用四边形优化，但是最大值不能。</p>
<p>这里贴一下模板吧。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _rep(i, a, b) for (int i = (a); i &lt;= (b); ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _rev(i, a, b) for (int i = (a); i &gt;= (b); --i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _for(i, a, b) for (int i = (a); i &lt; (b); ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _rof(i, a, b) for (int i = (a); i &gt; (b); --i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> oo 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 0.00001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(), x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> met(a, b) memset(a, b, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> id(x) ((x + 8))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> what_is(x) cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) x &amp;(-x)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e3</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e6</span> + <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> dpmin[maxn][maxn], n, a[maxn], dpmax[maxn][maxn], sum[maxn], kma[maxn][maxn], kmi[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	met(dpmin, oo);</span><br><span class="line">	_rep(i, <span class="number">1</span>, n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">		a[i + n] = a[i];</span><br><span class="line">		dpmin[i][i] = dpmin[i + n][i + n] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	_rep(i, <span class="number">1</span>, <span class="number">2</span> * n) &#123;</span><br><span class="line">		sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">		kmi[i][i] = kma[i][i] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	_rep(len, <span class="number">2</span>, n)</span><br><span class="line">	&#123;</span><br><span class="line">		_rep(l, <span class="number">1</span>, <span class="number">2</span> * n - len + <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> r = l + len - <span class="number">1</span>;</span><br><span class="line">			_rep(k, l, r - <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="comment">/*dpmax[l][r] = max(dpmax[l][k] + dpmax[k + 1][r] + sum[r] - sum[l - 1], dpmax[l][r]);</span></span><br><span class="line"><span class="comment">				dpmin[l][r] = min(dpmin[l][k] + dpmin[k + 1][r] + sum[r] - sum[l - 1], dpmin[l][r]);*/</span></span><br><span class="line">				<span class="keyword">if</span> (dpmax[l][k] + dpmax[k + <span class="number">1</span>][r] + sum[r] - sum[l - <span class="number">1</span>] &gt; dpmax[l][r]) &#123;</span><br><span class="line">					dpmax[l][r] = dpmax[l][k] + dpmax[k + <span class="number">1</span>][r] + sum[r] - sum[l - <span class="number">1</span>];</span><br><span class="line">					kma[l][r] = k;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (dpmin[l][k] + dpmin[k + <span class="number">1</span>][r] + sum[r] - sum[l - <span class="number">1</span>] &lt; dpmin[l][r]) &#123;</span><br><span class="line">					dpmin[l][r] = dpmin[l][k] + dpmin[k + <span class="number">1</span>][r] + sum[r] - sum[l - <span class="number">1</span>];</span><br><span class="line">					kmi[l][r] = k;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	_rep(i, <span class="number">1</span>, n + <span class="number">1</span>) &#123;</span><br><span class="line">		_rep(j, i+<span class="number">1</span>, i + n<span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="comment">//assert(kma[i][j - 1] &lt;= kma[i][j] &amp;&amp; kma[i][j] &lt;= kma[i + 1][j]);</span></span><br><span class="line">			<span class="comment">//assert(kmi[i][j - 1] &lt;= kmi[i][j] &amp;&amp; kmi[i][j] &lt;= kmi[i + 1][j]);</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"kma[%d][%d]=%d &lt;= kma[%d][%d]=%d &lt;= kma[%d][%d]=%d "</span>,i,j<span class="number">-1</span>,kma[i][j<span class="number">-1</span>],i,j,kma[i][j],i+<span class="number">1</span>,j,kma[i+<span class="number">1</span>][j]);</span><br><span class="line">			<span class="keyword">if</span>(kma[i][j - <span class="number">1</span>] &lt;= kma[i][j] &amp;&amp; kma[i][j] &lt;= kma[i + <span class="number">1</span>][j])	<span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	_rep(i, <span class="number">1</span>, n + <span class="number">1</span>) &#123;</span><br><span class="line">		_rep(j, i+<span class="number">1</span>, i + n<span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="comment">//assert(kma[i][j - 1] &lt;= kma[i][j] &amp;&amp; kma[i][j] &lt;= kma[i + 1][j]);</span></span><br><span class="line">			<span class="comment">//assert(kmi[i][j - 1] &lt;= kmi[i][j] &amp;&amp; kmi[i][j] &lt;= kmi[i + 1][j]);</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"kmi[%d][%d]=%d &lt;= kmi[%d][%d]=%d &lt;= kmi[%d][%d]=%d "</span>,i,j<span class="number">-1</span>,kmi[i][j<span class="number">-1</span>],i,j,kmi[i][j],i+<span class="number">1</span>,j,kmi[i+<span class="number">1</span>][j]);</span><br><span class="line">			<span class="keyword">if</span>(kmi[i][j - <span class="number">1</span>] &lt;= kmi[i][j] &amp;&amp; kmi[i][j] &lt;= kmi[i + <span class="number">1</span>][j])	<span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于最大值来说，他区间$[i,j]$的最大值，等于区间$[i,j−1]$和$[i+1,j]$中的最大值加上$w(i,j)$。</p>
<p>因为区间$[i+1,j-1]$的最大值是相同的，只需要看先合并左边还是先合并右边了，取其中的最大值。</p>
<h3 id="典型例题"><a href="#典型例题" class="headerlink" title="典型例题"></a>典型例题</h3><p><a href="https://www.luogu.com.cn/problem/P1880" target="_blank" rel="noopener">洛谷-P1880 石子合并</a></p>
<h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h4><p>有一圈石子，你需要把他们合成一堆，求最小花费和最大花费。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>模板题。</p>
<h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">310</span>, INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> dpm[N][N],dpM[N][N], p[N], num[N], c[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="built_in">memset</span>(dpm, <span class="number">127</span>, <span class="keyword">sizeof</span>(dpm));</span><br><span class="line">	<span class="built_in">memset</span>(dpM, <span class="number">0</span>, <span class="keyword">sizeof</span>(dpM));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; num[i],num[i+n] = num[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i++) c[i] = c[i - <span class="number">1</span>] + num[i], dpm[i][i] = <span class="number">0</span>, dpM[i][i] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n; len++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span>*n - len + <span class="number">1</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt; j; k++) &#123;</span><br><span class="line">				dpm[i][j] = <span class="built_in">min</span>(dpm[i][j], dpm[i][k] + dpm[k + <span class="number">1</span>][j] + c[j] - c[i - <span class="number">1</span>]);</span><br><span class="line">				dpM[i][j] = <span class="built_in">max</span>(dpM[i][j], dpM[i][k] + dpM[k + <span class="number">1</span>][j] + c[j] - c[i - <span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans1 = <span class="number">1e9</span>, ans2 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		ans1 = <span class="built_in">min</span>(ans1, dpm[i][i + n - <span class="number">1</span>]);</span><br><span class="line">		ans2 = <span class="built_in">max</span>(ans2, dpM[i][i + n - <span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>哈理工第十届程序设计竞赛 B 减成一 题解</title>
    <url>/2020/07/08/%E5%93%88%E7%90%86%E5%B7%A5%E7%AC%AC%E5%8D%81%E5%B1%8A%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B-B-%E5%87%8F%E6%88%90%E4%B8%80-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://ac.nowcoder.com/acm/contest/5758/B" target="_blank" rel="noopener">题目大意</a></h3><p>给你一些数字，你可以进行一种操作，令一个区间的数字减少1，问令这些数字全为1的最小操作数。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这题刚刚开始看的时候完全没思路。</p>
<p>后面感谢大佬抬我一手。</p>
<p>这就是一道纯差分题。</p>
<p>（我感觉自己都不会差分。。跟没学过一样。</p>
<p>上次比赛也是一道差分题卡了我好久。</p>
<p>对这一串数字进行构造差分数组。</p>
<p>由题意得，这种操作可以变成在差分数组中选取一位减1，一位加1。</p>
<p>而最终的数组应该除了第一位为1以外，其他的都为0。</p>
<p><img src="https://ae01.alicdn.com/kf/Hb766e75c07844c0393a776f4583eb870v.jpg" alt=""></p>
<p>所以最终的答案就是所有大于0的数加起来减一。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>;</span><br><span class="line">ll num[N],cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; num[i];</span><br><span class="line">			cnt[i] = num[i] - num[i - <span class="number">1</span>];<span class="comment">//构造差分数组</span></span><br><span class="line">		&#125;</span><br><span class="line">		ll ans = cnt[<span class="number">1</span>]<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (cnt[i] &gt; <span class="number">0</span>)	ans += cnt[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树和平衡树</title>
    <url>/2020/07/08/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%92%8C%E5%B9%B3%E8%A1%A1%E6%A0%91/</url>
    <content><![CDATA[<h3 id="二叉搜索树基本介绍"><a href="#二叉搜索树基本介绍" class="headerlink" title="二叉搜索树基本介绍"></a>二叉搜索树基本介绍</h3><p>给定一棵二叉树，树上的每一个节点带有一个数值，称为节点的关键值$val$。</p>
<p>对于树上的每一个节点：</p>
<blockquote>
<p>1、该节点的关键码不小于它的左子树任意节点的关键码</p>
<p>2、该节点的关键码不大于它的右子树任意节点的关键码</p>
</blockquote>
<p>这样的树就叫做二叉查找树（二叉排序树），即BST。</p>
<a id="more"></a>

<p>显然二叉查找树的中序遍历就是一个按照关键值递增的节点序列。</p>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><h4 id="1、建树"><a href="#1、建树" class="headerlink" title="1、建树"></a>1、建树</h4><p>我们可以建立两个初始节点，一个点的值为$INF$，另一个为$-INF$。</p>
<p>（书上说可以避免越界，减少边界的特殊情况）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>, N = <span class="number">1e6</span>;</span><br><span class="line"><span class="keyword">int</span> tot, root;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> l, r, val;</span><br><span class="line">&#125;a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">New</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">	a[++tot].val = val;</span><br><span class="line">    <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	New(-INF), New(INF), root = <span class="number">1</span>, a[<span class="number">1</span>].r = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、搜索"><a href="#2、搜索" class="headerlink" title="2、搜索"></a>2、搜索</h4><p>从根节点开始搜索，分为三种情况</p>
<p>1、若val等于p的关键值，表示已经找到，直接退出</p>
<p>2、若val大于p的关键值</p>
<blockquote>
<p>1、若p的右节点为空，说明不存在val</p>
<p>2、若p的右节点不为空，在右子树中进行递归查找</p>
</blockquote>
<p>3、若val小于p的关键值</p>
<blockquote>
<p>1、若p的左节点为空，说明不存在val</p>
<p>2、若p的左节点不为空，在左子树中进行递归查找</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="number">0</span>)	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (val == a[p].val)	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> val &gt; a[p].val ? search(a[p].r, val) : search(a[p].l, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、插入"><a href="#3、插入" class="headerlink" title="3、插入"></a>3、插入</h4><p>当我们发现走向p节点的子节点为空时，说明不存在，直接建立新节点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;p,<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="number">0</span>) &#123;</span><br><span class="line">		p = New(val);<span class="comment">//这里是引用，其父节点l，r同时也会被更新</span></span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (val == a[p].val)	<span class="keyword">return</span> ;</span><br><span class="line">	val &gt; a[p].val ? insert(a[p].r, val) : insert(a[p].l, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4、求前驱后继"><a href="#4、求前驱后继" class="headerlink" title="4、求前驱后继"></a>4、求前驱后继</h4><p>前驱就是在BST中关键值小于val的情况下，关键值最大的节点，而后继就是在BST中关键值大于val的情况下，关键值最小的节点。</p>
<p>这里以后继为例。</p>
<p>分为三种情况。</p>
<blockquote>
<p>1、没有找到val,说明val的后继已经在所遍历的节点中，ans即为所求</p>
<p>2、找到了关键值为val的节点p,但是该节点没有右子树，结果和1一样</p>
<p>3、找到了关键值为val的节点p，且有右子树，则从它的右子节点开始遍历，从左走，就找到了val的后继</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetNext</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">2</span>;<span class="comment">//a[p].val为INF</span></span><br><span class="line">	<span class="keyword">int</span> p = root;</span><br><span class="line">	<span class="keyword">while</span> (p) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[p].val == val) &#123;</span><br><span class="line">			<span class="keyword">if</span> (a[p].r) &#123;</span><br><span class="line">				p = a[p].r;</span><br><span class="line">				<span class="keyword">while</span> (p) p = a[p].l;</span><br><span class="line">				ans = p;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (a[p].val &gt; val &amp;&amp; a[p].val &lt; a[ans].val)	ans = p;<span class="comment">//不断更新</span></span><br><span class="line">		p = a[p].val &gt; val ? a[p].l : a[p].r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4、删除"><a href="#4、删除" class="headerlink" title="4、删除"></a>4、删除</h4><p>我们先查找到关键值为val的节点p。</p>
<p>若p的子节点数小于二，那么直接删除P，令p的子节点代替p的位置，与p的父节点相连。</p>
<p>若p既有左子树又有右子树，那么就先求出val的后继节点next,然后直接删除next(没有左子树)，并令next的右子树代替next的位置，最后让next节点代替p，删除p即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> &amp;p,<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!p)	<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (val == a[p].val) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!a[p].l)	p = a[p].r;<span class="comment">//左子树为空</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!a[p].r)	p = a[p].l;<span class="comment">//右子树为空</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">int</span> next = a[p].r;</span><br><span class="line">			<span class="keyword">while</span> (a[next].l)	next = a[p].l;<span class="comment">//找到后缀</span></span><br><span class="line">			<span class="built_in">remove</span>(a[p].r, a[next].val);<span class="comment">//删除后缀</span></span><br><span class="line">			a[next].l = a[p].l, a[next].r = a[p].r, p = next;<span class="comment">//用后缀来替代p</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	val &gt; a[p].val ? <span class="built_in">remove</span>(a[p].r, val) : <span class="built_in">remove</span>(a[p].l, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为数据的随机性，很有可能BST会变成链，那么时间复杂度又会从$O(logN)$变成$O(n)$。</p>
<p>所以出现了平衡树。</p>
<h3 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h3><p>（平衡树还不是很会啊。。</p>
<p>这边先放一下模板吧</p>
<p>到时候会了再补上。</p>
<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p><a href="https://www.acwing.com/problem/content/255/" target="_blank" rel="noopener">普通平衡树</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ycx的代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, INF = <span class="number">1e8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">int</span> key, val;</span><br><span class="line">    <span class="keyword">int</span> cnt, <span class="built_in">size</span>;</span><br><span class="line">&#125;tr[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> root, idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p].<span class="built_in">size</span> = tr[tr[p].l].<span class="built_in">size</span> + tr[tr[p].r].<span class="built_in">size</span> + tr[p].cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_node</span><span class="params">(<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[ ++ idx].key = key;</span><br><span class="line">    tr[idx].val = rand();</span><br><span class="line">    tr[idx].cnt = tr[idx].<span class="built_in">size</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zig</span><span class="params">(<span class="keyword">int</span> &amp;p)</span>    <span class="comment">// 右旋</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> q = tr[p].l;</span><br><span class="line">    tr[p].l = tr[q].r, tr[q].r = p, p = q;</span><br><span class="line">    pushup(tr[p].r), pushup(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zag</span><span class="params">(<span class="keyword">int</span> &amp;p)</span>    <span class="comment">// 左旋</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> q = tr[p].r;</span><br><span class="line">    tr[p].r = tr[q].l, tr[q].l = p, p = q;</span><br><span class="line">    <span class="comment">//之前一直对这个东西保有疑惑，后面发现必须要配合insert(&amp;p,val)和remove(&amp;p，key)来理解</span></span><br><span class="line">    pushup(tr[p].l), pushup(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    get_node(-INF), get_node(INF);</span><br><span class="line">    root = <span class="number">1</span>, tr[<span class="number">1</span>].r = <span class="number">2</span>;</span><br><span class="line">    pushup(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tr[<span class="number">1</span>].val &lt; tr[<span class="number">2</span>].val) zag(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;p, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) p = get_node(key);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tr[p].key == key) tr[p].cnt ++ ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tr[p].key &gt; key)</span><br><span class="line">    &#123;</span><br><span class="line">        insert(tr[p].l, key);</span><br><span class="line">        <span class="keyword">if</span> (tr[tr[p].l].val &gt; tr[p].val) zig(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        insert(tr[p].r, key);</span><br><span class="line">        <span class="keyword">if</span> (tr[tr[p].r].val &gt; tr[p].val) zag(p);</span><br><span class="line">    &#125;</span><br><span class="line">    pushup(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> &amp;p, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (tr[p].key == key)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (tr[p].cnt &gt; <span class="number">1</span>) tr[p].cnt -- ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tr[p].l || tr[p].r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!tr[p].r || tr[tr[p].l].val &gt; tr[tr[p].r].val)</span><br><span class="line">            &#123;</span><br><span class="line">                zig(p);</span><br><span class="line">                <span class="built_in">remove</span>(tr[p].r, key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                zag(p);</span><br><span class="line">                <span class="built_in">remove</span>(tr[p].l, key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> p = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tr[p].key &gt; key) <span class="built_in">remove</span>(tr[p].l, key);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">remove</span>(tr[p].r, key);</span><br><span class="line"></span><br><span class="line">    pushup(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_rank_by_key</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> key)</span>    <span class="comment">// 通过数值找排名</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">// 本题中不会发生此情况</span></span><br><span class="line">    <span class="keyword">if</span> (tr[p].key == key) <span class="keyword">return</span> tr[tr[p].l].<span class="built_in">size</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (tr[p].key &gt; key) <span class="keyword">return</span> get_rank_by_key(tr[p].l, key);</span><br><span class="line">    <span class="keyword">return</span> tr[tr[p].l].<span class="built_in">size</span> + tr[p].cnt + get_rank_by_key(tr[p].r, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_key_by_rank</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> rank)</span>   <span class="comment">// 通过排名找数值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> INF;     <span class="comment">// 本题中不会发生此情况</span></span><br><span class="line">    <span class="keyword">if</span> (tr[tr[p].l].<span class="built_in">size</span> &gt;= rank) <span class="keyword">return</span> get_key_by_rank(tr[p].l, rank);</span><br><span class="line">    <span class="keyword">if</span> (tr[tr[p].l].<span class="built_in">size</span> + tr[p].cnt &gt;= rank) <span class="keyword">return</span> tr[p].key;</span><br><span class="line">    <span class="keyword">return</span> get_key_by_rank(tr[p].r, rank - tr[tr[p].l].<span class="built_in">size</span> - tr[p].cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_prev</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> key)</span>   <span class="comment">// 找到严格小于key的最大数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> -INF;</span><br><span class="line">    <span class="keyword">if</span> (tr[p].key &gt;= key) <span class="keyword">return</span> get_prev(tr[p].l, key);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(tr[p].key, get_prev(tr[p].r, key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_next</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> key)</span>    <span class="comment">// 找到严格大于key的最小数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">if</span> (tr[p].key &lt;= key) <span class="keyword">return</span> get_next(tr[p].r, key);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(tr[p].key, get_next(tr[p].l, key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    build();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> opt, x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;opt, &amp;x);</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>) insert(root, x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">2</span>) <span class="built_in">remove</span>(root, x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, get_rank_by_key(root, x) - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">4</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, get_key_by_rank(root, x + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">5</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, get_prev(root, x));</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, get_next(root, x));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>BST</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>哈理工第十届程序设计竞赛 F 三角形 题解</title>
    <url>/2020/07/08/%E5%93%88%E7%90%86%E5%B7%A5%E7%AC%AC%E5%8D%81%E5%B1%8A%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B-F-%E4%B8%89%E8%A7%92%E5%BD%A2-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://ac.nowcoder.com/acm/contest/5758/F" target="_blank" rel="noopener">题目大意</a></h3><p>小明有一根长度为a的木棒，现在小明想将木棒分为多段（每段木棒长度必须为整数），<br>使得分隔后的木棍中，取出的任意三段都不能构成三角形，小明想知道木棒最多被分成几段？</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>由斐波那契数列得到，最佳的情况是每一段长度由斐波那契数列构成的。</p>
<p>因为斐波那契数列刚好是$a+b=c$，所以都不能构成三角形。</p>
<p>（可能这世界上就我不知道了吧。。</p>
<p>那我只需要构造出一个斐波那契数列的前缀和数组。</p>
<p>对这个数组进行二分查找即可。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> n[<span class="number">200</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">double</span> c = <span class="number">1</span>, cq = <span class="number">1</span>;</span><br><span class="line">	n[<span class="number">1</span>] = <span class="number">1</span>, n[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= <span class="number">150</span>; i++) &#123;</span><br><span class="line">		n[i] = n[i - <span class="number">1</span>] + c+cq;</span><br><span class="line">		swap(c, cq);</span><br><span class="line">		c += cq;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">double</span> a;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">		<span class="keyword">int</span> pos = upper_bound(n + <span class="number">1</span>, n + <span class="number">150</span>, a) - n;</span><br><span class="line">		pos--;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; pos &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
        <tag>二分查找</tag>
        <tag>打表</tag>
        <tag>斐波那契</tag>
      </tags>
  </entry>
  <entry>
    <title>拓展域</title>
    <url>/2020/07/08/%E6%8B%93%E5%B1%95%E5%9F%9F/</url>
    <content><![CDATA[<p>拓展域，个人感觉算是并查集中比较难的部分了。（网上都没什么详细的教学。。。全靠理解代码</p>
<p>简而言之，就是用多个并查集，多个空间，来表示节点之间的一些相互关系，比如x的敌人，x的朋友，我需要找到x的敌人的敌人，就也是我的朋友，x的敌人的朋友，就也是我的敌人。（【NOIP 2010 提高组】关押罪犯）</p>
<a id="more"></a>

<p>不多说，直接看例题吧。</p>
<p>（我感觉我说肯定说不清楚。。。</p>
<h3 id="例题解释"><a href="#例题解释" class="headerlink" title="例题解释"></a>例题解释</h3><p>1、<a href="http://poj.org/problem?id=1182" target="_blank" rel="noopener">POJ-1182 食物链</a></p>
<p>题目大意就是，告诉你一些动物之间的关系（同类或者捕食），如果满足这三个条件</p>
<blockquote>
<p>1）    当前的话与前面的某些真的话冲突，就是假话；<br>2）    当前的话中X或Y比N大，就是假话；<br>3）    当前的话表示X吃X，就是假话；</p>
</blockquote>
<p>就是假话。问你假话的数量。</p>
<p>我们可以用在同一个并查集的表示是同一类，x+n表示捕食关系。</p>
<blockquote>
<p>x-&gt;x+n-&gt;x+2*n-&gt;x</p>
</blockquote>
<p>如果x和y是同类，那么</p>
<blockquote>
<p>1）    x和y是同一类；<br>2）    x+n和y+n是同一类；<br>3）    x+2 * n和y+2 * n是同一类; </p>
</blockquote>
<p>如果x和y是捕食关系，那么</p>
<blockquote>
<p>1）    x和y+2 * n是同一类；<br>2）    x+n和y是同一类；<br>3）    x+2 * n和y+n是同一类; </p>
</blockquote>
<p>这样就可以用三个并查集来表达之间的关系了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">3</span> * N + <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> son = root, t;</span><br><span class="line">	<span class="keyword">while</span> (root != f[root])	root = f[root];</span><br><span class="line">	<span class="keyword">while</span> (son != root) &#123;</span><br><span class="line">		t = f[son];</span><br><span class="line">		f[son] = root;</span><br><span class="line">		son = t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> root1,<span class="keyword">int</span> root2)</span> </span>&#123;</span><br><span class="line">	root1 = <span class="built_in">find</span>(root1);</span><br><span class="line">	root2 = <span class="built_in">find</span>(root2);</span><br><span class="line">	<span class="keyword">if</span> (root1 != root2)	f[root1] = root2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, k;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;k);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">3</span>*n; i++) &#123;<span class="comment">//初始化，三倍空间</span></span><br><span class="line">		f[i] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> d, x, y;</span><br><span class="line">	<span class="keyword">while</span> (k--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;d, &amp;x, &amp;y);</span><br><span class="line">		<span class="keyword">if</span> (x &gt; n || y &gt; n) &#123;<span class="comment">//大于n就是假话，直接continue</span></span><br><span class="line">			ans++;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (d == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">find</span>(x + n) == <span class="built_in">find</span>(y) || <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y + n))	ans++;</span><br><span class="line">            <span class="comment">//x捕食y或者y捕食x，关系不符，就是假话</span></span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				join(x, y);</span><br><span class="line">				join(x + n, y + n);</span><br><span class="line">				join(x + <span class="number">2</span> * n, y + <span class="number">2</span> * n);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">find</span>(x) == <span class="built_in">find</span>(y) || <span class="built_in">find</span>(y + n) == <span class="built_in">find</span>(x))	ans++;</span><br><span class="line">            <span class="comment">//x和y是同一类或者y捕食x，关系不符，就是假话</span></span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				join(x + n, y);</span><br><span class="line">				join(x + <span class="number">2</span> * n, y + n);</span><br><span class="line">				join(x, y + <span class="number">2</span> * n);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、<a href="http://poj.org/problem?id=1733" target="_blank" rel="noopener">POJ-1733 Parity game</a></p>
<p>你有一串由0和1构成的序列，告诉你一些关系（[L,R]中1的个数是奇或偶），问你哪个地方出现了矛盾，输出最早出现矛盾的位置。</p>
<p>（这个题目。。相当头疼，想了好久，根本看不懂，我也不确定我能解释清楚。。</p>
<p>首先要离散化，n太大了，数组放不下，需要先离散化。</p>
<p>然后我们可以用d[x]表示x到根节点之间是奇是偶，用f[x]（并查集）表示前后关系。</p>
<p>如果根节点相同的时候，就需要判断是否矛盾。判断矛盾的时候可以用</p>
<blockquote>
<p>d[x]^d[y]  表示x到y之间的1的个数</p>
<p>1）    d[x] = 0,d[y] = 0 时，d[x]-d[y] == d[x]^d[y] == 0;<br>2）    d[x] = 0,d[y] = 1 时，d[x]-d[y] == d[x]^d[y] == 1;<br>3）    d[x] = 1,d[y] = 0 时，d[x]-d[y] == d[x]^d[y] == 1;<br>4）    d[x] = 1,d[y] = 1 时，d[x]-d[y] == d[x]^d[y] == 0;</p>
</blockquote>
<p>在路径压缩上，也可以使用同样的方法</p>
<blockquote>
<p>d[x]^d[f[x]]  表示x到f[x]之间的1的个数（用递归来实现）</p>
<p>1）    d[x] = 0,d[y] = 0 时，d[x]+d[y] == d[x]^d[y] == 0;<br>2）    d[x] = 0,d[y] = 1 时，d[x]+d[y] == d[x]^d[y] == 1;<br>3）    d[x] = 1,d[y] = 0 时，d[x]+d[y] == d[x]^d[y] == 1;<br>4）    d[x] = 1,d[y] = 1 时，d[x]+d[y] == d[x]^d[y] == 0;</p>
</blockquote>
<p>关系表示完后，即可写出正确代码。</p>
<p>（。。。我觉得没那么简单，我是真的菜。。根本想不到的好吧</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5050</span>;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">2</span> * N], d[<span class="number">2</span> * N];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; num;<span class="comment">//n太大了，不能用数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root != f[root]) &#123;</span><br><span class="line">		<span class="keyword">int</span> t = search(f[root]);<span class="comment">//递归寻找根节点</span></span><br><span class="line">		d[root] = d[root] ^ d[f[root]];<span class="comment">//更新d[x]的值</span></span><br><span class="line">		f[root] = t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f[root];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> rx = search(x);</span><br><span class="line">	<span class="keyword">int</span> ry = search(y);</span><br><span class="line">	<span class="keyword">if</span> (rx == ry) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((d[x] ^ d[y]) != l)	<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//判断是否矛盾</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		f[ry] = rx;</span><br><span class="line">		d[ry] = (d[x] + d[y] + l) % <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//d[ry] = (d[x] ^ d[y] + l) % 2;也可</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * N - <span class="number">5</span>; i++) &#123;</span><br><span class="line">		f[i] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">1</span>, mark = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> x, y, l;</span><br><span class="line">		<span class="keyword">char</span> ch[<span class="number">10</span>];</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; ch;</span><br><span class="line">		<span class="keyword">if</span> (!num[x - <span class="number">1</span>])	num[x - <span class="number">1</span>] = cnt++;<span class="comment">//离散化</span></span><br><span class="line">		<span class="keyword">if</span> (!num[y])	num[y] = cnt++;</span><br><span class="line">		<span class="keyword">if</span> (ch[<span class="number">0</span>] == <span class="string">'e'</span>)	l = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> l = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (!join(num[x - <span class="number">1</span>], num[y], l)) &#123;</span><br><span class="line">			mark = i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!mark)	mark = m + <span class="number">1</span>;<span class="comment">//如果没有冲突，就输出m</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; mark - <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>拓展域</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>数位DP</title>
    <url>/2020/07/08/%E6%95%B0%E4%BD%8DDP/</url>
    <content><![CDATA[<h3 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h3><p>简单来说，数位DP就是在数的每一位上进行DP，可以说是另类的暴力枚举了。</p>
<p>相比于简单的暴力枚举来说，数位DP具有记忆化的特点。</p>
<p>其实我感觉数位DP和状压DP有一点类似。</p>
<p>也是对每一位来进行DP。</p>
<a id="more"></a>

<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>刚好我们学长给我们贴了模板，那我就直接贴上来吧。</p>
<p>注意事项都是在代码里面了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> sta, <span class="keyword">bool</span> lead<span class="comment">/*前导 0，不是所有题目都有，题目不同不一样*/</span>, <span class="keyword">bool</span> limit<span class="comment">/*判断数位上限*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//递归边界</span></span><br><span class="line">    <span class="keyword">if</span>(pos == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//返回值因题而异</span></span><br><span class="line">    <span class="comment">//记忆化</span></span><br><span class="line">    <span class="keyword">if</span>(!limit &amp;&amp; !lead &amp;&amp; dp[pos][sta] == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[pos][sta];</span><br><span class="line">    <span class="keyword">int</span> len = limit?a[pos]:<span class="number">9</span>; <span class="comment">//判断上限</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//开始计数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//剪枝与状态转移</span></span><br><span class="line">        <span class="keyword">if</span>()</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>()</span><br><span class="line">        ans += dfs(pos - <span class="number">1</span>, sta<span class="comment">/*转移的状态*/</span>,lead &amp;&amp; i == <span class="number">0</span>, limit &amp;&amp; i == a[pos]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//完成记忆化</span></span><br><span class="line">    <span class="keyword">if</span>(!limit)</span><br><span class="line">        dp[pos][sta] = ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x) <span class="comment">// 分解数位</span></span><br><span class="line">    &#123;</span><br><span class="line">        a[pos ++] = x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dfs(pos - <span class="number">1</span>, <span class="number">-1</span>, <span class="literal">true</span>, <span class="literal">true</span>); <span class="comment">// 开始对数位从高位进行枚举</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; solve(r) - solve(l - <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="典型例题"><a href="#典型例题" class="headerlink" title="典型例题"></a>典型例题</h3><h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2089" target="_blank" rel="noopener">题目大意</a></h4><p>给你两个数n和m，问在n和m区间中，有多少数是不含4和62的。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>可以用$dp[pos][s]$来表示前一位是否是6的所有情况。s为1的时候代表前一位为6，那么这一位就不能为2，当s为0的时候，代表前一位不为6，那么就不用特殊考虑。</p>
<h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50</span>;</span><br><span class="line"><span class="keyword">int</span> dp[N][<span class="number">5</span>],num[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> s,<span class="keyword">bool</span> limit)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="number">-1</span>)	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (!limit &amp;&amp; dp[p][s])	<span class="keyword">return</span> dp[p][s];</span><br><span class="line">	<span class="keyword">int</span> l = limit ? num[p] : <span class="number">9</span>;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= l; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i == <span class="number">4</span>||(s &amp;&amp; i == <span class="number">2</span>))	<span class="keyword">continue</span>;</span><br><span class="line">		ans += dfs(p - <span class="number">1</span>, i == <span class="number">6</span>, limit&amp;&amp;i == num[p]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!limit)	dp[p][s] = ans;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (m) &#123;</span><br><span class="line">		num[c++] = m % <span class="number">10</span>,m /= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dfs(c - <span class="number">1</span>, <span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &amp;&amp; n || m) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; solve(m) - solve(n - <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数位DP</tag>
      </tags>
  </entry>
  <entry>
    <title>杭电多校第一场 1005 Fibonacci Sum 题解</title>
    <url>/2020/07/22/%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B8%80%E5%9C%BA-1005-Fibonacci-Sum-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6755" target="_blank" rel="noopener">题目大意</a></h3><p>定义一个斐波那契数列</p>
<p>$F_0=0,F_1=1$</p>
<p>$F_n=F_{n-1}+F_{n-2}\ (n&gt;1)$</p>
<p>求$(F_{0})^K+(F_{C})^K+(F_{2C})^K+\dots +(F_{NC})^{K}$。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这题直接让我自闭好吧。</p>
<p>这是啥，基础数论，难度easy。。</p>
<p>我感觉我离退役不远了。</p>
<p>首先我们需要知道斐波那契数列的通项公式（这个我就不知道。。<br>$$<br>F_n=\frac{1}{\sqrt{5}}\left(\left(\frac{1+\sqrt{5}}{2}\right)^{n}-\left(\frac{1-\sqrt{5}}{2}\right)^{n}\right)<br>$$<br>通过暴力，我们可以求出来，在$mod10^9+9$的情况下，与$\sqrt 5$同余的是383008016。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MOD;++i)&#123;</span><br><span class="line">	<span class="keyword">if</span>((<span class="keyword">long</span> <span class="keyword">long</span>)i*i%MOD == <span class="number">5</span>)&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//383008016</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过快速幂，求出$\frac{1} {\sqrt 5}$的逆元是276601605。</p>
<p>然后，通项公式中还含有$ \large\frac{1+\sqrt 5}{2}$和$\large \frac{1-\sqrt 5}{2}$。</p>
<p>为了方便表示，可以令$\large a=\frac{1+\sqrt 5}{2},b = \frac{1-\sqrt 5}{2}$。</p>
<p>这个a和b的值的计算，我不是很懂。。</p>
<p>大致就是把a和b的值用$1+\sqrt 5$和$1-\sqrt 5$的同余乘以2的逆元，得出的结果就是691504013和308495997。</p>
<p>具体的可以去看这位大佬的<a href="https://blog.csdn.net/acdreamers/article/details/23039571" target="_blank" rel="noopener">博客</a>。</p>
<p>讲解的很详细，很好。</p>
<p>总之，可以得出$a=691504013，b=308495997$。</p>
<p>这样，基础准备就已经做好了。</p>
<p>$\begin{align} \text{ans}&amp;=\sum_{i=0}^{N}(F_{iC})^{K}\ &amp;=\sum_{i=0}^{N}\left(\frac{1}{\sqrt{5}}\left(\left(\frac{1+\sqrt{5}}{2}\right)^{iC}-\left(\frac{1-\sqrt{5}}{2}\right)^{iC}\right)\right)^K\ &amp;=\left(\frac{1}{\sqrt{5}}\right)^K\cdot \sum_{i=0}^{N}\left(\left(\frac{1+\sqrt{5}}{2}\right)^{iC}-\left(\frac{1-\sqrt{5}}{2}\right)^{iC}\right)^{K} \end{align}$</p>
<p>为了方便表示，令$A=\left(\frac{1+\sqrt{5}}{2}\right)^C,B=\left(\frac{1-\sqrt{5}}{2}\right)^C$。</p>
<p>这样，答案就变成了$\large \left(\frac{1}{\sqrt{5}}\right)^K\sum_{i=0}^{N}(A^i-B^i)^K$。</p>
<p>前面那一项，我们可以用快速幂求出来。</p>
<p>只需要求出后面那一项即可。</p>
<p>对此可以进行二项式展开。</p>
<p>过程同上面那个大佬博客中的二项式展开类似。</p>
<p>就是从n变成了cn。</p>
<p>$\large (A-B)^k = C_k^0A^k + C_k^1A^{k-1}B^1 + \cdots + C_k^iA^{k-i}B^i + \cdots +C_k^kB^k (n \in N^*)$</p>
<p>这样，对于不同的斐波那契项，相同位置的二次项展开数，构成了一个等比数列。</p>
<p>对于每一项来说，公比$\large q=a^{c(k-i)}b^{ci}$。</p>
<p>其前n项和公式为<br>$$<br>\large S_n=\frac{(-1)^i·c_k^i·a^{c(k-i)}·b^{ci}·(1-a^{cn(k-i)}·b^{cni})}{1-a^{c(k-i)}b^{ci}}<br>$$<br> 接着只需要从0枚举到k，把每项用求和公式求出来相加即可。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">1e5</span> + <span class="number">5</span>, mod = <span class="number">1e9</span> + <span class="number">9</span>, N = <span class="number">1e5</span>;</span><br><span class="line">ll A = <span class="number">691504013</span>, B = <span class="number">308495997</span>;</span><br><span class="line">ll sqrt5 = <span class="number">383008016</span>, invsqrt5 = <span class="number">276601605</span>;</span><br><span class="line">ll fac[maxn], finv[maxn];</span><br><span class="line">ll sac[maxn], sbc[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	a %= mod;</span><br><span class="line">	<span class="keyword">while</span> (b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)	ans = (ans * a % mod) % mod;</span><br><span class="line">		a = (a * a) % mod, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a &lt; b)	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!b || a == b)	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> ((fac[a] * finv[a - b]) % mod * finv[b]) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	fac[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (ll i = <span class="number">2</span>; i &lt;= N; i++)	fac[i] = (fac[i - <span class="number">1</span>] * i)%mod;</span><br><span class="line">	finv[N] = qpow(fac[N], mod - <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">for</span> (ll i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)	finv[i] = (finv[i + <span class="number">1</span>] * (i + <span class="number">1</span>)) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	init();</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		ll n, c, k;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; c &gt;&gt; k;</span><br><span class="line">		ll ans = <span class="number">0</span>, flag = <span class="number">-1</span>;</span><br><span class="line">		ll ac = qpow(A, c), bc = qpow(B, c);</span><br><span class="line">		sac[<span class="number">0</span>] = sbc[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">			sac[i] = sac[i - <span class="number">1</span>] * ac % mod;</span><br><span class="line">			sbc[i] = sbc[i - <span class="number">1</span>] * bc % mod;</span><br><span class="line">		&#125;</span><br><span class="line">		ll acn = qpow(ac, n), bcn = qpow(bc, n), acninv = qpow(acn, mod - <span class="number">2</span>);</span><br><span class="line">		ll now_acn = qpow(acn, k), now_bcn = <span class="number">1</span>;</span><br><span class="line">		ll x, y;</span><br><span class="line">		<span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt;= k; i++) &#123;</span><br><span class="line">			flag *= <span class="number">-1</span>;</span><br><span class="line">			ll q = sac[k - i] * sbc[i] % mod;</span><br><span class="line">			<span class="keyword">if</span> (q == <span class="number">1</span>) &#123;</span><br><span class="line">				ll t = C(k, i) * (n % mod) % mod;</span><br><span class="line">				ans = (ans + (flag * t) % mod + mod) % mod;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				x = ((C(k, i) * sac[k - i]) % mod * sbc[i]) % mod;</span><br><span class="line">				x = (x * (<span class="number">1</span> - (now_acn * now_bcn % mod) + mod) % mod) % mod;</span><br><span class="line">				y = (<span class="number">1</span> - q) % mod;</span><br><span class="line">				y = qpow(y, mod - <span class="number">2</span>);</span><br><span class="line">				ans = (ans + flag * x * y % mod + mod) % mod;</span><br><span class="line">			&#125;</span><br><span class="line">			now_acn = (now_acn * acninv) % mod;</span><br><span class="line">			now_bcn = (now_bcn * bcn) % mod;</span><br><span class="line">		&#125;</span><br><span class="line">		ll mul = qpow(invsqrt5, k);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; (ans * mul) % mod &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>逆元</tag>
      </tags>
  </entry>
  <entry>
    <title>拓展欧几里得、逆元、线性同余方程、中国剩余定理和拓展中国剩余定理</title>
    <url>/2020/07/08/%E6%8B%93%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E3%80%81%E9%80%86%E5%85%83%E3%80%81%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B%E3%80%81%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86%E5%92%8C%E6%8B%93%E5%B1%95%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<h3 id="拓欧介绍"><a href="#拓欧介绍" class="headerlink" title="拓欧介绍"></a>拓欧介绍</h3><p>简单来说，拓欧就是求关于x，y的方程$ax+by=gcd(a,b)$的所有整数解。</p>
<p>这里就简单的证一下，详细证明点<a href="https://blog.csdn.net/weixin_39645344/article/details/83615901" target="_blank" rel="noopener">这里</a></p>
<a id="more"></a>

<p>由欧几里得定理可以得出$gcd(a,b)=gcd(b,a \%\ b)$。</p>
<p>由$gcd(b,a \%\ b)=bx_1+(a \%\ b)y_1$</p>
<p>由于$(a\%\ b)$可以表示成$a-(a/b)*b$。</p>
<p>所以表示成$bx_1+ay_1-b(a/b)y_1$。</p>
<p>即$ay_1+b(x_1-(a/b)y_1)$。</p>
<p>由于式子右边相当，所以左边也相等。</p>
<p>所以推出$x==y_1$,$y==x_1-(a/b)y_1$。</p>
<p>当我们推到最后一步的时候，即$b==0$时，显然是存在一组特解$x_1==1,y_1==0$。</p>
<p>那么我们就可以用这个特解来推出其他的解了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ex_gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span>&amp; x, <span class="keyword">int</span>&amp; y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!b) &#123;</span><br><span class="line">		x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">int</span> t = ex_gcd(b, a % b, y, x);</span><br><span class="line">		y -= (a / b)*x;</span><br><span class="line">		<span class="keyword">return</span> t;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="逆元介绍"><a href="#逆元介绍" class="headerlink" title="逆元介绍"></a>逆元介绍</h3><p>若整数$b,m$互质（这点很重要），并且$b|a$（表示b能整除a），则存在一个整数$a/b\equiv a*x(mod  \ m) $</p>
<p>称x为b的逆元。</p>
<p>介绍一下求逆元比较常用的两种方法。</p>
<h4 id="1、快速幂求逆元"><a href="#1、快速幂求逆元" class="headerlink" title="1、快速幂求逆元"></a>1、快速幂求逆元</h4><p>如果模数m为质数，由费马小定理的$b^{p-2}$为b的逆元。</p>
<p>可以用快速幂求出$b^{\ p-2}$。</p>
<h4 id="2、拓欧求逆元"><a href="#2、拓欧求逆元" class="headerlink" title="2、拓欧求逆元"></a>2、拓欧求逆元</h4><p>由定义知，$a\times x\equiv 1(mod\ m)$，这个x就是a的逆元,等价于$a\times x-1$是m的倍数。</p>
<p>将这个倍数令为-y倍。</p>
<p>得到$a\times x+m\times y=1$。</p>
<p>我们只需要用拓展欧几里得求得x，在令x对m取模即可。</p>
<h3 id="线性同余方程介绍"><a href="#线性同余方程介绍" class="headerlink" title="线性同余方程介绍"></a>线性同余方程介绍</h3><p>给定你a和b，以及取余的m，求一个整数x满足$a*x\equiv b(mod\ m)$。</p>
<p>求x的最小值。</p>
<p>这个方程$a*x\equiv b(mod\ m)$就是线性同余方程。</p>
<p>等价于$a\times x+m\times y=b$。</p>
<p>这个方程有解需要满足$gcd(a,m)|b$。（注意）</p>
<p>我们可以用拓欧来求出一组特解$x_0,y_0$。</p>
<p>通解为$x = x_0+(m/t)\times z$，$y = y_0\ +(a/t)\times z$，其中t为$gcd (a,m)$,z为整数。</p>
<p>因为$lcm(a,b) = a*b/gcd(a,b)$。</p>
<p>即每次增加一个最小公倍数。</p>
<p>当我们要求$a\times x+m \times y=b$的解时，我们可以先求出$a \times x +m\times y=gcd(a,m)$的解$x_0$。</p>
<p>那么原方程的解为$x=x_0*b/gcd(a/m)$，其中$b/gcd(a,m)$为扩大的倍数。</p>
<h4 id="典型例题"><a href="#典型例题" class="headerlink" title="典型例题"></a>典型例题</h4><p><a href="https://www.luogu.com.cn/problem/P1082" target="_blank" rel="noopener">洛谷-P1082 同余方程</a></p>
<h5 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h5><p>求关于$x$的同余方程 $a x \equiv 1 \pmod {b} $的最小正整数解。</p>
<h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><p>就是模板题。输入数据保证有解，不需要再去判断是否满足条件。</p>
<h5 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ex_gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span>&amp; x, <span class="keyword">int</span>&amp; y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!b) &#123;</span><br><span class="line">		x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">int</span> t = ex_gcd(b, a % b, y, x);</span><br><span class="line">		y -= (a / b)*x;</span><br><span class="line">		<span class="keyword">return</span> t;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a, b, x, y;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">	ex_gcd(a, b, x, y);</span><br><span class="line">	x = (x%b + b) % b;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="中国剩余定理介绍"><a href="#中国剩余定理介绍" class="headerlink" title="中国剩余定理介绍"></a>中国剩余定理介绍</h3><p>求解同余方程组</p>
<p>$\begin{cases} x \equiv a_1(mod\ m_1) \\ x \equiv a_2(mod\ m_2) \\ x\equiv a_3(mod\ m_3) \\ ……………. \\ x \equiv a_k(mod\ m_k) \end{cases}$</p>
<p>其中$m_1,m_2,m_3,….,m_k$为<strong>两两互质</strong>的整数。（这个区别于拓展中国剩余定理）</p>
<p>求x的最小非负整数解。</p>
<p>令$M=∏^k_{i = 1\ m_i}$，（$∏$这个符号代表连乘），即M是所有$m_i$的最小公倍数。</p>
<p>$t_i$是同余方程$\frac{M}{m_i}\equiv 1(mod\ m_i)$的最小非负整数解。</p>
<p>则解x为$x=∑^k_{i=1}\ a_i\frac{M}{m_i}t_i$。</p>
<p>通解为$x+i*M$。</p>
<p>最小非负整数解为$(x %M+M) %M$。</p>
<p>证明的话，蓝书证明的挺好的，这里就不写了。</p>
<p><img src="https://ae01.alicdn.com/kf/H8e8bd356eb124549bb50cd928bfa94298.jpg" alt=""></p>
<h4 id="典型例题-1"><a href="#典型例题-1" class="headerlink" title="典型例题"></a>典型例题</h4><p><a href="https://www.luogu.com.cn/problem/P3868" target="_blank" rel="noopener">洛谷-P3868 猜数字</a></p>
<h5 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h5><p>现有两组数字，每组 k 个。</p>
<p>第一组中的数字分别用 $a_1,a_2,\cdots ,a_k$ 表示，第二组中的数字分别用 $b_1,b_2,\cdots ,b_k $表示。</p>
<p>其中第二组中的数字是两两互素的。求最小的 $n∈N$，满足对于 $\forall i\in [1,k]，有 b_i | (n-a_i)$。</p>
<h5 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h5><p>把 $b_i | (n-a_i)$变一下型，就变成了$n\equiv a_i(mod \ b)$。</p>
<p>就是一个模板题了。</p>
<p>补充：</p>
<p>如果有$a\equiv b(mod \ m)$，则$a+c\equiv b\ +c(mod\ m)$成立。</p>
<h5 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll a[<span class="number">20</span>], b[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a, ll b, ll&amp; x, ll&amp; y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!b) &#123;</span><br><span class="line">		x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">	ll t = exgcd(b, a % b, y, x);</span><br><span class="line">	y -= (a / b) * x;</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qmul</span><span class="params">(ll a, ll b, ll mod)</span> </span>&#123;<span class="comment">//快速乘</span></span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)	ans = (ans + a) % mod;</span><br><span class="line">		a = (a &lt;&lt; <span class="number">1</span>) % mod;</span><br><span class="line">		b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">china</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll M = <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)	M *= b[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		ll t = M / b[i];</span><br><span class="line">		ll x, y;</span><br><span class="line">		exgcd(t, b[i], x, y);</span><br><span class="line">		x = (x % b[i] + b[i]) % b[i];</span><br><span class="line">		ans = (ans + qmul(qmul(a[i], t, M), x, M)) % M;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (ans%M+M)%M;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = (a[i] % b[i] + b[i]) % b[i];<span class="comment">//题目中的a可能大于b，所以需要取模</span></span><br><span class="line">	ll ans = china();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="拓展中国剩余定理介绍"><a href="#拓展中国剩余定理介绍" class="headerlink" title="拓展中国剩余定理介绍"></a>拓展中国剩余定理介绍</h3><p>求解同余方程组</p>
<p>$\begin{cases} x \equiv a_1(mod\ m_1) \\ x \equiv a_2(mod\ m_2) \\ x \equiv a_3(mod\ m_3) \\ ……………. \\ x \equiv a_k(mod\ m_k) \end{cases}$</p>
<p>其中$m_1,m_2,m_3,….,m_k$为<strong>不一定两两互质</strong>的整数。</p>
<p>求x的最小非负整数解。</p>
<p>我们可以设第i项的解$x_i$为$x_i = x_{i-1}+k_{i-1}*M$​。其中M为前$i-1$项的m的最小公倍数。</p>
<p>将$x_i$带入式子得$k_{i-1}\times m_{i-1}-k_i\times m_i+x_{i-1}\equiv a_i(mod\ m_i)$。</p>
<p>即$k_{i-1}\times M-k_i\times m_i\equiv a_i-x_{i-1}(mod\ m_i)$。</p>
<p>我们可以用拓欧来求出$k_{i-1}$，然后带入到$x_i = x_{i-1}+k_{i-1}*M$中，求得$x_i$。</p>
<h4 id="典型例题-2"><a href="#典型例题-2" class="headerlink" title="典型例题"></a>典型例题</h4><p><a href="https://www.luogu.com.cn/problem/P4777" target="_blank" rel="noopener">洛谷-P4777 【模板】扩展中国剩余定理（EXCRT）</a></p>
<h5 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h5><p>求解同余方程组</p>
<p>$\begin{cases} x \equiv b_1(mod\ a_1) \\ x \equiv b_2(mod\ a_2) \\ x \equiv b_3(mod\ a_3) \\ ……………. \\ x \equiv b_k(mod\ a_k) \end{cases}$</p>
<p>求x的最小非负整数解。</p>
<h5 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h5><p>模板题，套板子即可，注意快(gui)速乘。</p>
<h5 id="完整代码-2"><a href="#完整代码-2" class="headerlink" title="完整代码"></a>完整代码</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line">ll a[N], b[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a, ll b, ll&amp; x, ll&amp; y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!b) &#123;</span><br><span class="line">		x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">	ll t = exgcd(b, a % b, y, x);</span><br><span class="line">	y -= (a / b) * x;</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qmul</span><span class="params">(ll a,ll b,ll mod)</span> </span>&#123;</span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)	ans = (ans + a % mod) % mod;</span><br><span class="line">		a = (a &lt;&lt; <span class="number">1</span>) % mod;</span><br><span class="line">		b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">get_ans</span><span class="params">(ll a, ll b, ll c, ll&amp; x, ll&amp; y, ll&amp; gcd)</span> </span>&#123;</span><br><span class="line">	gcd = exgcd(a, b, x, y);</span><br><span class="line">	ll k = c / gcd, t = b / gcd;</span><br><span class="line">	<span class="keyword">if</span> (c % gcd)	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	x = qmul(x, k, t);</span><br><span class="line">	x = (x % t + t) % t;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">exchina</span><span class="params">(ll&amp; ans)</span> </span>&#123;</span><br><span class="line">	ll x, y,gcd;</span><br><span class="line">	ll M = a[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!get_ans(M, a[i], (b[i] - ans % a[i] + a[i]) % a[i], x, y, gcd))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		ans += M * x;</span><br><span class="line">		M = M / gcd* a[i] ;</span><br><span class="line">		ans = (ans % M + M) % M;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)	<span class="built_in">cin</span> &gt;&gt; a[i] &gt;&gt; b[i];</span><br><span class="line">	ll ans = b[<span class="number">1</span>];</span><br><span class="line">	exchina(ans);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，就差不多把我最近学的数论方面的东西讲完了。。</p>
<p>（数论是真的难啊啊</p>
<p>简直是天书。。</p>
]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>逆元</tag>
        <tag>拓展欧几里得</tag>
        <tag>线性同余方程</tag>
        <tag>中国剩余定理</tag>
        <tag>拓展中国剩余定理</tag>
      </tags>
  </entry>
  <entry>
    <title>杭电多校第一场 1004 Distinct Sub-palindromes 题解</title>
    <url>/2020/07/21/%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B8%80%E5%9C%BA-1004-Distinct-Sub-palindromes-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/contests/contest_showproblem.php?pid=1004&cid=879" target="_blank" rel="noopener">题目大意</a></h3><p>长度为n的字符串，这个字符串由小写字母构成，求所有长度为n的字符串中，子回文串数量最小的串的数量为多少。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>一开始还以为是$26^n$，结果我们一个队交快速幂wa了三次。。</p>
<p>（我就wa了一次。。</p>
<p>首先，当长度为一的时候，很显然答案是26，因为无论你用哪个字母，子回文串的数量都是1。</p>
<p>当长度为二的时候，可以理解为在长度为一的串中，在空隙中插入其他字母，发现，无论你插入哪个字母，串的子回文串的数量都会加一，所以答案为$26^2$。当长度为三的时候，可以得出同样的结果，答案为$26^3$。</p>
<p>当长度大于三的时候，可以发现，当原长度为三的串中各个元素都不相同的时候，在其空隙中插入与左右两边都不相同的第三个字母，这个时候，串的回文子串的数量是不会增加的，所以答案为$26<em>25</em>24$。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="number">1</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="number">26</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t == <span class="number">2</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="number">676</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="number">3</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="number">17576</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="number">15600</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>杭电多校第三场 1004 Tokitsukaze and Multiple 题解</title>
    <url>/2020/07/29/%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B8%89%E5%9C%BA-1004-Tokitsukaze-and-Multiple-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6794" target="_blank" rel="noopener">题目大意</a></h3><p>给你一串数字，你可以让任意两个相邻的数字合在一起，使串的个数减一，求串中最多有多少个数是p的倍数。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这个应该是这一场的签到了吧。</p>
<p>但是我没想出来。</p>
<p>好丢人啊。</p>
<p>刚开始以为是dp，想了半天，不知道咋进行状态转移。</p>
<p>就放弃了。</p>
<p>其实之后仔细想想，当时以为是没有重叠的子问题，以为就不是dp了。</p>
<p>（后面题解也提供了dp的做法。。尴尬</p>
<p>其实这个题目想到了就很简单。</p>
<p>可以用set或者map来维护前缀和。</p>
<p>在求前缀和的同时不断的对p取余。</p>
<p>如果这个前缀和在之前没出现过就记录一下。</p>
<p>出现了，则说明必然中间加了一个p的倍数，所以ans++。</p>
<p>之后清空set或者map。</p>
<p>注意，0是必须要在里面的，因为0就是刚好是p的倍数。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n, p;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; p;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> t = <span class="number">0</span>,ans = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">		s.<span class="built_in">clear</span>(), s.insert(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			t += a[i] % p, t %= p;</span><br><span class="line">			<span class="keyword">if</span> (s.count(t)) &#123;</span><br><span class="line">				ans++;</span><br><span class="line">				t = <span class="number">0</span>;</span><br><span class="line">				s.<span class="built_in">clear</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			s.insert(t);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>杭电多校第三场 1009 Parentheses Matching 题解</title>
    <url>/2020/07/29/%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B8%89%E5%9C%BA-1009-Parentheses-Matching-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6799" target="_blank" rel="noopener">题目大意</a></h3><p>给你一个只含有$*,(,)$三种字符的字符串。</p>
<p>你可以将*变成空字符串或者左右括号，你需要使左右括号匹配，并且使这个字符串字典序最小，输出最后的字符串。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>我是真的不是很会写字符串。</p>
<p>比赛发现自己一身都是弱点。。</p>
<p>之前打cf时也差不多，只要碰上字符串的题目，稍微难一点就不会写了。</p>
<p>难受。</p>
<p>其实只是单纯的匹配到还挺简单的，只需要按照可以统计左括号的数量，每遇到一个右括号，就使左括号的数量减一，并且统计之前的*数量。</p>
<p>如果匹配到右括号发现左括号没了，就可以让*变成左括号。</p>
<p>如果匹配到最后，发现左括号多了，就可以让*变成右括号。</p>
<p>多出来就删掉。</p>
<p>关键是需要字典序最小。</p>
<p>这里可以使用贪心，尽可能在最左边变成左括号，在最右边变成右括号。</p>
<p>最后需要判断是否满足匹配的字符串即可。</p>
<p>可以用pos数组来记录一下*的位置，优先使用最前面的。</p>
<p>这里记录一下，本来都过了的，因为用了memset，导致超时了，还特别严重。</p>
<p>ac代码400+ms，用了memset2sT了。</p>
<p>查了一下，发现memset效率和for循环差不多。</p>
<p>下次还是按照题目大小来用for吧。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> pos[N];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="comment">//string s;</span></span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">		<span class="keyword">int</span> l = <span class="built_in">strlen</span>(s);</span><br><span class="line">		<span class="keyword">int</span> cnt = <span class="number">0</span>, pre = <span class="number">0</span>, now = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//memset(pos, -1, sizeof(pos));</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= l; i++)	pos[i] = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (s[i] == <span class="string">'('</span>) cnt++;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">')'</span>) &#123;</span><br><span class="line">				cnt--;</span><br><span class="line">				<span class="keyword">if</span> (cnt &lt; <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">if</span> (pos[now]==<span class="number">-1</span>)	<span class="keyword">break</span>;</span><br><span class="line">					now = pos[now];</span><br><span class="line">					s[now - <span class="number">1</span>] = <span class="string">'('</span>;</span><br><span class="line">					cnt = <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> pos[pre] = i+<span class="number">1</span>, pre = i+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (cnt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = l - <span class="number">1</span>; i&gt;=<span class="number">0</span> &amp;&amp; cnt; i--) &#123;</span><br><span class="line">				<span class="keyword">if</span> (s[i] == <span class="string">'*'</span>)	cnt--,s[i] = <span class="string">')'</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (s[i] == <span class="string">'('</span>) cnt++;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">')'</span>) &#123;</span><br><span class="line">				cnt--;</span><br><span class="line">				<span class="keyword">if</span> (cnt &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (cnt!=<span class="number">0</span>)	<span class="built_in">cout</span> &lt;&lt; <span class="string">"No solution!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (s[i] != <span class="string">'*'</span>)	<span class="built_in">cout</span> &lt;&lt; s[i];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>杭电多校第二场 1001 Total Eclipse 题解</title>
    <url>/2020/07/25/%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%BA%8C%E5%9C%BA-1001-Total-Eclipse-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6763" target="_blank" rel="noopener">题目大意</a></h3><p>给你一个n个点m边的双向图，你可以进行一个操作，选择一个数字k，选择k个互相联通的点，使这些点的权值减一，问最少需要多少次操作。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>刚开始打的时候，看到这个题过得还挺多的，又过的快。</p>
<p>以为是签到题。。</p>
<p>结果完全没思路。。</p>
<p>杭电多校还是难啊，补题都很困难。</p>
<p>对于任何一个图来说，最优解肯定是优先最大连通块，减去连通块中最小的值，然后对于分裂之后的所有连通块再进行相同的操作。</p>
<p>所以我们可以倒过来看，选择权值由大到小的点，每个点的贡献为前一个点的的权值减去现在的点的权值乘以目前连通块的数量，就是将大的点减小成目前点所需要的次数。</p>
<p>在从第二个点开始枚举的过程中，需要枚举这个点的边，如果连接的是以前被标记的点，就可以判断这两点是不是属于同一个连通块的，以此来控制连通块的数量。</p>
<p>最后还需要加上最后一个点的权值乘以连通块的数量。</p>
<p>说实话，这个题目还挺难想的。。。</p>
<p>不愧是杭电多校。</p>
<p>就没啥简单的题目。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> cnt, fa[N], p[N], flag[N];</span><br><span class="line">ll num[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; e[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> son)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> root = son;</span><br><span class="line">	<span class="keyword">while</span> (fa[root] != root)	root = fa[root];</span><br><span class="line">	<span class="keyword">while</span> (root != son) &#123;</span><br><span class="line">		<span class="keyword">int</span> t = son;</span><br><span class="line">		fa[son] = root;</span><br><span class="line">		son = fa[t];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> root1 = <span class="built_in">find</span>(a), root2 = <span class="built_in">find</span>(b);</span><br><span class="line">	<span class="keyword">if</span> (root1 != root2)	fa[root1] = root2, cnt--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> num[a] &gt; num[b];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n, m;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">			flag[i] = <span class="number">0</span>, e[i].<span class="built_in">clear</span>(), fa[i] = p[i] = i, <span class="built_in">cin</span> &gt;&gt; num[i];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> l, r;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">			e[l].push_back(r), e[r].push_back(l);</span><br><span class="line">		&#125;</span><br><span class="line">		sort(p + <span class="number">1</span>, p + <span class="number">1</span> + n, cmp);</span><br><span class="line">		cnt = <span class="number">1</span>;</span><br><span class="line">		ll ans = <span class="number">0</span>;</span><br><span class="line">		flag[p[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			ans += (ll)cnt * (num[p[i - <span class="number">1</span>]] - num[p[i]]);</span><br><span class="line">			cnt++;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> x : e[p[i]]) &#123;</span><br><span class="line">				<span class="keyword">int</span> u = p[i];</span><br><span class="line">				<span class="keyword">if</span> (!flag[x])	<span class="keyword">continue</span>;</span><br><span class="line">				join(u, x);</span><br><span class="line">			&#125;</span><br><span class="line">			flag[p[i]] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ans += (ll)cnt * num[p[n]];</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>杭电多校第三场 1005 Little W and Contest 题解</title>
    <url>/2020/07/30/%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B8%89%E5%9C%BA-1005-Little-W-and-Contest-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6795" target="_blank" rel="noopener">题目大意</a></h3><p>总共有n个人，每个人都有自己的权值1或者2。</p>
<p>组成一个队伍至少需要三个人，最少需要两个2。每个队伍不能存在任意两个互相认识的人。</p>
<p>输入n-1组关系，使两个人熟悉，保证之前是都不认识的。输出每一次熟悉之后剩下的能组成队伍的个数。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这个题目其实看懂了不难。</p>
<p>首先全部个数就是$C_{cnt2}^{3}+C_{cnt1}^1*C_{cnt2}^2$。</p>
<p>（在求这个的时候我又用了取模。。我又忘了除法不能同余。我自裁。。</p>
<p>之后就只需要在这个基础上不断减少就可以了。</p>
<p>用c1和c2两个数组来维持并查集中不同集合中的为1和为2的个数。</p>
<p>因为之前都是互不认识的，所以必定根节点不同。</p>
<p>（之前就没注意到，想了好久要不要判断是否根节点不同。。</p>
<p>之后的就简单了，考虑到四种情况就可以了。</p>
<blockquote>
<p>1、1 2 2</p>
<p>2、2 1 2</p>
<p>3、2 2 1</p>
<p>4、2 2 2</p>
</blockquote>
<p>把这四种情况减去就可以了。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> fa[N];</span><br><span class="line">ll c1[N], c2[N];</span><br><span class="line">ll cnt1, cnt2;</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> son)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> root = son;</span><br><span class="line">	<span class="keyword">while</span> (fa[root] != root)	root = fa[root];</span><br><span class="line">	<span class="keyword">while</span> (son != root) &#123;</span><br><span class="line">		<span class="keyword">int</span> t = fa[son];</span><br><span class="line">		fa[son] = root;</span><br><span class="line">		son = t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> rt1 = <span class="built_in">find</span>(a), rt2 = <span class="built_in">find</span>(b);</span><br><span class="line">	ans -= c2[rt1] * c2[rt2] * (cnt2 - c2[rt1] - c2[rt2]);</span><br><span class="line">	ans -= c2[rt1] * c2[rt2] * (cnt1 - c1[rt1] - c1[rt2]);</span><br><span class="line">	ans -= c1[rt1] * c2[rt2] * (cnt2 - c2[rt1] - c2[rt2]);</span><br><span class="line">	ans -= c2[rt1] * c1[rt2] * (cnt2 - c2[rt1] - c2[rt2]);</span><br><span class="line">	fa[rt1] = rt2;</span><br><span class="line">	c1[rt2] += c1[rt1], c2[rt2] += c2[rt1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t; <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		cnt1 = cnt2 = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> x; <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">			fa[i] = i;</span><br><span class="line">			<span class="keyword">if</span> (x == <span class="number">1</span>)	c1[i] = <span class="number">1</span>, c2[i] = <span class="number">0</span>, cnt1++;</span><br><span class="line">			<span class="keyword">else</span> c1[i] = <span class="number">0</span>, c2[i] = <span class="number">1</span>, cnt2++;</span><br><span class="line">		&#125;</span><br><span class="line">		ans = cnt2 * (cnt2 - <span class="number">1</span>) * (cnt2 - <span class="number">2</span>) / <span class="number">6</span> + cnt2 * (cnt2 - <span class="number">1</span>) * cnt1 / <span class="number">2</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans % mod &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> u, v; <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">			join(u, v);</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; ans % mod &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>杭电多校第二场 1010 Lead of Wisdom 题解</title>
    <url>/2020/07/24/%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%BA%8C%E5%9C%BA-1010-Lead-of-Wisdom-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6772" target="_blank" rel="noopener">题目大意</a></h3><p>有n件装备，总共有k种。每种装备最多选一件，每件装备都有abcd四个属性$\large DMG=\left(100+\sum_\limits{i\in S} a_i\right)\left(100+\sum_\limits{i\in S} b_i\right)\left(100+\sum_\limits{i\in S} c_i\right)\left(100+\sum_\limits{i\in S} d_i\right)$</p>
<p>求这个式子的最大值。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>刚开始看到这个题目的时候，发现这个数据不大，就想着应该可以暴力搜索。</p>
<p>但是t了好几遍，就没写了。</p>
<p>后面比完了看题解，？怎么和我的思路一模一样。</p>
<p>但是我的t了。</p>
<p>结果发现我vector忘初始化了。</p>
<p>吐了，被自己蠢哭了。</p>
<p>后面初始化之后就过了。</p>
<p>唉。。希望自己不要再犯这么低级的错误了。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line">ll ans;</span><br><span class="line"><span class="keyword">int</span> flag[<span class="number">55</span>];</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> a, b, c, d;</span><br><span class="line">&#125;T;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="built_in">vector</span>&lt;T&gt; e[<span class="number">55</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">cal</span><span class="params">(ll a, ll b, ll c, ll d)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="number">100</span> + a) * (<span class="number">100</span> + b) * (<span class="number">100</span> + c) * (<span class="number">100</span> + d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> j,ll a,ll b,ll c,ll d)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> x : e[t]) &#123;</span><br><span class="line">		a += x.a, b += x.b, c += x.c, d += x.d;</span><br><span class="line">		<span class="keyword">if</span> (j==v.<span class="built_in">size</span>()<span class="number">-1</span>) &#123;</span><br><span class="line">			ans = <span class="built_in">max</span>(ans, cal(a, b, c, d));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			slove(v[j+<span class="number">1</span>],j+<span class="number">1</span>, a, b, c, d);</span><br><span class="line">		&#125;</span><br><span class="line">		a -= x.a, b -= x.b, c -= x.c, d -= x.d;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(flag, <span class="number">0</span>, <span class="keyword">sizeof</span>(flag));</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">		v.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)	e[i].<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> ty;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; ty;</span><br><span class="line">			<span class="keyword">if</span> (!flag[ty])	v.push_back(ty);</span><br><span class="line">			flag[ty] = <span class="number">1</span>;</span><br><span class="line">			T a;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; a.a &gt;&gt; a.b &gt;&gt; a.c &gt;&gt; a.d;</span><br><span class="line">			e[ty].push_back(a);</span><br><span class="line">		&#125;</span><br><span class="line">		ans = <span class="number">0</span>;</span><br><span class="line">		slove(v[<span class="number">0</span>],<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>杭电多校第二场 1006 The Oculus 题解</title>
    <url>/2020/07/25/%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%BA%8C%E5%9C%BA-1006-The-Oculus-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6768" target="_blank" rel="noopener">题目大意</a></h3><p>给你一个从1,2开始的斐波那契数列，给你三个数$a,b,c$，以及三个数用斐波那契数列的表示形式，这个c是修改后的c，原本c等于a*b，但是将其中一位的1替换成了0，问你是哪一位替换了。</p>
<p>$\large b_1\times F_1+b_2\times F_2+\dots+b_n\times F_n=x$</p>
<p>其中的$b_n\in {0,1}$。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>说实话，这个题目原题好吓人。</p>
<p>看了一下没看懂，就没去做这个题目了。</p>
<p>补题的时候发现其实这个应该是签到题。</p>
<p>我们已经知道了a和b的值，只需要用这两个数的乘积减去c，然后判断这个差值是等于哪一位斐波那契数列的值即可。</p>
<p>即需要找到满足使斐波那契数列两两不相同的模数P，使$F_kmodp=(a*b-c)modP$。</p>
<p>这一步应该是这个题的难点了。</p>
<p>（反正我是没想到。。</p>
<p>看了一个大佬的题解，貌似可以用暴力枚举，求出一个值3799912185593857。</p>
<p>但是其他题解都是用的$2^{64}$，即ull的自然溢出。</p>
<p>但是我不知道为啥$2^{64}$就能满足这个条件。。</p>
<p>可能对于大佬来说这就是常识吧。。</p>
<p>像上场比赛的1005一样，一开始不知道为啥n可以摸mod-1，后来一查才发现，是用了欧拉降幂。。</p>
<p>我太弱了。。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e6</span> + <span class="number">5</span>;</span><br><span class="line">ull F[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	F[<span class="number">1</span>] = <span class="number">1</span>, F[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; maxn; i++)</span><br><span class="line">		F[i] = F[i - <span class="number">1</span>] + F[i - <span class="number">2</span>];</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> A, B, C;</span><br><span class="line">		ull a, b, c;</span><br><span class="line">		a = b = c = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; A;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= A; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> x;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">			<span class="keyword">if</span> (x)	a += F[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; C;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= C; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> x;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">			<span class="keyword">if</span> (x)	b += F[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; C;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= C; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> x;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">			<span class="keyword">if</span> (x)	c += F[i];</span><br><span class="line">		&#125;</span><br><span class="line">		ull ans = a * b;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (ans - c != F[i])	i++;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title>杭电多校第四场 1012 Last Problem 题解</title>
    <url>/2020/08/01/%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E7%AC%AC%E5%9B%9B%E5%9C%BA-1012-Last-Problem-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6813" target="_blank" rel="noopener">题目大意</a></h3><p>在一个无穷大的画板上，你有n种颜色，编号从1到n，你需要涂第n种颜色，当你涂第i种颜色的时候，他的四周相邻的格子必须有他前面的四种颜色，即n-1到n-4，输出正确的步骤。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>刚开始的时候看到这个题目，就知道应该是构造，然后递归。</p>
<p>结果我倒推了半天没推出来。</p>
<p>首先你需要涂n，就需要这样。</p>
<p><img src="https://ae01.alicdn.com/kf/H6287a38f0b134438904a970bf1a8835fh.jpg" alt=""></p>
<p>为了能涂出n-1到n-4，你就需要这样。</p>
<p><img src="https://ae01.alicdn.com/kf/Hea390a3b93e04d92873c33adf4460167o.jpg" alt=""></p>
<p>你会发现，对于每个灰色的颜色，他们都满足上面的n的颜色分布。</p>
<p>这样，我们就能根据第一张图的颜色分布，构造出正确的涂色的情况了。</p>
<p>只需要dfs出步骤即可。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mp[<span class="number">2020</span>][<span class="number">2020</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (val &lt;= <span class="number">0</span>)	<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (mp[x][y - <span class="number">1</span>] != val - <span class="number">1</span>)	dfs(x, y - <span class="number">1</span>, val - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (mp[x - <span class="number">1</span>][y] != val - <span class="number">2</span>)	dfs(x - <span class="number">1</span>, y, val - <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span> (mp[x + <span class="number">1</span>][y] != val - <span class="number">3</span>)	dfs(x + <span class="number">1</span>, y, val - <span class="number">3</span>);</span><br><span class="line">	<span class="keyword">if</span> (mp[x][y + <span class="number">1</span>] != val - <span class="number">4</span>)	dfs(x, y + <span class="number">1</span>, val - <span class="number">4</span>);</span><br><span class="line">	mp[x][y] = val;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; x &lt;&lt;<span class="string">" "</span>&lt;&lt; y &lt;&lt;<span class="string">" "</span>&lt;&lt; mp[x][y] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="built_in">memset</span>(mp, <span class="number">0</span>, <span class="keyword">sizeof</span>(mp));</span><br><span class="line">	dfs(<span class="number">1000</span>, <span class="number">1000</span>, n);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>杭电多校第四场 1005 Equal Sentences 题解</title>
    <url>/2020/07/30/%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E7%AC%AC%E5%9B%9B%E5%9C%BA-1005-Equal-Sentences-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6806" target="_blank" rel="noopener">题目大意</a></h3><p>把一个单词串定义为与原本单词串s几乎相等，当且仅当单词串只是由原本单词串相邻的单词交换所形成的，求原本单词串有多少个几乎相等的单词串。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>服了这翻译。</p>
<p>我看题看了半天没看懂。</p>
<p>直接跳了。</p>
<p>结果发现这个题目就是简单的dp。。</p>
<p>定义dp[i]为从第一个单词到第i个单词所形成的单词串有多少几乎相等的单词串。</p>
<p>如果第i个单词与第i-1个单词相同，则不需要交换，$dp[i] = dp[i-1]$。</p>
<p>如果第i个单词与第i-1个单词不相同，则不交换时贡献为$dp[i-1]$，交换时贡献为$dp[i-2]$，所以状态转移为$dp[i] = dp[i-1]+dp[i-2]$。</p>
<p>注意初始化$dp[0]=dp[1]=1$。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dp[N];</span><br><span class="line"><span class="built_in">string</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t; <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; s[i];</span><br><span class="line">		dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (s[i] == s[i - <span class="number">1</span>])	dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">			<span class="keyword">else</span> dp[i] = (dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>])%mod;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; dp[n]%mod  &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>树形DP</title>
    <url>/2020/07/08/%E6%A0%91%E5%BD%A2DP/</url>
    <content><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>树形dp顾名思义就是在“树”上进行动态规划，通过遍历树等一些操作来完成题目要求。</p>
<p>在树形动态规划中是建立在树上的，由树中的父节点和子节点的关系推出来的。</p>
<p>一般有两种。</p>
<p> 1、就是由子节点推到父节点，即根的子节点传递有用的信息给父节点，最终有父节点再求出最优解。（此形式较为常用）</p>
<p> 2、从父节点推至子节点，这种情况的意思是需要取所有点来求出父节点的值，再减去要除的子节点的dp状态，再将其转移，这样就可由根节点推至叶节点。</p>
<p>通常使用链式前向星来建树。</p>
<a id="more"></a>

<h3 id="实现形式"><a href="#实现形式" class="headerlink" title="实现形式"></a>实现形式</h3><p>树形dp与其他的dp存在一些区别。</p>
<p>他没有固定的形式，很多时候会与其他的算法结合，像背包等等。</p>
<p>与其说是一种算法，说是一种思想更加恰当。</p>
<p>因为自己也不是很理解，也就不详细讲了。。</p>
<p>以后慢慢学习吧，还有很长的路要走。</p>
<p>那这里贴一下链式前向星模板。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">6060</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],cnt,in[N];<span class="comment">//head数组通常初始化为-1，可以用in数组来求一棵树的根节点</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> to, val, next;</span><br><span class="line">&#125;Map[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">	Map[++cnt].to = v;</span><br><span class="line">    Map[cnt].val = val;</span><br><span class="line">	Map[cnt].next = head[u];</span><br><span class="line">	head[u] = cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="典型例题"><a href="#典型例题" class="headerlink" title="典型例题"></a>典型例题</h3><h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1520" target="_blank" rel="noopener">题目大意</a></h4><p>在公司中，老板和员工构成了一个树形结构，每个人有自己的开心值，有一天举办了一个聚会，但是每个人很讨厌和自己的上司一起去，所以上司去他就不会去。问公司最大开心值。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>先用链式前向星构树。</p>
<p>我们可以用$dp[i][0]$来表示，以i为根节点的子树中，i不去的最大开心值。</p>
<p>$dp[i][1]$来表示，以i为根节点的子树中，i去的最大开心值。</p>
<p>可以得出状态转移方程。</p>
<p>设i的某一个子节点为x。</p>
<p>$dp[i][0] += max(dp[x][0],dp[x][1])$。</p>
<p>$dp[i][1] += dp[x][0]$。</p>
<p>最后答案为$max(dp[root][0],dp[root][1])$。</p>
<h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">6060</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],cnt,dp[N][<span class="number">3</span>],h[N],in[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> to, next;</span><br><span class="line">&#125;Map[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">	Map[++cnt].to = v;</span><br><span class="line">	Map[cnt].next = head[u];</span><br><span class="line">	head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">	dp[p][<span class="number">0</span>] = <span class="number">0</span>, dp[p][<span class="number">1</span>] = h[p];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = head[p]; ~i; i = Map[i].next) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = Map[i].to;</span><br><span class="line">		dfs(x);</span><br><span class="line">		dp[p][<span class="number">0</span>] += <span class="built_in">max</span>(dp[x][<span class="number">0</span>], dp[x][<span class="number">1</span>]);</span><br><span class="line">		dp[p][<span class="number">1</span>] += dp[x][<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n) &#123;</span><br><span class="line">		cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(Map, <span class="number">0</span>, <span class="keyword">sizeof</span>(Map));</span><br><span class="line">		<span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">		<span class="built_in">memset</span>(in, <span class="number">0</span>, <span class="keyword">sizeof</span>(in));</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; h[i];</span><br><span class="line">		<span class="keyword">int</span> l, k;</span><br><span class="line">		<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; l &gt;&gt; k &amp;&amp; l || k) &#123;</span><br><span class="line">			build(k, l);</span><br><span class="line">			in[l]++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> root = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!in[i]) &#123;</span><br><span class="line">				root = i;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		dfs(root);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">max</span>(dp[root][<span class="number">1</span>], dp[root][<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title>杭电多校第四场 1004 Deliver the Cake 题解</title>
    <url>/2020/07/31/%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E7%AC%AC%E5%9B%9B%E5%9C%BA-1004-Deliver-the-Cake-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6805" target="_blank" rel="noopener">题目大意</a></h3><p>给你一个n个点m条边的双向图，告诉你起点和终点，以及每个点对左右手的要求，如果是M的话，则既可以左手，又可以右手，但是交换手是需要时间的，求起点到终点的最短距离。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这题比赛的时候毫无思路。</p>
<p>结束的时候直接看的题解。</p>
<p>没做过这种题的真的写的出吗。。</p>
<p>这个拆点的想法也太神奇了吧。</p>
<p>对于M的点，我们可以把i点当做是用左手，i+n当做是用右手。</p>
<p>这样就相当于多加了边。</p>
<p>如果是从不同的手切换来的，边的权值就等于原本路的权值加上换手的权值。</p>
<p>相同的话，就等于原本路的权值。</p>
<p>需要注意，如果起点和终点是M的话，就会出现两个起点和终点。</p>
<p>可以令0和$2n+1$作为真正的起点和终点。</p>
<p>只是需要在原本的基础上，加上0到两个起点，和$2n+1$到两个终点的边即可。</p>
<p>（找了一下午bug。。结果发现是return0在while循环里面。。吐了。。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>, M = <span class="number">2e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">int</span> head[N], vis[N], n, m, s, e, x, cnt;</span><br><span class="line">ll dis[N];</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, val;</span><br><span class="line">&#125;Map[M];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    ll c;</span><br><span class="line">    node(<span class="keyword">int</span> a = <span class="number">0</span>, ll b = <span class="number">0</span>) :v(a), c(b) &#123;&#125;;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> node&amp; a) <span class="keyword">const</span> &#123; <span class="keyword">return</span> c &gt; a.c; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    Map[cnt].to = v, Map[cnt].val = val;</span><br><span class="line">    Map[cnt].next = head[u], head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">    priority_queue&lt;node&gt;q;</span><br><span class="line">    <span class="keyword">if</span> (str[s] == <span class="string">'M'</span>) dis[<span class="number">0</span>] = <span class="number">0</span>,q.push(node(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">else</span> dis[s] = <span class="number">0</span>,q.push(node(s, <span class="number">0</span>));</span><br><span class="line">    node t;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        t = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">int</span> u = t.v;</span><br><span class="line">        <span class="keyword">if</span> (vis[u])    <span class="keyword">continue</span>;</span><br><span class="line">        vis[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = Map[i].next) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = Map[i].to, c = Map[i].val;</span><br><span class="line">            <span class="keyword">if</span> (!vis[v] &amp;&amp; dis[v] &gt; dis[u] + c)</span><br><span class="line">                dis[v] = dis[u] + c, q.push(node(v, dis[v]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (str[e] == <span class="string">'M'</span>)    <span class="keyword">return</span> dis[<span class="number">2</span> * n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> dis[e];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> t; <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; e &gt;&gt; x &gt;&gt; str + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)), cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (str[s] == <span class="string">'M'</span>) &#123;</span><br><span class="line">            build(<span class="number">0</span>, s, <span class="number">0</span>), build(s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            build(<span class="number">0</span>, s + n, <span class="number">0</span>), build(s + n, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (str[e] == <span class="string">'M'</span>) &#123;</span><br><span class="line">            build(e, <span class="number">2</span> * n + <span class="number">1</span>, <span class="number">0</span>), build(<span class="number">2</span> * n + <span class="number">1</span>, e, <span class="number">0</span>);</span><br><span class="line">            build(e + n, <span class="number">2</span> * n + <span class="number">1</span>, <span class="number">0</span>), build(<span class="number">2</span> * n + <span class="number">1</span>, e + n, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> u, v, c;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; c;</span><br><span class="line">            <span class="keyword">if</span> ((str[u] == <span class="string">'L'</span> &amp;&amp; str[v] == <span class="string">'R'</span>) || (str[u] == <span class="string">'R'</span> &amp;&amp; str[v] == <span class="string">'L'</span>))</span><br><span class="line">                build(u, v, c + x), build(v, u, c + x);</span><br><span class="line">            <span class="keyword">if</span> ((str[u] == <span class="string">'L'</span> &amp;&amp; str[v] == <span class="string">'L'</span>) || (str[u] == <span class="string">'R'</span> &amp;&amp; str[v] == <span class="string">'R'</span>))</span><br><span class="line">                build(u, v, c), build(v, u, c);</span><br><span class="line">            <span class="keyword">if</span> (str[u] == <span class="string">'L'</span> &amp;&amp; str[v] == <span class="string">'M'</span>) &#123;</span><br><span class="line">                build(u, v, c), build(u, v + n, c + x);</span><br><span class="line">                build(v, u, c), build(v + n, u, c + x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (str[u] == <span class="string">'M'</span> &amp;&amp; str[v] == <span class="string">'L'</span>) &#123;</span><br><span class="line">                swap(u, v);</span><br><span class="line">                build(u, v, c), build(u, v + n, c + x);</span><br><span class="line">                build(v, u, c), build(v + n, u, c + x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (str[u] == <span class="string">'R'</span> &amp;&amp; str[v] == <span class="string">'M'</span>) &#123;</span><br><span class="line">                build(u, v, c + x), build(u, v + n, c);</span><br><span class="line">                build(v, u, c + x), build(v + n, u, c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (str[u] == <span class="string">'M'</span> &amp;&amp; str[v] == <span class="string">'R'</span>) &#123;</span><br><span class="line">                swap(u, v);</span><br><span class="line">                build(u, v, c + x), build(u, v + n, c);</span><br><span class="line">                build(v, u, c + x), build(v + n, u, c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (str[u] == <span class="string">'M'</span> &amp;&amp; str[v] == <span class="string">'M'</span>) &#123;</span><br><span class="line">                build(u, v, c), build(u, v + n, c + x), build(u + n, v, c + x), build(u + n, v + n, c);</span><br><span class="line">                swap(u, v);</span><br><span class="line">                build(u, v, c), build(u, v + n, c + x), build(u + n, v, c + x), build(u + n, v + n, c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; Dijkstra() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>拆点</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客多校第四场 F Finding the Order 题解</title>
    <url>/2020/07/22/%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1%E7%AC%AC%E5%9B%9B%E5%9C%BA-Finding-the-Order-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://ac.nowcoder.com/acm/contest/5669/F" target="_blank" rel="noopener">题目大意</a></h3><p>有两条平行线，上面一根有ab两点，下面一根有cd两点，问是ab//cd，还是ab//dc。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>其实这个题目就是一个签到水题。</p>
<p>题目并不难，就连接四根线，取左右两个三角形。</p>
<p>由两个三角形边长关系之和，可以得出ad+bc&gt;ac+ad。</p>
<p>题目不难，关键是我一下子没想到这个思路。</p>
<p>思维很重要，写这个题解就是需要告诉自己这一点，acm是需要多思考的。</p>
<p>希望自己以后思维更加灵活吧。</p>
<p>至少这种题目是不应该写不出的。</p>
<p>（其实给我乱凑凑出来了。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> a, b, c, d;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line">		<span class="keyword">if</span> (a+d&lt;b+c)	<span class="built_in">cout</span> &lt;&lt; <span class="string">"AB//CD"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"AB//DC"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>第十七届“科大讯飞杯” D 车辆调度 题解</title>
    <url>/2020/07/08/%E7%AC%AC%E5%8D%81%E4%B8%83%E5%B1%8A%E2%80%9C%E7%A7%91%E5%A4%A7%E8%AE%AF%E9%A3%9E%E6%9D%AF%E2%80%9D-D-%E8%BD%A6%E8%BE%86%E8%B0%83%E5%BA%A6-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://ac.nowcoder.com/acm/contest/5477/D" target="_blank" rel="noopener">题目大意</a></h3><p>张老师设计了一个智能调度系统来控制他的遥控车队，今天，他带着他的车队来到黄渡理工大学的一块空地上测试这个系统。<br> 这块空地可以描述为一个 w * h 大小的长方形，广场上有一些障碍物，几个目标点，当然，还有张老师的车队。<br> 每分钟，调度系统会智能地向其中的一辆遥控车发送以下指令的其中一条： </p>
<ol>
<li><p>​    向北走，直到撞到空地的边界、障碍物或其他遥控车；   </p>
</li>
<li><p>​    向南走，直到撞到空地的边界、障碍物或其他遥控车；   </p>
</li>
<li><p>​    向西走，直到撞到空地的边界、障碍物或其他遥控车；   </p>
</li>
<li><p>​    向东走，直到撞到空地的边界、障碍物或其他遥控车；   </p>
<p>​    每条指令都会在一分钟之内完成，也就是说，空地上最多只有一辆遥控车在运动。此外，当遥控车无法向相应的方向移动时，它会停在原地。   </p>
<p>你想知道，在第 k 分钟时，有没有可能有任意一辆遥控车处在任意一个目标点上。</p>
</li>
</ol>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>很明显的搜索，模拟这个车的行动。</p>
<p>（但是。。我真的不是很会搜索。。</p>
<p>其实想到了DFS但是没想到怎么去模拟，卡了半天。</p>
<p>（还是需要再去学一下。。刚开始学的时候可能没学懂。</p>
<p>其实BFS也是可以的。。不想写了</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> Map[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> n, m, k, flag;</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">5</span>] = &#123; <span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span> &#125;, dy[<span class="number">5</span>] = &#123; <span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; <span class="number">1</span> || x &gt; n || y &lt; <span class="number">1</span> || y &gt; m || Map[y][x] == <span class="string">'X'</span> || Map[y][x] == <span class="string">'R'</span>)	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (t &gt;= k)	<span class="keyword">return</span>;<span class="comment">//搜索步数，这点永远想不到。。</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (Map[i][j] == <span class="string">'R'</span>) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> g = <span class="number">0</span>; g &lt; <span class="number">4</span>; g++) &#123;</span><br><span class="line">					<span class="keyword">int</span> x = j, y = i;</span><br><span class="line">					<span class="keyword">while</span> (check(x + dx[g], y + dy[g]))	x += dx[g], y += dy[g];</span><br><span class="line">					<span class="keyword">if</span> (Map[y][x] == <span class="string">'D'</span>)	flag = <span class="number">1</span>;</span><br><span class="line">					<span class="keyword">if</span> (flag)	<span class="keyword">return</span>;</span><br><span class="line">					swap(Map[i][j], Map[y][x]);</span><br><span class="line">					dfs(t + <span class="number">1</span>);</span><br><span class="line">					swap(Map[i][j], Map[y][x]);<span class="comment">//注意还原，也经常想不到</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; Map[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	flag = <span class="number">0</span>;</span><br><span class="line">	dfs(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (flag)	<span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客多校第四场 B Basic Gcd Problem 题解</title>
    <url>/2020/07/23/%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1%E7%AC%AC%E5%9B%9B%E5%9C%BA-B-Basic-Gcd-Problem-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://ac.nowcoder.com/acm/contest/5669/B" target="_blank" rel="noopener">题目大意</a></h3><p>定义函数$\large f_c(x) = max(1-&gt;x-1) c·f_c(gcd(i,x)) \quad x &gt; 1$</p>
<p>$\large f_c(x) = 1 \quad x=1$。</p>
<p>求$\large f_c(n)$。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>很明显，答案肯定是$c^n$，所以我们需要使这个n尽可能的大。</p>
<p>由于质数与其他数的gcd都是1，所以我们不需要考虑质数。</p>
<p>那么对于其他的数来说，我们可以将他们分解成质因数相乘，每一个质因数就是相当于乘以一个c。</p>
<p>那么答案就只需要统计其质因数的数量然后用快速幂即可。</p>
<p>（我统计的时候乘就TLE了。。乘这么慢的吗。。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> num[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)    ans = ans*a%mod;</span><br><span class="line">        a = a*a%mod,b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">slove</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i*i &lt;= a; i++) &#123;</span><br><span class="line">		<span class="keyword">while</span> (a % i == <span class="number">0</span>) &#123;</span><br><span class="line">			ans++;</span><br><span class="line">			a /= i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;<span class="number">1</span>)    ans++;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n, c;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; c;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; qpow((ll)c,slove(n)) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>gcd</tag>
      </tags>
  </entry>
  <entry>
    <title>约瑟夫环问题</title>
    <url>/2020/07/08/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>约瑟夫环问题都很熟悉了，这里也就不多赘述了。</p>
<p>主要是来记录一下，约瑟夫环的一些解法。</p>
<a id="more"></a>

<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>这里我就不详细写推理的过程了。。（其实我也不会。。</p>
<p>网上应该一搜一大片。</p>
<p>1、迭代</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cir</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		p=(p+m)%i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、公式</p>
<p>我不知道这个公式是哪个鬼才想出来的。。</p>
<p>我在网上都没有找到。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">S</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n&amp;<span class="number">1</span>)	<span class="keyword">return</span> S((n<span class="number">-1</span>)/<span class="number">2</span>)*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>	<span class="keyword">return</span> S(n/<span class="number">2</span>)*<span class="number">2</span><span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用这个可以过掉1e9的题。。</p>
<p>上面那个会TLE。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>约瑟夫环</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树</title>
    <url>/2020/07/08/%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    <content><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>1、线段树是一棵二叉搜索树，它储存的是一个区间的信息。</p>
<p>2、每个节点以结构体的方式存储，结构体包含以下几个信息：</p>
<p>   区间左端点、右端点；（这两者必有）</p>
<p>   这个区间要维护的信息（事实际情况而定，数目不等）。</p>
<p>3、线段树的基本思想：<strong>二分</strong>。</p>
<p>4、线段树一般结构如图所示：</p>
<p><img src="https://ae01.alicdn.com/kf/H81ea5477dc55444399dd94d0e43f00633.jpg" alt=""></p>
<p>5、特殊性质：</p>
<p>由上图可得，</p>
<p>1、每个节点的左孩子区间范围为$[l,mid]$，右孩子为$[mid+1,r]$。</p>
<p>2、对于结点k，左孩子结点为$2<em>k$，右孩子为$2</em>k+1$，这符合完全二叉树的性质。</p>
<a id="more"></a>

<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>要实现线段树，首先需要构造一颗树。</p>
<p>这里以结构体为例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> l;<span class="comment">//该节点的左边界</span></span><br><span class="line">    <span class="keyword">int</span> r;<span class="comment">//该节点的右边界</span></span><br><span class="line">    <span class="keyword">int</span> sum;<span class="comment">//该节点的值</span></span><br><span class="line">    <span class="keyword">int</span> lz;<span class="comment">//之后说的lazytage</span></span><br><span class="line">&#125;tree[N&lt;&lt;<span class="number">2</span>];<span class="comment">//N为最大节点数量，需要开四倍大小。</span></span><br></pre></td></tr></table></figure>

<h4 id="1、建树"><a href="#1、建树" class="headerlink" title="1、建树"></a>1、建树</h4><p>我们可以用递归的方式来建树。</p>
<p>给每个节点记录他的左边界和右边界。</p>
<p>然后递归左子树和右子树。</p>
<p>如果该节点左右边界相等，则说明是子节点，赋值后结束递归。</p>
<p>建树之后记得更新自身的值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> i=<span class="number">1</span>,<span class="keyword">int</span> l=<span class="number">1</span>,<span class="keyword">int</span> r=n)</span> </span>&#123;</span><br><span class="line">	tree[i].l = l, tree[i].r = r;</span><br><span class="line">	<span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">		tree[i].sum = num[l];</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	build(i &lt;&lt; <span class="number">1</span>, l, mid);<span class="comment">//建左子树</span></span><br><span class="line">	build(i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);<span class="comment">//建右子树</span></span><br><span class="line">	tree[i].sum = tree[i &lt;&lt; <span class="number">1</span>].sum + tree[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、区间修改"><a href="#2、区间修改" class="headerlink" title="2、区间修改"></a>2、区间修改</h4><p>为了实现区间修改的功能，我们需要引入一个叫做“lazytage”的东西，就是懒标记。</p>
<p>正如他的名字所说，最大的特点就是懒，只有需要用到他的时候才需要他。</p>
<p>当需要他的时候，就需要一个操作，“pushdown”。</p>
<p>其实意思很好理解，就是将该节点的标记进行下传。</p>
<p>他的左子树和右子树加上该节点的懒标记，同时更新左右子树的值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (tree[i].lz != <span class="number">0</span>) &#123;</span><br><span class="line">		tree[i &lt;&lt; <span class="number">1</span>].lz += tree[i].lz;<span class="comment">//标记下传</span></span><br><span class="line">		tree[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].lz += tree[i].lz;</span><br><span class="line">		<span class="keyword">int</span> mid = (tree[i].l + tree[i].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		tree[i &lt;&lt; <span class="number">1</span>].sum += tree[i].lz * (mid - tree[i].l + <span class="number">1</span>);<span class="comment">//标记乘上区间长度</span></span><br><span class="line">		tree[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum += tree[i].lz * (tree[i].r - mid);</span><br><span class="line">		tree[i].lz = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在修改的时候，如果某一个节点的区间完全被包含在需要修改的区间中，我们只需要修改这个节点的值，也就是加上标记乘以区间长度的值，并且给他的标记数量加上$k$。</p>
<p>如果不是完全包含在其中的，也就意味我们需要继续的搜索，也意味着我们需要用到这个节点的子节点。</p>
<p>还记得懒标记的定义吗——“只有需要用到他的时候才需要他”。</p>
<p>所以我们需要将懒标记下传。</p>
<p>（这里很重要，我搞懂这里想了好久。。</p>
<p>如果不下传的话，就会导致查询到的值不真实。</p>
<p>如果左子树与这个区间有交集，就搜索左子树。</p>
<p>如果右子树与这个区间有交集，就搜索右子树。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (tree[i].l &gt;= l &amp;&amp; tree[i].r &lt;= r) &#123;<span class="comment">//如果完全被包含，就直接修改</span></span><br><span class="line">		tree[i].sum += k * (tree[i].r - tree[i].l + <span class="number">1L</span>L);</span><br><span class="line">		tree[i].lz += k;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	pushdown(i);<span class="comment">//下传标记</span></span><br><span class="line">	<span class="keyword">if</span> (tree[i &lt;&lt; <span class="number">1</span>].r &gt;= l)	add(i &lt;&lt; <span class="number">1</span>, l, r, k);<span class="comment">//搜索左子树</span></span><br><span class="line">	<span class="keyword">if</span> (tree[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].l &lt;= r)	add(i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, k);<span class="comment">//搜索右子树</span></span><br><span class="line">	tree[i].sum = tree[i &lt;&lt; <span class="number">1</span>].sum + tree[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、区间查询"><a href="#3、区间查询" class="headerlink" title="3、区间查询"></a>3、区间查询</h4><p>从根节点开始搜索。</p>
<p>如果该节点的区域完全被包含在查询的区间中，返回该节点的值即可。</p>
<p>如果该节点的区域在查询的区间外，则直接返回0。</p>
<p>如果我们还需要向下搜索的话，同样是需要pushdown的。</p>
<p>原因同上，我们仍然需要使用到该节点的子节点。</p>
<p>接下来就是类似的了。</p>
<p>如果左子树与这个区间有交集，就搜索左子树。</p>
<p>如果右子树与这个区间有交集，就搜索右子树。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">quiry</span><span class="params">(<span class="keyword">int</span> i ,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (tree[i].l &gt;= l &amp;&amp; tree[i].r &lt;= r)	<span class="keyword">return</span> tree[i].sum;<span class="comment">//如果完全在其中，则直接返回值</span></span><br><span class="line">	<span class="keyword">if</span> (tree[i].r&lt;l || tree[i].l&gt;r)	<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//超出区间外，直接返回0</span></span><br><span class="line">	pushdown(i);</span><br><span class="line">	<span class="keyword">if</span> (tree[i &lt;&lt; <span class="number">1</span>].r &gt;= l)	ans += quiry(i &lt;&lt; <span class="number">1</span>, l, r);<span class="comment">//加上左子树</span></span><br><span class="line">	<span class="keyword">if</span> (tree[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].l &lt;= r)	ans += quiry(i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);<span class="comment">//加上右子树</span></span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（其实线段树还有很多内容，像基础的单点修改，区间查询，区间修改，单点查询，这些完全可以用区间修改和区间查询替代，所以就不讲了。</p>
<p>在区间修改中，懒标记不止有加法，还存在乘法和根号，这些不会。。</p>
<p>（以后可能会补。。大概</p>
<p>想要了解的话，可以<a href="https://www.cnblogs.com/jason2003/p/9676729.html" target="_blank" rel="noopener">点击这里</a>。</p>
<p>因为自己了解的也不是很深，可能没有讲明白。。</p>
<p>不懂的话可以点击上面那个链接。</p>
<h3 id="典型例题"><a href="#典型例题" class="headerlink" title="典型例题"></a>典型例题</h3><p>1、<a href="https://www.luogu.com.cn/problem/P3372" target="_blank" rel="noopener">洛谷P3372 【模板】线段树 1</a></p>
<h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h4><p>如题，已知一个数列，你需要进行下面两种操作：</p>
<ol>
<li>将某区间每一个数加上 $k$。</li>
<li>求出某区间每一个数的和。</li>
</ol>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>典型的区间修改加区间查询。</p>
<p>线段树模板。</p>
<h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> num[N],n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> sum, lz;</span><br><span class="line">	<span class="keyword">int</span> l, r;</span><br><span class="line">&#125;tree[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> i=<span class="number">1</span>,<span class="keyword">int</span> l=<span class="number">1</span>,<span class="keyword">int</span> r=n)</span> </span>&#123;</span><br><span class="line">	tree[i].l = l, tree[i].r = r;</span><br><span class="line">	<span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">		tree[i].sum = num[l];</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	build(i &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">	build(i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">	tree[i].sum = tree[i &lt;&lt; <span class="number">1</span>].sum + tree[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (tree[i].lz != <span class="number">0</span>) &#123;</span><br><span class="line">		tree[i &lt;&lt; <span class="number">1</span>].lz += tree[i].lz;</span><br><span class="line">		tree[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].lz += tree[i].lz;</span><br><span class="line">		<span class="keyword">int</span> mid = (tree[i].l + tree[i].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		tree[i &lt;&lt; <span class="number">1</span>].sum += tree[i].lz * ((<span class="keyword">long</span> <span class="keyword">long</span>)mid - tree[i].l + <span class="number">1</span>);</span><br><span class="line">		tree[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum += tree[i].lz * (tree[i].r - (<span class="keyword">long</span> <span class="keyword">long</span>)mid);</span><br><span class="line">		tree[i].lz = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (tree[i].l &gt;= l &amp;&amp; tree[i].r &lt;= r) &#123;</span><br><span class="line">		tree[i].sum += k * (tree[i].r - tree[i].l + <span class="number">1L</span>L);</span><br><span class="line">		tree[i].lz += k;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	pushdown(i);</span><br><span class="line">	<span class="keyword">if</span> (tree[i &lt;&lt; <span class="number">1</span>].r &gt;= l)	add(i &lt;&lt; <span class="number">1</span>, l, r, k);</span><br><span class="line">	<span class="keyword">if</span> (tree[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].l &lt;= r)	add(i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, k);</span><br><span class="line">	tree[i].sum = tree[i &lt;&lt; <span class="number">1</span>].sum + tree[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">quiry</span><span class="params">(<span class="keyword">int</span> i ,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (tree[i].l &gt;= l &amp;&amp; tree[i].r &lt;= r)	<span class="keyword">return</span> tree[i].sum;</span><br><span class="line">	<span class="keyword">if</span> (tree[i].r&lt;l || tree[i].l&gt;r)	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	pushdown(i);</span><br><span class="line">	<span class="keyword">if</span> (tree[i &lt;&lt; <span class="number">1</span>].r &gt;= l)	ans += quiry(i &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">	<span class="keyword">if</span> (tree[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].l &lt;= r)	ans += quiry(i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num[i]);</span><br><span class="line">	build();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> g;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; g;</span><br><span class="line">		<span class="keyword">if</span> (g == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> x,y, k;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x, &amp;y,&amp;k);</span><br><span class="line">			add(<span class="number">1</span>, x, y, k);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">int</span> x, y;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; quiry(<span class="number">1</span>, x, y) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、<a href="http://codeforces.com/problemset/problem/12/D" target="_blank" rel="noopener">CF-12D Ball</a> </p>
<p>因为这道题我已经写过题解了，这里就不再赘述。</p>
<p>想要了解的可以去看我之前写的题解。</p>
<p><a href="https://sakurakarma.github.io/2020/04/22/CF-12D-Ball-题解/">点击这里</a></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥模拟2第八题题解</title>
    <url>/2020/07/08/%E8%93%9D%E6%A1%A5%E6%A8%A1%E6%8B%9F2%E7%AC%AC%E5%85%AB%E9%A2%98%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​         如果一个序列的奇数项都比前一项大，偶数项都比前一项小，则称为一个摆动序列。即 a[2i]&lt;a[2i-1], a[2i+1]&gt;a[2i]。<br>　　小明想知道，长度为 m，每个数都是 1 到 n 之间的正整数的摆动序列一共有多少个。</p>
<a id="more"></a>

<p>输入格式</p>
<p>　　输入一行包含两个整数 m，n。</p>
<p>输出格式</p>
<p>　　输出一个整数，表示答案。答案可能很大，请输出答案除以10000的余数。</p>
<p>样例输入</p>
<p>3 4</p>
<p>样例输出</p>
<p>14</p>
<p>样例说明</p>
<p>　　以下是符合要求的摆动序列：<br>　　2 1 2<br>　　2 1 3<br>　　2 1 4<br>　　3 1 2<br>　　3 1 3<br>　　3 1 4<br>　　3 2 3<br>　　3 2 4<br>　　4 1 2<br>　　4 1 3<br>　　4 1 4<br>　　4 2 3<br>　　4 2 4<br>　　4 3 4</p>
<p>评测用例规模与约定</p>
<p>　　对于 20% 的评测用例，1 &lt;= n, m &lt;= 5；<br>　　对于 50% 的评测用例，1 &lt;= n, m &lt;= 10；<br>　　对于 80% 的评测用例，1 &lt;= n, m &lt;= 100；<br>　　对于所有评测用例，1 &lt;= n, m &lt;= 1000。</p>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>就是一串数列，要求偶数项要小于前面那项的值，奇数项要大于前面那项的值，长度为m，数字为1~n。求这串数列的最多组成方案。</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>因为奇数项和偶数项的要求不同，所以需要分开来考虑。</p>
<p>奇数项的方案数等于前面一项的所有小于该项值的方案数之和。</p>
<p>偶数项的方案数等于前面一项的所有大于该项值的方案数之和。</p>
<p>于是可以得出定义:<br>dp[i] [j] (i为奇数)等于第i项大于等于j的方案数。</p>
<p>dp[i] [j] (i为偶数)等于第i项小于等于j的方案数。</p>
<p>所以状态转移方程为:</p>
<blockquote>
<p>1、dp[i] [j] = dp[i - 1] [j + 1] + dp[i] [j - 1];</p>
<p>2、dp[i] [j] = dp[i - 1] [j - 1] + dp[i] [j + 1];</p>
</blockquote>
<p>初始化为dp[1] [j] =n - j +1;</p>
<p>如果m为奇数的话，答案为dp[i] [1];</p>
<p>m为偶数的话，答案为dp[i] [n];</p>
<p>(哎。。DP是真的难。。主要是特别难想</p>
<p>基本DP题都能杀我，还是不会DP。</p>
<p>需要多去学习啊。。</p>
<p>别问，问就是题量不够。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		dp[<span class="number">1</span>][i] = n - i + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;<span class="comment">//这里推荐用i&amp;1来判断，比取余要更快</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">				dp[i][j] = (dp[i - <span class="number">1</span>][j + <span class="number">1</span>] + dp[i][j - <span class="number">1</span>]) % <span class="number">10000</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">				dp[i][j] = (dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i][j + <span class="number">1</span>]) % <span class="number">10000</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (m % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; dp[m][n];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; dp[m][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
        <category>蓝桥</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥模拟2第九题题解</title>
    <url>/2020/07/08/%E8%93%9D%E6%A1%A5%E6%A8%A1%E6%8B%9F2%E7%AC%AC%E4%B9%9D%E9%A2%98%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>　　小明和朋友们一起去郊外植树，他们带了一些在自己实验室精心研究出的小树苗。<br>　　小明和朋友们一共有 n 个人，他们经过精心挑选，在一块空地上每个人挑选了一个适合植树的位置，总共 n 个。他们准备把自己带的树苗都植下去。<br>　　然而，他们遇到了一个困难：有的树苗比较大，而有的位置挨太近，导致两棵树植下去后会撞在一起。<br>　　他们将树看成一个圆，圆心在他们找的位置上。如果两棵树对应的圆相交，这两棵树就不适合同时植下（相切不受影响），称为两棵树冲突。<br>　　小明和朋友们决定先合计合计，只将其中的一部分树植下去，保证没有互相冲突的树。他们同时希望这些树所能覆盖的面积和（圆面积和）最大。</p>
<a id="more"></a>

<p>输入格式</p>
<p>　　输入的第一行包含一个整数 n ，表示人数，即准备植树的位置数。<br>　　接下来 n 行，每行三个整数 x, y, r，表示一棵树在空地上的横、纵坐标和半径。</p>
<p>输出格式</p>
<p>　　输出一行包含一个整数，表示在不冲突下可以植树的面积和。由于每棵树的面积都是圆周率的整数倍，请输出答案除以圆周率后的值（应当是一个整数）。</p>
<p>样例输入</p>
<p>6<br>1 1 2<br>1 4 2<br>1 7 2<br>4 1 2<br>4 4 2<br>4 7 2</p>
<p>样例输出</p>
<p>12</p>
<p>评测用例规模与约定</p>
<p>　　对于 30% 的评测用例，1 &lt;= n &lt;= 10；<br>　　对于 60% 的评测用例，1 &lt;= n &lt;= 20；<br>　　对于所有评测用例，1 &lt;= n &lt;= 30，0 &lt;= x, y &lt;= 1000，1 &lt;= r &lt;= 1000。</p>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>每棵树都占有一定的面积，求出如何种树，在面积不冲突的情况下，占有的最大面积。</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>比赛的时候根本没想到用DFS。。。</p>
<p>看了学长的代码才发现可以用DFS。</p>
<p>用dfs遍历每一颗树，求出最大值，数据不是很大。</p>
<p>(DFS，BFS。。。技术盲区啊</p>
<p>还是要去多学学搜索，多写写题。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">int</span> y;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">&#125;a[<span class="number">35</span>];</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>, n, flag[<span class="number">35</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i != node &amp;&amp; flag[i]) &#123;</span><br><span class="line">			<span class="keyword">double</span> d = <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(a[node].x - a[i].x, <span class="number">2</span>) + <span class="built_in">pow</span>(a[node].y - a[i].y, <span class="number">2</span>));</span><br><span class="line">			<span class="keyword">if</span> (d &lt; (<span class="keyword">double</span>)a[node].r + a[i].r)	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (num == n) &#123;</span><br><span class="line">		ans = <span class="built_in">max</span>(ans, sum);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!flag[i]) &#123;</span><br><span class="line">				flag[i] = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span> (check(i)) &#123;</span><br><span class="line">					dfs(num + <span class="number">1</span>, sum + <span class="built_in">pow</span>(a[i].r, <span class="number">2</span>));</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					dfs(num + <span class="number">1</span>, sum);</span><br><span class="line">				&#125;</span><br><span class="line">				flag[i] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a[i].x &gt;&gt; a[i].y &gt;&gt; a[i].r;</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
        <category>蓝桥</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥模拟2第十题题解</title>
    <url>/2020/07/08/%E8%93%9D%E6%A1%A5%E6%A8%A1%E6%8B%9F2%E7%AC%AC%E5%8D%81%E9%A2%98%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​        2015年，全中国实现了户户通电。作为一名电力建设者，小明正在帮助一带一路上的国家通电。<br>　　这一次，小明要帮助 n 个村庄通电，其中 1 号村庄正好可以建立一个发电站，所发的电足够所有村庄使用。<br>　　现在，这 n 个村庄之间都没有电线相连，小明主要要做的是架设电线连接这些村庄，使得所有村庄都直接或间接的与发电站相通。<br>　　小明测量了所有村庄的位置（坐标）和高度，如果要连接两个村庄，小明需要花费两个村庄之间的坐标距离加上高度差的平方，形式化描述为坐标为 $(x_1, y_1)$ 高度为$ h_1$ 的村庄与坐标为 $(x_2, y_2)$ 高度为 $h_2$ 的村庄之间连接的费用为<br>　　$sqrt((x_1-x_2)* (x_1-x_2)+(y_1-y_2)* (y_1-y_2))+(h_1-h_2)*(h_1-h_2)$。<br>　　在上式中 sqrt 表示取括号内的平方根。请注意括号的位置，高度的计算方式与横纵坐标的计算方式不同。<br>　　由于经费有限，请帮助小明计算他至少要花费多少费用才能使这 n 个村庄都通电。</p>
<a id="more"></a>

<p>输入格式</p>
<p>　　输入的第一行包含一个整数 n ，表示村庄的数量。<br>　　接下来 n 行，每个三个整数 x, y, h，分别表示一个村庄的横、纵坐标和高度，其中第一个村庄可以建立发电站。</p>
<p>输出格式</p>
<p>　　输出一行，包含一个实数，四舍五入保留 2 位小数，表示答案。</p>
<p>样例输入</p>
<p>4<br>1 1 3<br>9 9 7<br>8 8 6<br>4 5 4</p>
<p>样例输出</p>
<p>17.41</p>
<p>评测用例规模与约定</p>
<p>　　对于 30% 的评测用例，1 &lt;= n &lt;= 10；<br>　　对于 60% 的评测用例，1 &lt;= n &lt;= 100；<br>　　对于所有评测用例，1 &lt;= n &lt;= 1000，0 &lt;= x, y, h &lt;= 10000。</p>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>求以1节点为起点，连接其他节点的最短距离。就是求出以1为起点的最小生成树。</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>可以用Kruskal算法和Prim算法。</p>
<p>(还好今年没报蓝桥，啥也不会。。。去了就是送钱了</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p>1、Prim算法(写起来比较简单)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">int</span> y;</span><br><span class="line">	<span class="keyword">int</span> h;</span><br><span class="line">&#125;a[<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">double</span> d[<span class="number">1010</span>][<span class="number">1010</span>], dis[<span class="number">1010</span>], ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n, mark[<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;<span class="comment">//求出当前的最短距离的节点</span></span><br><span class="line">			<span class="keyword">if</span> (!mark[j] &amp;&amp; (t == <span class="number">0</span> || dis[j] &lt; dis[t])) </span><br><span class="line">				t = j;</span><br><span class="line">		&#125;</span><br><span class="line">		mark[t] = <span class="number">1</span>;</span><br><span class="line">		ans += dis[t];<span class="comment">//更新答案</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(!mark[j])</span><br><span class="line">			dis[j] = <span class="built_in">min</span>(dis[j], d[t][j]);<span class="comment">//更新距离</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">			d[i][j] = INF;</span><br><span class="line">		dis[i] = INF;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a[i].x &gt;&gt; a[i].y &gt;&gt; a[i].h;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">			d[i][j] = d[j][i] = <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(a[i].x - a[j].x, <span class="number">2</span>) + <span class="built_in">pow</span>(a[i].y - a[j].y, <span class="number">2</span>)) + <span class="built_in">pow</span>(a[i].h - a[j].h, <span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	prim();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、Kruskal(并查集)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e9</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">int</span> y;</span><br><span class="line">	<span class="keyword">int</span> h;</span><br><span class="line">&#125;a[<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">int</span> y;</span><br><span class="line">	<span class="keyword">double</span> d;</span><br><span class="line">&#125;D;</span><br><span class="line"><span class="keyword">double</span>  ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n, f[<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(D a, D b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.d &lt; b.d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> son = root, t;</span><br><span class="line">	<span class="keyword">while</span> (root != f[root])	root = f[root];</span><br><span class="line">	<span class="keyword">while</span> (son != root) &#123;</span><br><span class="line">		t = f[son];</span><br><span class="line">		f[son] = root;</span><br><span class="line">		son = t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> node1, <span class="keyword">int</span> node2, <span class="keyword">double</span> num)</span> </span>&#123;</span><br><span class="line">	node1 = search(node1);</span><br><span class="line">	node2 = search(node2);</span><br><span class="line">	<span class="keyword">if</span> (node1 != node2) &#123;<span class="comment">//如果不成环就加上这条边</span></span><br><span class="line">		f[node1] = node2;</span><br><span class="line">		ans += num;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	D d[<span class="number">1010</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) 	f[i] = i;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a[i].x &gt;&gt; a[i].y &gt;&gt; a[i].h;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">			d[cnt].d = <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(a[i].x - a[j].x, <span class="number">2</span>) + <span class="built_in">pow</span>(a[i].y - a[j].y, <span class="number">2</span>)) + <span class="built_in">pow</span>(a[i].h - a[j].h, <span class="number">2</span>);</span><br><span class="line">			d[cnt].x = i;</span><br><span class="line">			d[cnt++].y = j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(d, d + cnt, cmp);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) join(d[i].x, d[i].y, d[i].d);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
        <category>蓝桥</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>西邮第五届ACM-ICPC B 烦人的依赖 题解</title>
    <url>/2020/07/08/%E8%A5%BF%E9%82%AE%E7%AC%AC%E4%BA%94%E5%B1%8AACM-ICPC-B-%E7%83%A6%E4%BA%BA%E7%9A%84%E4%BE%9D%E8%B5%96-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://ac.nowcoder.com/acm/contest/5678/B" target="_blank" rel="noopener">题目大意</a></h3><p>给你n个字符串，给你其中m个的优先关系，需要先输出字典序小的字符串，问你能否成立，能的话输出序列。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>由于需要按照字典序的顺序来输出，所以需要使用优先队列（小顶堆）。</p>
<p>告诉了我们每对的优先关系，可以构造出一个图，用拓扑排序来判断是否有环来判断是否成立。</p>
<p>字符串与位置的对应关系需要使用unorder_map，map会超时。。</p>
<p>用一个vector来记录路径。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;M;</span><br><span class="line">priority_queue&lt;<span class="built_in">string</span>,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;,greater&lt;<span class="built_in">string</span>&gt;&gt; q;</span><br><span class="line"><span class="built_in">string</span> ss[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;Map[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; p;</span><br><span class="line"><span class="keyword">int</span> in[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t,c = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n, m;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">		<span class="built_in">string</span> s1,s2;</span><br><span class="line">		<span class="built_in">memset</span>(in, <span class="number">0</span>, <span class="keyword">sizeof</span>(in));</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			Map[i].<span class="built_in">clear</span>();</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; ss[i];</span><br><span class="line">		&#125;</span><br><span class="line">		sort(ss + <span class="number">1</span>, ss + <span class="number">1</span> + n);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			M[ss[i]] = i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">			<span class="keyword">int</span> n1 = M[s1], n2 = M[s2];</span><br><span class="line">			Map[n1].push_back(n2);</span><br><span class="line">			in[n2]++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!in[M[ss[i]]])	q.push(ss[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> f = M[q.top()];</span><br><span class="line">			p.push_back(ss[f]);</span><br><span class="line">			q.pop();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> x = Map[f].<span class="built_in">begin</span>(); x != Map[f].<span class="built_in">end</span>(); x++) &#123;</span><br><span class="line">				in[*x]--;</span><br><span class="line">				<span class="keyword">if</span>(!in[*x])	q.push(ss[*x]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; c++ &lt;&lt; <span class="string">":"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">if</span> (p.<span class="built_in">size</span>() == n) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> x : p)<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Impossible"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		p.<span class="built_in">clear</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
        <tag>优先队列</tag>
      </tags>
  </entry>
</search>

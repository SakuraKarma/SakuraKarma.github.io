<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2020ICPC南京站E-Evil Coordinate 题解</title>
    <url>/2021/01/13/2020ICPC%E5%8D%97%E4%BA%AC%E7%AB%99E-Evil-Coordinate-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://ac.nowcoder.com/acm/contest/10272/E" target="_blank" rel="noopener">题目大意</a></h3><p>从$(0,0)$出发，给你一个代表方向的字符串，给你一个点$(x,y)$，这个点不能走，问能否在不经过这个点的情况下到达终点。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>当初打比赛的时候，说实话，真没啥思路。</p>
<p>打完之后看题解，这思路。。</p>
<p>绝了。</p>
<p>完全想不到只要全排列UDLR就可以了。</p>
<p>因为全枚举上下左右已经足够避免重复了，如果所有情况都没办法避免，那就是不行的。</p>
<p>只能说这思路太妙了。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for (int i=a;i&lt;=n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,n) for (int i=a;i&gt;=n;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bg begin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rbg rbegin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ed end</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dbg(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">"==="</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> u, d, l, r;</span><br><span class="line"><span class="keyword">int</span> per[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> dx, dy;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)	ans *= a;</span><br><span class="line">		a &lt;&lt;= <span class="number">1</span>, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (x == dx) &amp;&amp; (y == dy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x, y; x = y = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">	rep(i, <span class="number">0</span>, <span class="number">3</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (per[i] == <span class="number">1</span>) &#123;</span><br><span class="line">			rep(i, <span class="number">1</span>, u) &#123;</span><br><span class="line">				y++; flag = <span class="built_in">exit</span>(x, y);</span><br><span class="line">				<span class="keyword">if</span> (flag)	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (per[i] == <span class="number">2</span>) &#123;</span><br><span class="line">			rep(i, <span class="number">1</span>, d) &#123;</span><br><span class="line">				y--; flag = <span class="built_in">exit</span>(x, y);</span><br><span class="line">				<span class="keyword">if</span> (flag)	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (per[i] == <span class="number">3</span>) &#123;</span><br><span class="line">			rep(i, <span class="number">1</span>, l) &#123;</span><br><span class="line">				x--; flag = <span class="built_in">exit</span>(x, y);</span><br><span class="line">				<span class="keyword">if</span> (flag)	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			rep(i, <span class="number">1</span>, r) &#123;</span><br><span class="line">				x++; flag = <span class="built_in">exit</span>(x, y);</span><br><span class="line">				<span class="keyword">if</span> (flag)	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\in.txt", "r", stdin);</span></span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\out.txt", "w+", stdout);</span></span><br><span class="line">	<span class="keyword">int</span> t; <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		u = d = l = r = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; dx &gt;&gt; dy;</span><br><span class="line">		<span class="built_in">string</span> s; <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">		<span class="keyword">int</span> len = s.length();</span><br><span class="line">		rep(i,<span class="number">0</span>,len<span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (s[i] == <span class="string">'U'</span>) u++;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'D'</span>) d++;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'L'</span>) l++;</span><br><span class="line">			<span class="keyword">else</span> r++;</span><br><span class="line">		&#125;</span><br><span class="line">		per[<span class="number">0</span>] = <span class="number">1</span>, per[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">		per[<span class="number">2</span>] = <span class="number">3</span>, per[<span class="number">3</span>] = <span class="number">4</span>;</span><br><span class="line">		<span class="keyword">if</span> (!dx &amp;&amp; !dy) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"Impossible"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (check()) &#123;</span><br><span class="line">				flag = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">while</span> (next_permutation(per, per + <span class="number">4</span>));</span><br><span class="line">		<span class="keyword">if</span> (flag) &#123;</span><br><span class="line">			rep(i, <span class="number">0</span>, <span class="number">3</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (per[i] == <span class="number">1</span>)</span><br><span class="line">					rep(i, <span class="number">1</span>, u)	<span class="built_in">cout</span> &lt;&lt; <span class="string">'U'</span>;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (per[i] == <span class="number">2</span>)</span><br><span class="line">					rep(i, <span class="number">1</span>, d)	<span class="built_in">cout</span> &lt;&lt; <span class="string">'D'</span>;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (per[i] == <span class="number">3</span>)</span><br><span class="line">					rep(i, <span class="number">1</span>, l)	<span class="built_in">cout</span> &lt;&lt; <span class="string">'L'</span>;</span><br><span class="line">				<span class="keyword">else</span> rep(i, <span class="number">1</span>, r)	<span class="built_in">cout</span> &lt;&lt; <span class="string">'R'</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"Impossible"</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>2020年“联想杯” A Archmage 题解</title>
    <url>/2020/07/08/2020-%E5%B9%B4-%E2%80%9C%E8%81%94%E6%83%B3%E6%9D%AF%E2%80%9D-A-Archmage-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://acm.ecnu.edu.cn/contest/270/problem/A/" target="_blank" rel="noopener">题目大意</a></h3><p>你有初始的n点法力值，有m个回合，在回合初，你可以花费x点法力值，制造一个水球，在回合结束时，你可以回复y点法力值。问最多水球数量。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>哇。。这个是真的卡了我好久。。</p>
<p>一直没想到正确的思路。。</p>
<p>结果一看题解。。</p>
<p>我们首先可以分两种情况。</p>
<p>1、$y\ge x$</p>
<p>显然，每回合回复的法力值都足够消耗，答案显然是m。</p>
<p>2、$y&lt;x$</p>
<p>这里很难想。</p>
<p>我刚开始想的时候，是想到答案为$(n+m*y)/x$,后来发现不对，就没往这方面想了。</p>
<p>结果是$(n+(m-1)*y)/x$。</p>
<p>对于每一回合来说，我上回合回复的y，我之后的回合总能够使用到，但是我第m回合的时候，回复的法力值相当于是无用的，所以实际上增加的应该是$(m-1)*y$。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		ll n, m, x, y;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		<span class="keyword">if</span> (y &gt;= x) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ll ans = (n + (m - <span class="number">1</span>) * y) / x;</span><br><span class="line">		ans = <span class="built_in">min</span>(ans, m);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>2020ICPC南京站F-Fireworks 题解</title>
    <url>/2020/12/23/2020ICPC%E5%8D%97%E4%BA%AC%E7%AB%99F-Fireworks-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://ac.nowcoder.com/acm/contest/10272/F" target="_blank" rel="noopener">题目大意</a></h3><p>你可以花费n点时间去制作一个烟花，可以任意做多少个，每个烟花有$p\times 10^{-4}$的概率是一个完美的烟花，你需要</p>
<p>花费m点时间去把你制作的所有烟花点燃，问至少点燃一个完美的烟花的最小期望值是多少。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>赛时这个题目连怎么求期望都没想到。。</p>
<p>更不用说想到三分了。</p>
<p>说实话，还是感觉自己太菜了，签到题都写了那么久，同题数我们都已经垫底了。。</p>
<p>需要提高思维速度了。</p>
<p>而且像概率这种东西，我们队没有会的。。</p>
<p>这就属于知识盲区了。</p>
<p>寒假要加油学了。</p>
<p>这题对于不同的一次制作数量k，可以得到一个关于k的期望函数$\Large \frac{1}{1-(1-p)^k}$,那么就可以得到花费的期望函数$\Large \frac {n*k+m}{1-(1-p)^k}$。</p>
<p>由打表或者求导可以看出是一个单峰的凹函数，用三分求峰值即可。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for (int i=a;i&lt;=n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,n) for (int i=a;i&gt;=n;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bg begin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rbg rbegin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ed end</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dbg(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">"==="</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line">ll n, m;</span><br><span class="line"><span class="keyword">double</span> p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">qpow</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">double</span> ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)	ans *= a;</span><br><span class="line">		a *= a, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">double</span> ans = <span class="number">1.0</span> * (n * k + m) / (<span class="number">1.0</span> - qpow(<span class="number">1.0</span> - p, k));</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//ios::sync_with_stdio(0);</span></span><br><span class="line">	<span class="comment">//cin.tie(0); cout.tie(0);</span></span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\in.txt", "r", stdin);</span></span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\out.txt", "w+", stdout);</span></span><br><span class="line">	<span class="keyword">int</span> t; <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; p;</span><br><span class="line">		<span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">1e9</span>;</span><br><span class="line">		p /= <span class="number">1e4</span>;</span><br><span class="line">		<span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">			<span class="keyword">int</span> mid1 = l + (r - l) / <span class="number">3</span>, mid2 = r - (r - l) / <span class="number">3</span>;</span><br><span class="line">			<span class="keyword">if</span> (cal(mid1) &lt; cal(mid2))	r = mid2 - <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> l = mid1 + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%.10f\n"</span>, cal(l));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>概率</tag>
        <tag>期望</tag>
        <tag>三分</tag>
      </tags>
  </entry>
  <entry>
    <title>2020ICPC上海站M-Gitignore 题解</title>
    <url>/2020/12/22/2020ICPC%E4%B8%8A%E6%B5%B7%E7%AB%99M-Gitignore-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://ac.nowcoder.com/acm/contest/9925/M" target="_blank" rel="noopener">题目大意</a></h3><p> 给你n个需要删除的文件和m个不能删除的文件，分别告诉你这些文件的路径，当某个文件夹中没有不能删除的文件时，你可以删除这一整个文件夹，问最少需要删除几次。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们打了南京，铁了，难受啊。。</p>
<p>寒假要好好学了，不然牌都拿不到就退役了。。</p>
<p>当时这场打完之后我们复现了一场，然后这题没写出来。</p>
<p>打这一场的他们说就是一个搜索。</p>
<p>后面看了下别人的代码，这个应该就是一个思维题。</p>
<p>不过这个思路特别妙。</p>
<p>把有不能删的文件夹标记一下，如果遇到了不能删的文件夹就继续往下走。</p>
<p>如果碰到了能删的，就直接删了这个文件夹，并标记一下。</p>
<p>如果碰到了删过的文件夹，就ans–。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for (int i=a;i&lt;=n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,n) for (int i=a;i&gt;=n;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bg begin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rbg rbegin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ed end</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dbg(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">"==="</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; M;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)	ans *= a;</span><br><span class="line">		a &lt;&lt;= <span class="number">1</span>, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\in.txt", "r", stdin);</span></span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\out.txt", "w+", stdout);</span></span><br><span class="line">	<span class="keyword">int</span> t; <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		M.<span class="built_in">clear</span>(); v.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">int</span> n, m; <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">		<span class="built_in">string</span> s;</span><br><span class="line">		rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">			v.push_back(s);</span><br><span class="line">		&#125;</span><br><span class="line">		rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">			<span class="keyword">int</span> l = s.length();</span><br><span class="line">			<span class="built_in">string</span> t;</span><br><span class="line">			rep(j, <span class="number">0</span>, l - <span class="number">1</span>) &#123;</span><br><span class="line">				t += s[j];</span><br><span class="line">				<span class="keyword">if</span> (s[j] == <span class="string">'/'</span>)	M[t] = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> ans = n;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> x : v) &#123;</span><br><span class="line">			<span class="keyword">int</span> l = x.length();</span><br><span class="line">			<span class="built_in">string</span> t;</span><br><span class="line">			rep(i, <span class="number">0</span>, l - <span class="number">1</span>) &#123;</span><br><span class="line">				t += x[i];</span><br><span class="line">				<span class="keyword">if</span> (x[i] == <span class="string">'/'</span>) &#123;</span><br><span class="line">					<span class="keyword">if</span> (M[t] != <span class="number">1</span>) &#123;</span><br><span class="line">						<span class="keyword">if</span> (M[t] != <span class="number">2</span>) M[t] = <span class="number">2</span>;</span><br><span class="line">						<span class="keyword">else</span> &#123;</span><br><span class="line">							ans--; <span class="keyword">break</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>2020年浙江理工大学校赛同步赛 E yesky wine展销会</title>
    <url>/2020/07/08/2020%E5%B9%B4%E6%B5%99%E6%B1%9F%E7%90%86%E5%B7%A5%E5%A4%A7%E5%AD%A6%E6%A0%A1%E8%B5%9B%E5%90%8C%E6%AD%A5%E8%B5%9B-E-yesky-wine%E5%B1%95%E9%94%80%E4%BC%9A/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你n个坐标，你需要让每个坐标的差值为k，你可以移动这些坐标来完成这个目的，请问最少移动多少。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>看到这个题目的时候。。真的没啥思路。</p>
<p>还好大佬抬我一手。。感谢大佬</p>
<p>当时还有点理解的，后来比赛完之后有人问了我一下这个题目。</p>
<p>被考住了。。还是感觉不够理解，为啥一定是最优解。</p>
<p>后面看到别人博客，自己试着推了一下，感觉自己差不多懂了。</p>
<p>假设，我们先以$k,2k,3k,…,nk$为基准，想要每个点都是这个状态，于是我们可以用每个点的坐标做差，得到每个点的差值$x_i-i*k$，求之前需要对坐标数组进行排序。</p>
<p>得到每个点的差值之后，我们肯定是不能就是按照$k,2k,3k,…,nk$这个基准来，因为我们可以让这些k相关点进行一个移动，至少可以移动到一个点上来，我们就假设以这个点展开，那么这个点就叫做基准点。</p>
<p>那么我们就需要找到这个基准点。</p>
<p>假设存在一些差值，分别是$…,a-bk,c-dk,e-fk,g-hk,i-jk,…$，都是按照大小进行排序的。</p>
<p>假设我们取$c-dk$这个差值，也就是以c为基准点，将其他所有的值，进行偏移$c-dk$。</p>
<p>加入c在dk的左边，即差值为负数，即整体向右移，或者说k相关点向左移。</p>
<p>对于他左边的差值，都是减小$c-dk$的，（这个差值都是取绝对值的，以后省略）。</p>
<p>对于他右边的差值，如果差值小于0的话，也是减小$c-dk$的，如果差值大于0的话，就是增加$c-dk$的。</p>
<p>因为差值减小是取绝对值的，所以可能减小也可能增大，因为他左边的点的差值的绝对值都比他大，所以他左边的点都是差值减小的，他右边的点的差值的绝对值都比他要小，实际上是差值增大的，但是差值增大就是绝对增大的。</p>
<p>如果在c在dk的右边同理，可以得到差不多的结果。</p>
<p>假设c在dk左边，令$c-dk$为$Δx$,他左边的点个数记为$n_1$，右边小于0的点个数记为$n_2$，其他的点个数记为$n_3$。</p>
<p>那么便可以得到减小的值是$n_1\times Δx$，增加的值是$n_2\times (Δx-|x_i|)+n_3\timesΔx$。</p>
<p>假设原本的所有差值的和为s，那么最后得到的结果便是$s+|n_1-(n_2+n_3)|\times Δx-n_2\times |x_i|$。</p>
<p>其中$|n_1-(n_2+n_3) |$就是基准点左右两边的数的个数的差值。</p>
<p>显然，当基准点为中位数的时候，差值为0或者为1。</p>
<p>由于当你取的基准点偏离中位数的时候，显然第一个式子会比第二个式子要大得多，只要我们将增加的值取得最小，也就是最优解了。</p>
<p>当c在dk右边的时候可以得到相类似的结果。</p>
<p>所以我们只需要取中位数即可。</p>
<p>最后的结果就是每个点的差值减去中位数的差值然后取绝对值相加即可。</p>
<p>（可能证明不是很严谨。。但是我也尽力了。</p>
<p>贴一个我认为比较严谨的数学方式证明的链接。</p>
<p><a href="https://blog.csdn.net/zstuyyyyccccbbbb/article/details/106876910" target="_blank" rel="noopener">链接</a>。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">6</span>;</span><br><span class="line">ll x[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> n, k;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; x[i];</span><br><span class="line">	&#125;</span><br><span class="line">	sort(x + <span class="number">1</span>, x + <span class="number">1</span> + n);</span><br><span class="line">	<span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		x[i] -= i * k;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(x + <span class="number">1</span>, x + <span class="number">1</span> + n);</span><br><span class="line">	ll t = x[(n + <span class="number">1</span>) / <span class="number">2</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)	ans += <span class="built_in">abs</span>(x[i] - t);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>ACWing-344 观光之旅 题解</title>
    <url>/2020/07/08/ACWing-344-%E8%A7%82%E5%85%89%E4%B9%8B%E6%97%85-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://www.acwing.com/problem/content/description/346/" target="_blank" rel="noopener">题目大意</a></h3><p>给定一张无向图，求图中一个至少包含3个点的环，环上的节点不重复，并且环上的边的长度之和最小。</p>
<p>你需要输出最小环的方案，若最小环不唯一，输出任意一个均可。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>模板题。。</p>
<p>比最小环模板多了一个记录路径的过程。</p>
<p>（没啥好说的，还是看代码吧。。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e8</span>;</span><br><span class="line"><span class="keyword">int</span> Map[<span class="number">200</span>][<span class="number">200</span>], dis[<span class="number">200</span>][<span class="number">200</span>],ne[<span class="number">200</span>][<span class="number">200</span>],n,path[<span class="number">200</span>];</span><br><span class="line"><span class="comment">//ne[i][j]表示从i到j的经过的第一个节点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> mins = INF,cnt;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; k; j++) &#123;</span><br><span class="line">				<span class="keyword">int</span> tmp = dis[i][j] + Map[i][k] + Map[j][k];</span><br><span class="line">				<span class="keyword">if</span> (tmp &lt; mins) &#123;</span><br><span class="line">					mins = tmp;</span><br><span class="line">					cnt = <span class="number">0</span>;</span><br><span class="line">					<span class="keyword">int</span> p = i;</span><br><span class="line">					<span class="keyword">while</span> (p != j) &#123;<span class="comment">//输出从i到j的路径</span></span><br><span class="line">						path[cnt++] = p;</span><br><span class="line">						p = ne[p][j];</span><br><span class="line">					&#125;</span><br><span class="line">					path[cnt++] = j;</span><br><span class="line">					path[cnt++] = k;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">				<span class="keyword">int</span> tmp = dis[i][k] + dis[k][j];</span><br><span class="line">				<span class="keyword">if</span> (tmp &lt; dis[i][j]) &#123;</span><br><span class="line">					dis[i][j] = tmp;</span><br><span class="line">					ne[i][j] = ne[i][k];<span class="comment">//记录路径</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (mins == INF)	<span class="built_in">cout</span> &lt;&lt; <span class="string">"No solution."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">			<span class="built_in">string</span> s = i == cnt - <span class="number">1</span> ? <span class="string">"\n"</span> : <span class="string">" "</span>;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; path[i] &lt;&lt; s;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">			Map[i][j] = dis[i][j] = INF,ne[i][j] = j;</span><br><span class="line">		Map[i][i] = dis[i][i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> x, y, l;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; l;</span><br><span class="line">		Map[x][y] = dis[x][y] = Map[y][x] = dis[y][x] = l;</span><br><span class="line">	&#125;</span><br><span class="line">	Floyd();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Floyd</tag>
        <tag>最小环</tag>
        <tag>记录路径</tag>
      </tags>
  </entry>
  <entry>
    <title>ACWing-1432 棋盘挑战 题解</title>
    <url>/2021/02/01/ACWing-1432-%E6%A3%8B%E7%9B%98%E6%8C%91%E6%88%98-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://www.acwing.com/problem/content/1434/" target="_blank" rel="noopener">题目大意</a></h3><p>n皇后问题。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>我的搜索还是写的稀烂。</p>
<p>这倒是我第一次写八皇后，搜索倒不难，难点在对角线怎么表示。</p>
<p>看了y总的视频，学到了。</p>
<p>一条对角线是$y = x+b$，一条是$y = -x + b$。</p>
<p>可以用截距来表示，那么一个就是$y-x$，一个就是$y+x$。</p>
<p>因为$y-x$可以是负数，所以需要加上一个n，$y-x+n$。</p>
<p>其他的就是标准的dfs了。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for (int i=a;i&lt;=n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,n) for (int i=a;i&gt;=n;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bg begin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rbg rbegin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ed end</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dbg(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">"==="</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> visx[<span class="number">20</span>], visd[<span class="number">40</span>], visrd[<span class="number">40</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line"><span class="built_in">string</span> t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!visx[i] &amp;&amp; !visrd[y - i + n] &amp;&amp; !visd[i + y]) &#123;</span><br><span class="line">			visx[i] = visrd[y - i + n] = visd[i + y] = <span class="number">1</span>;</span><br><span class="line">			t += i + <span class="string">'0'</span>;</span><br><span class="line">			<span class="keyword">if</span> (y == n) ans.push_back(t);</span><br><span class="line">			<span class="keyword">else</span> dfs(y + <span class="number">1</span>);</span><br><span class="line">			t.erase(t.<span class="built_in">end</span>() - <span class="number">1</span>);</span><br><span class="line">			visx[i] = visrd[y - i + n] = visd[i + y] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b, ll mod)</span> </span>&#123;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)	ans = (ans * a) % mod;</span><br><span class="line">		a = (a * a) % mod, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\in.txt", "r", stdin);</span></span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\out.txt", "w+", stdout);</span></span><br><span class="line">	dfs(<span class="number">1</span>);</span><br><span class="line">	sort(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">	rep(i, <span class="number">0</span>, <span class="number">2</span>) &#123;</span><br><span class="line">		rep(j, <span class="number">0</span>, n - <span class="number">1</span>)	<span class="built_in">cout</span> &lt;&lt; ans[i][j] - <span class="string">'0'</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>AC自动机</title>
    <url>/2020/07/08/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
    <content><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>AC自动机，正如他的名字，能够让你自动AC（误</p>
<p>其实是一个匹配字符串的算法。</p>
<p>简单来说，就是在trie树上用KMP的思想。</p>
<p>（当然，你也可以理解为就是用了KMP。。</p>
<p>因为本来trie树是可以用来匹配字符串的，但是因为匹配失败的时候都需要从头开始，会导致浪费了很多时间，加大了时间复杂度。</p>
<p>所以，就提出来了AC自动机。</p>
<p>原理就是和KMP的next数组类似，使用一个fail数组，来记录匹配失败之后，需要回溯到哪个地方。</p>
<p>这样便能减少很多复杂度。</p>
<p>时间复杂度为$O(n)$($n$为文本长度)</p>
<p>（AC自动机怎么不能帮助我自动AC啊。。</p>
<a id="more"></a>

<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><h4 id="1、建树"><a href="#1、建树" class="headerlink" title="1、建树"></a>1、建树</h4><p>这里和trie树是一样的，我就不多赘述了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> trie[N][<span class="number">30</span>], cnt[N], fail[N], tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = s.length(),now = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> id = s[i] - <span class="string">'a'</span>;</span><br><span class="line">		<span class="keyword">if</span> (!trie[now][id])	trie[now][id] = ++tot;</span><br><span class="line">		now = trie[now][id];</span><br><span class="line">	&#125;</span><br><span class="line">	cnt[now]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、获取fail数组"><a href="#2、获取fail数组" class="headerlink" title="2、获取fail数组"></a>2、获取fail数组</h4><p>这个fail数组就类似于KMP中的next数组，当你匹配失败的时候，能通过回溯的方式，来回到fail所指向的那个节点，通过这样的方式来减小时间复杂度。</p>
<p>而fail指针指向是与当前字符相同并且该字符所在的前缀构成现在字符的最长后缀。</p>
<p>用bfs的方式来获取fail数组。</p>
<p>这里以$aba,abcd,bca,bad$为例。</p>
<p><img src="https://ae01.alicdn.com/kf/H0eb39b789d55425faba9342f12634e3ex.jpg" alt=""></p>
<p>首先，第一层的节点的fail肯定是指向根节点的。</p>
<p>此外，对于遍历的节点来说。</p>
<p>如果遍历的节点存在指向的子节点的话，那么该子节点的fail为他的父节点的fail的节点指向相同节点的节点。</p>
<p>（有点绕啊。。不懂的看看代码吧。</p>
<p>如果遍历的节点不存在指向的子节点的话，那么令该节点指向他的fail的节点指向的相同节点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Getfail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)<span class="comment">//第一层的直接指向根节点</span></span><br><span class="line">		<span class="keyword">if</span>(trie[<span class="number">0</span>][i])</span><br><span class="line">		fail[trie[<span class="number">0</span>][i]] = <span class="number">0</span>, q.push(trie[<span class="number">0</span>][i]);</span><br><span class="line">	<span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> now = q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (trie[now][i]) &#123;<span class="comment">//如果存在指向的子节点</span></span><br><span class="line">				fail[trie[now][i]] = trie[fail[now]][i];</span><br><span class="line">                <span class="comment">//他子节点的fail为他的父节点，也就是now的fail的指向相同节点的节点</span></span><br><span class="line">				q.push(trie[now][i]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> trie[now][i] = trie[fail[now]][i];</span><br><span class="line">            <span class="comment">//如果不存在指向的子节点</span></span><br><span class="line">            <span class="comment">//那么直接让该节点指向他自己fail的节点的指向的相同节点</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、查询"><a href="#3、查询" class="headerlink" title="3、查询"></a>3、查询</h4><p>从根节点开始一步步进行匹配。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quiry</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> now = <span class="number">0</span>, ans = <span class="number">0</span>, len = s.length();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> id = s[i] - <span class="string">'a'</span>;</span><br><span class="line">		now = trie[now][id];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = now; j &amp;&amp; cnt[j] != <span class="number">-1</span>; j = fail[j])<span class="comment">//从now开始一直向下寻找，直到匹配失败（指向根节点或者已经被匹配过）</span></span><br><span class="line">			ans += cnt[j], cnt[j] = <span class="number">-1</span>;<span class="comment">//将匹配过的节点进行标记</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4、last优化"><a href="#4、last优化" class="headerlink" title="4、last优化"></a>4、last优化</h4><p>不会last优化。。</p>
<p>这边记录一下，了解<a href="https://www.cnblogs.com/sclbgw7/p/9875671.html" target="_blank" rel="noopener">点击这里</a>。</p>
<h3 id="典型例题"><a href="#典型例题" class="headerlink" title="典型例题"></a>典型例题</h3><p>1、<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2222" target="_blank" rel="noopener">HDU-2222 Keywords Search</a></p>
<h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h4><p>给你一串字符串，问你里面最多有多少个关键词。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>AC自动机模板题。</p>
<p>就是卡cin，cout。</p>
<p>真的难受。</p>
<h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> trie[N][<span class="number">30</span>], cnt[N], fail[N], tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = s.length(),now = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> id = s[i] - <span class="string">'a'</span>;</span><br><span class="line">		<span class="keyword">if</span> (!trie[now][id])	trie[now][id] = ++tot;</span><br><span class="line">		now = trie[now][id];</span><br><span class="line">	&#125;</span><br><span class="line">	cnt[now]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Getfail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">		<span class="keyword">if</span>(trie[<span class="number">0</span>][i])</span><br><span class="line">		fail[trie[<span class="number">0</span>][i]] = <span class="number">0</span>, q.push(trie[<span class="number">0</span>][i]);</span><br><span class="line">	<span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> now = q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (trie[now][i]) &#123;</span><br><span class="line">				fail[trie[now][i]] = trie[fail[now]][i];</span><br><span class="line">				q.push(trie[now][i]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> trie[now][i] = trie[fail[now]][i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quiry</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> now = <span class="number">0</span>, ans = <span class="number">0</span>, len = s.length();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> id = s[i] - <span class="string">'a'</span>;</span><br><span class="line">		now = trie[now][id];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = now; j &amp;&amp; cnt[j] != <span class="number">-1</span>; j = fail[j])</span><br><span class="line">			ans += cnt[j], cnt[j] = <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		tot = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(trie, <span class="number">0</span>, <span class="keyword">sizeof</span>(trie));</span><br><span class="line">		<span class="built_in">memset</span>(fail, <span class="number">0</span>, <span class="keyword">sizeof</span>(fail));</span><br><span class="line">		<span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">		<span class="built_in">string</span> s;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">			insert(s);</span><br><span class="line">		&#125;</span><br><span class="line">		Getfail();</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; quiry(s) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2896" target="_blank" rel="noopener">HDU-2896 病毒侵袭</a></p>
<h4 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h4><p>给你多个字符串，每个字符串按$1-M$编号，输入多个病毒特征码，按照$1-N$，问你每个字符串中存在的特征码。</p>
<h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>这个题目究极恶心，卡内存卡到吐。。</p>
<p>题目要求每个字符都是ASCII码可见字符（不包括回车）。</p>
<p>所以最大的就是$127-32=95$,我刚开始以为要开到128。</p>
<p>其他的就是模板了。</p>
<p>还要注意病毒的编号是从小到大输出的，可以用优先队列。</p>
<h4 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">7e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> trie[N][<span class="number">100</span>], cnt[N], fail[N], tot,flag[N];</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> s,<span class="keyword">int</span> g)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = s.length(), now = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> id = s[i] - <span class="string">' '</span>;</span><br><span class="line">		<span class="keyword">if</span> (!trie[now][id])	trie[now][id] = ++tot;</span><br><span class="line">		now = trie[now][id];</span><br><span class="line">	&#125;</span><br><span class="line">	cnt[now] = g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Getfail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">96</span>; i++)</span><br><span class="line">		<span class="keyword">if</span> (trie[<span class="number">0</span>][i])</span><br><span class="line">			fail[trie[<span class="number">0</span>][i]] = <span class="number">0</span>, q.push(trie[<span class="number">0</span>][i]);</span><br><span class="line">	<span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> now = q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">96</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (trie[now][i]) &#123;</span><br><span class="line">				fail[trie[now][i]] = trie[fail[now]][i];</span><br><span class="line">				q.push(trie[now][i]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> trie[now][i] = trie[fail[now]][i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quiry</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> now = <span class="number">0</span>, len = s.length();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> id = s[i] - <span class="string">' '</span>;</span><br><span class="line">		now = trie[now][id];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = now; j &amp;&amp; flag[j] != <span class="number">-1</span>; j = fail[j]) &#123;</span><br><span class="line">			<span class="keyword">if</span> (cnt[j] &gt; <span class="number">0</span>)	ans.push(cnt[j]);</span><br><span class="line">			flag[j] = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> n,m;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n) &#123;</span><br><span class="line">		tot = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(trie, <span class="number">0</span>, <span class="keyword">sizeof</span>(trie));</span><br><span class="line">		<span class="built_in">memset</span>(fail, <span class="number">0</span>, <span class="keyword">sizeof</span>(fail));</span><br><span class="line">		<span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">		<span class="built_in">memset</span>(flag, <span class="number">0</span>, <span class="keyword">sizeof</span>(flag));</span><br><span class="line">		<span class="built_in">string</span> s;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">			insert(s, i);</span><br><span class="line">		&#125;</span><br><span class="line">		Getfail();</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">		<span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">			quiry(s);</span><br><span class="line">			<span class="keyword">if</span> (!ans.empty()) &#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"web "</span> &lt;&lt; i &lt;&lt; <span class="string">":"</span>;</span><br><span class="line">				<span class="keyword">while</span> (!ans.empty()) &#123;</span><br><span class="line">					<span class="built_in">cout</span> &lt;&lt;<span class="string">" "</span>&lt;&lt; ans.top();</span><br><span class="line">					ans.pop();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">				c++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">memset</span>(flag, <span class="number">0</span>, <span class="keyword">sizeof</span>(flag));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"total: "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>51NOD-1625 夹克爷发红包 题解</title>
    <url>/2020/07/08/51NOD-1625-%E5%A4%B9%E5%85%8B%E7%88%B7%E5%8F%91%E7%BA%A2%E5%8C%85-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://www.51nod.com/Challenge/Problem.html#problemId=1625" target="_blank" rel="noopener">题目大意</a></h3><p>给你一个$n*m$的矩阵，矩阵中存在初始值，现在你可以进行$k$次操作，将任意一行或者一列每一个数都赋值为$x$，问你矩阵最大和为多少。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>刚开始我是想，用贪心，计算出每一行，每一列的修改值，然后从小到大的修改。</p>
<p>想了想，发现很麻烦，而且还不一定正确。。</p>
<p>直接懵了，想了好久，没想出来。。</p>
<p>去看了题解。。</p>
<p>用状态压缩的方法，枚举每一行的情况，因为n的范围不大，最大也就是$2^{10}$。</p>
<p>状压，用我自己的话来说，就是用一个数的二进制来表示每一位的情况，所以说其实是相当暴力的。</p>
<p>可以用这一位为1来表示选，为0的表示不选。</p>
<p>因为行确定了，而列与列之间不会互相影响，这样只需要枚举出最大值即可。</p>
<p>（这方法好妙啊。。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll num[<span class="number">20</span>][<span class="number">300</span>],dx[<span class="number">300</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m, x, k;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; k;</span><br><span class="line">	ll sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)	</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; num[i][j],sum+=num[i][j];</span><br><span class="line">	&#125;</span><br><span class="line">	ll ans = sum;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++) &#123;</span><br><span class="line">		ll res, cnt;</span><br><span class="line">		res = cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i &amp; (<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))) &#123;<span class="comment">//判断第j位是不是为1</span></span><br><span class="line">				cnt++;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> g = <span class="number">1</span>; g &lt;= m; g++)	res += x - num[j][g];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (cnt &gt; k)	<span class="keyword">continue</span>;</span><br><span class="line">		cnt = k - cnt;</span><br><span class="line">		<span class="built_in">memset</span>(dx, <span class="number">0</span>, <span class="keyword">sizeof</span>(dx));</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> g = <span class="number">1</span>; g &lt;= n; g++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (i &amp; (<span class="number">1</span> &lt;&lt; (g - <span class="number">1</span>)))	<span class="keyword">continue</span>;</span><br><span class="line">				dx[j] += x - num[g][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		sort(dx + <span class="number">1</span>, dx + <span class="number">1</span> + m, greater&lt;ll&gt;());<span class="comment">//十年OI一场空，不开longlong见祖宗，我又忘了。。</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m &amp;&amp; j &lt;= cnt; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (dx[j] &lt; <span class="number">0</span>)	<span class="keyword">break</span>;</span><br><span class="line">			res += dx[j];</span><br><span class="line">		&#125;</span><br><span class="line">		ans = <span class="built_in">max</span>(ans, sum + res);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>状压</tag>
        <tag>暴力</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>ACWing-680 剪绳子 题解</title>
    <url>/2021/01/18/ACWing-680-%E5%89%AA%E7%BB%B3%E5%AD%90-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://www.acwing.com/problem/content/682/" target="_blank" rel="noopener">题目大意</a></h3><p>有N根绳子，第i根绳子长度为$Li$，现在需要M根等长的绳子，你可以对N根绳子进行任意裁剪（不能拼接），请你帮忙计算出这M根绳子最长的长度是多少。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>刚开始看到这个题意，想着应该是二分。</p>
<p>但是这个题目是浮点二分。</p>
<p>好久没写过浮点二分了，刚好补个博客。</p>
<p>浮点二分模板</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (r - l &gt; 精度) &#123;</span><br><span class="line">	<span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;<span class="comment">//或者可以写成mid=l+(r-l)/2，防止溢出</span></span><br><span class="line">	<span class="keyword">if</span> (check(mid) &gt;= m) l = mid;</span><br><span class="line">	<span class="keyword">else</span> r = mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.2lf"</span>, l);</span><br></pre></td></tr></table></figure>

<p>顺便补个整数二分模板（y总的）</p>
<p>模板一：</p>
<p>当我们将区间$[l, r]$划分成$[l, mid]$和$[mid + 1, r]$时，其更新操作是$r = mid$或者$l = mid + 1$，计算$mid$时不需要加1。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (l &lt; r)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (check(mid)) r = mid;</span><br><span class="line">	<span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; l &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>模板二：</p>
<p>当我们将区间$[l, r]$划分成$[l, mid - 1]$和$[mid, r]$时，其更新操作是$r = mid - 1$或者$l = mid;$，此时为了防止死循环，计算$mid$时需要加1。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (l &lt; r)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (check(mid)) r = mid;</span><br><span class="line">	<span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; l &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for (int i=a;i&lt;=n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,n) for (int i=a;i&gt;=n;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bg begin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rbg rbegin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ed end</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dbg(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">"==="</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> num[N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)	ans *= a;</span><br><span class="line">		a &lt;&lt;= <span class="number">1</span>, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">		ans += num[i] * <span class="number">1.0</span> / x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\in.txt", "r", stdin);</span></span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\out.txt", "w+", stdout);</span></span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	rep(i, <span class="number">1</span>, n) <span class="built_in">cin</span> &gt;&gt; num[i];</span><br><span class="line">	<span class="keyword">double</span> l = <span class="number">0</span>, r = <span class="number">1e9</span>;</span><br><span class="line">	<span class="keyword">while</span> (r - l &gt; <span class="number">1e-3</span>) &#123;</span><br><span class="line">		<span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (cal(mid) &gt;= m) l = mid;</span><br><span class="line">		<span class="keyword">else</span> r = mid;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%.2lf"</span>, l);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>ACWing-126 最大的和 题解</title>
    <url>/2021/02/09/ACWing-126-%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://www.acwing.com/problem/content/128/" target="_blank" rel="noopener">题目大意</a></h3><p>给定一个包含整数的二维矩阵，子矩形是位于整个阵列内的任何大小为1 * 1或更大的连续子阵列。</p>
<p>矩形的总和是该矩形中所有元素的总和。</p>
<p>在这个问题中，具有最大和的子矩形被称为最大子矩形。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这个题目有个类似的，但是是<a href="https://www.acwing.com/problem/content/50/" target="_blank" rel="noopener">一维</a>的。</p>
<p>懂了那个之后，这个题就会做了。</p>
<p>枚举上下界，然后对于其中的数据，做类似一维的即可。</p>
<p>对于每一个点，判断前一个点之前的最大和是否为正数，然后正数才相加。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for (int i=a;i&lt;=n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,n) for (int i=a;i&gt;=n;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bg begin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rbg rbegin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ed end</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dbg(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">"==="</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b, ll mod)</span> </span>&#123;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)	ans = (ans * a) % mod;</span><br><span class="line">		a = (a * a) % mod, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\in.txt", "r", stdin);</span></span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\out.txt", "w+", stdout);</span></span><br><span class="line">	<span class="keyword">int</span> n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">		rep(j, <span class="number">1</span>, n) &#123;</span><br><span class="line">			<span class="keyword">int</span> x; <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">			num[i][j] = num[i - <span class="number">1</span>][j] + x;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">-1e9</span>;</span><br><span class="line">	rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">		rep(j, i, n) &#123;</span><br><span class="line">			<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">			rep(k, <span class="number">1</span>, n) &#123;</span><br><span class="line">				<span class="keyword">int</span> t = num[j][k] - num[i - <span class="number">1</span>][k];</span><br><span class="line">				res = <span class="built_in">max</span>(res, <span class="number">0</span>) + t;</span><br><span class="line">				ans = <span class="built_in">max</span>(ans, res);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-1132C Painting the Fence 题解</title>
    <url>/2020/09/27/CF-1132C-Painting-the-Fence-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforces.com/problemset/problem/1132/C" target="_blank" rel="noopener">题目大意</a></h3><p>有p个人，每个人负责一个区域，让你从中选p-2个人，求覆盖的最大面积。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>因为数据不大，刚开始就想着是用直接暴力。</p>
<p>但是纯粹的暴力的话，复杂度是$O(n^3)$。</p>
<p>估计铁超时。</p>
<p>后面就想着用差分吧，但是每次都需要一个前缀和。</p>
<p>也觉得会超时，后面想了好久，没想到什么好的方法。</p>
<p>卡了我好久，没办法了，看题解去了。</p>
<p>发现与我的思路就差了一个前缀和。</p>
<p>通过这个前缀和，把$O(n^3)$优化到$O(n^2)$了。</p>
<p>真的没想到用前缀和来维护区间中这次去掉人之后所会减少的面积。</p>
<p>太难想了。。。</p>
<p>整体思路就是先统计每一个位置上被覆盖了多少次，然后反向思维，枚举掉需要去掉的两个人。</p>
<p>在枚举第一个人的时候，需要修改统计的数组，最后需要记得还原，同时dp出前缀和数组，这个数组表示从1~i中有多少是覆盖次数为1的，也就是这次会去掉的个数。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> l[<span class="number">5050</span>], r[<span class="number">5050</span>], cnt[<span class="number">5050</span>], flag[<span class="number">5050</span>], fs[<span class="number">5050</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, q; <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; q;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; l[i] &gt;&gt; r[i];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = l[i]; j &lt;= r[i]; j++) &#123;</span><br><span class="line">			cnt[j]++;</span><br><span class="line">			<span class="keyword">if</span> (cnt[j] &amp;&amp; !flag[j])	flag[j] = <span class="number">1</span>, sum++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = l[i]; j &lt;= r[i]; j++) &#123;</span><br><span class="line">			cnt[j]--;</span><br><span class="line">			<span class="keyword">if</span> (!cnt[j])	s++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (cnt[j]==<span class="number">1</span>)	fs[j] = fs[j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> fs[j] = fs[j - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = <span class="number">1e9</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt;= q; j++) &#123;</span><br><span class="line">			m = <span class="built_in">min</span>(m, fs[r[j]] - fs[l[j] - <span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = l[i]; j &lt;= r[i]; j++) cnt[j]++;</span><br><span class="line">		ans = <span class="built_in">max</span>(ans, sum - s - m);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>暴力</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-1000C Covered Points Count 题解</title>
    <url>/2020/07/08/CF-1000C-Covered-Points-Count-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://codeforces.com/problemset/problem/1000/C" target="_blank" rel="noopener">题目大意</a></h3><p>在一个数轴上，给你n个线段，每个线段可以相交，重合，问你被覆盖$1$~$n$次的点每个有多少。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>上次上课讲到了离散化差分，去搜了搜，就找到了这个题目。。</p>
<p>因为线段的端点数值很大，$1·10^{18}$，但是n的数据范围不大。</p>
<p>所以可以使用离散化，</p>
<p>那么差分之后的数组代表着一段的覆盖次数，这一段的长度为相邻两点的差。</p>
<p>线段可以重合，需要去重。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">500</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	ll x, y;</span><br><span class="line">&#125;p[N];</span><br><span class="line">ll pos[N &lt;&lt; <span class="number">1</span>], num[N &lt;&lt; <span class="number">1</span>], cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> n,c = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; p[i].x &gt;&gt; p[i].y;</span><br><span class="line">		pos[++c] = p[i].x,pos[++c] = p[i].y + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(pos + <span class="number">1</span>, pos + <span class="number">1</span> + c);</span><br><span class="line">	<span class="keyword">int</span> l = unique(pos + <span class="number">1</span>, pos + <span class="number">1</span> + c) - pos - <span class="number">1</span>;<span class="comment">//去重</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = lower_bound(pos + <span class="number">1</span>, pos + <span class="number">1</span> + l, p[i].x) - pos;<span class="comment">//注意，lower_bound的返回值为与传入的数组起始地址的相对位置，所以num是从1开始的。</span></span><br><span class="line">		<span class="keyword">int</span> y = lower_bound(pos + <span class="number">1</span>, pos + <span class="number">1</span> + l, p[i].y + <span class="number">1</span>) - pos;<span class="comment">//查找y+1</span></span><br><span class="line">		num[x]++, num[y]--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; l; i++) &#123;</span><br><span class="line">		num[i] += num[i - <span class="number">1</span>];<span class="comment">//这一段的覆盖数量</span></span><br><span class="line">		cnt[num[i]] += pos[i+<span class="number">1</span>]-pos[i];<span class="comment">//这一段的长度</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)	<span class="built_in">printf</span>(<span class="string">"%lld%c"</span>, cnt[i], i == n ? <span class="string">'\n'</span> : <span class="string">' '</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>差分</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title>A*算法</title>
    <url>/2020/07/08/Astar%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>把Dijkstra算法（靠近初始点的结点）和BFS算法（靠近目标点的结点）的信息块结合起来。在讨论A*的标准术语中，g(n)表示从初始结点到任意结点n的代价，h(n)表示从结点n到目标点的启发式评估代价（heuristic estimated cost）。</p>
<p>当从初始点向目标点移动时，A*权衡这两者。每次进行主循环时，它检查f(n)最小的结点n，其中$f(n) = g(n) + h(n)$。</p>
<p>A*主要作为寻路算法作用在游戏上。</p>
<a id="more"></a>

<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>到这里，学长给我们上的课就到此结束了。</p>
<p>说实话，还是挺感谢学长们的，讲了好多东西啊。</p>
<p>还需要继续去掌握和巩固。</p>
<p>但是这个A*是真的难懂。</p>
<p>用我的理解来说，就是正向的一个Dijkstra与反向的BFS（最佳优先搜索）结合，用f(n)作为优先级来判断。</p>
<p>这个BFS存在一个启发式函数，这个启发式函数就是从节点n开始到目标节点的最小值。</p>
<p>这个算法网上没啥题，也没啥教程，听学长讲了一遍。</p>
<p>说实话，还是相当懵。</p>
<p>这里就贴一个详解吧。</p>
<p><a href="https://blog.csdn.net/coutamg/article/details/53923717" target="_blank" rel="noopener">A*</a>。</p>
<h3 id="典型例题"><a href="#典型例题" class="headerlink" title="典型例题"></a>典型例题</h3><p><a href="http://poj.org/problem?id=2449" target="_blank" rel="noopener">POJ-2449 Remmarguts’ Date</a></p>
<h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h4><p>给你一个n个节点，m条边的图，给你起点s，和终点t，求第k短路。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>网上说貌似可以用spfa，我用的A*。</p>
<p>先反向跑一遍Dijkstra，得出距离，也就是$h(n)$。</p>
<p>然后以$f(n)$为优先级跑一遍Dijkstra。</p>
<p>应该算是典型A*模板题。</p>
<h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>, M = <span class="number">1e5</span> + <span class="number">5</span>, INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> cnt1, cnt2, head1[N], head2[N], vis[N], dis[N], n, k;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> to, val, next;</span><br><span class="line">&#125;Map1[M],Map2[M];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> u, c;</span><br><span class="line">	node(<span class="keyword">int</span> a = <span class="number">0</span>,<span class="keyword">int</span> b = <span class="number">0</span>):u(a),c(b)&#123;&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> node&amp; a) <span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> c &gt; a.c;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">heap</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> g, h, num;</span><br><span class="line">	heap(<span class="keyword">int</span> a = <span class="number">0</span>,<span class="keyword">int</span> b = <span class="number">0</span>,<span class="keyword">int</span> c = <span class="number">0</span>):g(a),h(b),num(c)&#123;&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> heap&amp; a) <span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (g + h) &gt; (a.g + a.h);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build1</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">	Map1[++cnt1].to = v, Map1[cnt1].val = val;</span><br><span class="line">	Map1[cnt1].next = head1[u], head1[u] = cnt1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">	Map2[++cnt2].to = v, Map2[cnt2].val = val;</span><br><span class="line">	Map2[cnt2].next = head2[u], head2[u] = cnt2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dis[i] = INF;</span><br><span class="line">	dis[s] = <span class="number">0</span>;</span><br><span class="line">	priority_queue&lt;node&gt;q2;</span><br><span class="line">	q2.push(node(s, <span class="number">0</span>));</span><br><span class="line">	node t;</span><br><span class="line">	<span class="keyword">while</span> (!q2.empty()) &#123;</span><br><span class="line">		t = q2.top();</span><br><span class="line">		q2.pop();</span><br><span class="line">		<span class="keyword">int</span> u = t.u;</span><br><span class="line">		<span class="keyword">if</span> (vis[u])	<span class="keyword">continue</span>;</span><br><span class="line">		vis[u] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = head2[u]; ~i; i = Map2[i].next) &#123;</span><br><span class="line">			<span class="keyword">int</span> x = Map2[i].to;</span><br><span class="line">			<span class="keyword">int</span> c = Map2[i].val;</span><br><span class="line">			<span class="keyword">if</span> (!vis[x]&amp;&amp;dis[x] &gt; dis[u] + c)</span><br><span class="line">				dis[x] = dis[u] + c, q2.push(node(x, dis[x]));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Astar</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">	Dijkstra(e);</span><br><span class="line">	priority_queue&lt;heap&gt;q1;</span><br><span class="line">	q1.push(heap(<span class="number">0</span>, dis[s], s));</span><br><span class="line">	heap t;</span><br><span class="line">	<span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!q1.empty()) &#123;</span><br><span class="line">		t = q1.top();</span><br><span class="line">		q1.pop();</span><br><span class="line">		<span class="keyword">if</span> (t.num == e) &#123;</span><br><span class="line">			c++;</span><br><span class="line">			<span class="keyword">if</span> (c &gt;= k) &#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; t.g &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = head1[t.num]; ~i; i = Map1[i].next) &#123;</span><br><span class="line">			<span class="keyword">int</span> x = Map1[i].to;</span><br><span class="line">			<span class="keyword">int</span> c = Map1[i].val;</span><br><span class="line">			q1.push(heap(t.g + c, dis[x], x));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="built_in">memset</span>(head1, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head1));</span><br><span class="line">	<span class="built_in">memset</span>(head2, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head2));</span><br><span class="line">	cnt1 = cnt2 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> l, r, c;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r &gt;&gt; c;</span><br><span class="line">		build1(l, r, c),build2(r, l, c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> s, t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; s &gt;&gt; t &gt;&gt; k;</span><br><span class="line">	<span class="keyword">if</span> (s == t)	k++;</span><br><span class="line">	Astar(s, t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>A*</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-1217D Coloring Edges 题解</title>
    <url>/2020/07/08/CF-1217D-Coloring-Edges-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://codeforces.com/problemset/problem/1217/D" target="_blank" rel="noopener">题目大意</a></h3><p>小明是一个国王，他的国家有n个城市。</p>
<p>现在小明想为这n个城市制造m条路径（路径都是有向的），现在小明有k种不同种类的材料，可以用来制造路径。</p>
<p>无自环，无重复边。</p>
<p>在制造路径的时候，小明不想看到一个环的路径都是由一种材料制造成的，这样小明就会生气。</p>
<p>现在问你这个k最小值应该是多少呢。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>（来补一下题解</p>
<p>题目的要求是每个环的路径的材料不能完全相同，那么我们可以将不是环的点的k值赋为1，在环中的最多也是2。</p>
<p>那么存在环k最大为2，不存在则k为1。</p>
<p>首先，我们可以使用拓扑排序来判环。</p>
<p>（写这题之前完全就没听过。。</p>
<p>判断是否有环之后，如果不存在环，则每个点都为1。</p>
<p>如果存在环，那么可以用dfs来在环内赋值。</p>
<p>有一个很巧妙的方法来赋值。</p>
<p>（我也是看到了别人的题解才想到的。。</p>
<p>就是如果这个点比其他点大，就赋为1，否则赋为2。</p>
<p>显然，在一个环中，是不可能出现单增或者单降的，所以整个环必然不可能是同一种颜色。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;Map[<span class="number">5050</span>];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q, p;</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">5050</span>][<span class="number">5050</span>];</span><br><span class="line"><span class="keyword">int</span> l[<span class="number">5050</span>], r[<span class="number">5050</span>], in[<span class="number">5050</span>], mark[<span class="number">5050</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; l[i] &gt;&gt; r[i];</span><br><span class="line">		Map[l[i]].push_back(r[i]);</span><br><span class="line">		in[r[i]]++;</span><br><span class="line">		ans[l[i]][r[i]] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;<span class="comment">//拓扑排序</span></span><br><span class="line">		<span class="keyword">if</span> (!in[i]) &#123;</span><br><span class="line">			mark[i] = <span class="number">1</span>;</span><br><span class="line">			q.push(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> node = q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		p.push(node);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> it = Map[node].<span class="built_in">begin</span>(); it != Map[node].<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">			in[*it]--;</span><br><span class="line">			<span class="keyword">if</span> (!in[*it]) &#123;</span><br><span class="line">				mark[*it] = <span class="number">1</span>;</span><br><span class="line">				q.push(*it);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (p.<span class="built_in">size</span>() == n)	flag = <span class="number">1</span>;<span class="comment">//判断是否有环</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!mark[i]) &#123;</span><br><span class="line">				q.push(i);				</span><br><span class="line">				<span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">					<span class="keyword">int</span> m = q.front();</span><br><span class="line">					q.pop();</span><br><span class="line">					mark[m] = <span class="number">1</span>;</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">auto</span> it = Map[m].<span class="built_in">begin</span>(); it != Map[m].<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">						<span class="keyword">if</span> (m &gt; (*it))	ans[m][*it] = <span class="number">1</span>;</span><br><span class="line">						<span class="keyword">else</span> ans[m][*it] = <span class="number">2</span>;</span><br><span class="line">						<span class="keyword">if</span>(!mark[*it])	q.push(*it);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (flag)	<span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans[l[i]][r[i]];</span><br><span class="line">		<span class="keyword">if</span> (i != m - <span class="number">1</span>)	<span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-1169B Pairs 题解</title>
    <url>/2020/07/08/CF-1169B-Pairs-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://vjudge.net/problem/CodeForces-1169B/origin" target="_blank" rel="noopener">题目大意</a></h3><p>给定你m对整数对（x[i],y[i]），请问是否存在x和y，使得n对中每一对中至少有一个数是x和y之中的一个。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>（我是真的蠢啊。。。</p>
<p>每一对都要是x，y中的一个，那么x就只有两种情况，第一对其中的任意一个。</p>
<p>这个需要只需要枚举y两次即可。</p>
<p>（就是这个卡了我好久。。</p>
<p>只要x加上y减去y和x一起出现的次数加起来等于m即可。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"><span class="built_in">map</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; M;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">int</span> a, b;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">	cnt[a]++;</span><br><span class="line">	cnt[b]++;</span><br><span class="line">	M[make_pair(a, b)]++;</span><br><span class="line">	M[make_pair(b, a)]++;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> x, y;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		cnt[x]++;</span><br><span class="line">        cnt[y]++;</span><br><span class="line">		M[make_pair(x,y)]++;</span><br><span class="line">		M[make_pair(y,x)]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i != a&amp;&amp; cnt[i] + cnt[a] - M[make_pair(i, a)] == m) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i!=b&amp;&amp;cnt[i] + cnt[b] - M[make_pair(i, b)] == m) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-1060D  Social Circles 题解</title>
    <url>/2020/07/08/CF-1060D-Social-Circles-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://codeforces.com/problemset/problem/1060/D" target="_blank" rel="noopener">题目大意</a></h3><p>有n个客人，他们围绕着1个或者多个圈而坐。每一个人都需要左边空li个人，右边ri个人（空位可以重叠）。请问最少需要多少个座位。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>（想了好久没想到思路，后来发现是理解错了。。</p>
<p>其实就是蠢了。想着左边连左边了。</p>
<p>看了题解，发现就是贪心。。</p>
<p>每个人就是左边连着另外一个人的右边，那么我只要让他们的差值最小即可，这样浪费的座位数越小，也就是按照大小排序之后，取左边和右边中的最大值+1，便是两人之间一条边的最小贡献。（如果选出的恰好是同一个人的时候，就是一个人单独一个圈，也是相同的方法）</p>
<p>（zbw大佬说的对，贪心确实要多做题。。</p>
<p>第一次做到这种贪心。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> l[N], r[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)	<span class="built_in">cin</span> &gt;&gt; l[i] &gt;&gt; r[i];</span><br><span class="line">	sort(l + <span class="number">1</span>, l + <span class="number">1</span> + n);</span><br><span class="line">	sort(r + <span class="number">1</span>, r + <span class="number">1</span> + n);</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;<span class="comment">//注意数据范围</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		ans += <span class="built_in">max</span>(l[i], r[i]) + <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-1195C Basketball Exercise 题解</title>
    <url>/2020/07/08/CF-1195C-Basketball-Exercise-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你两个序列a和b，你可以从中任意选取其中的数字，但是你不能取相邻的两个数字，问所取的数字的最大和。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>典型的线性DP题。。</p>
<p>但是写的DP题少啊。。DP还是相当苦手。</p>
<p>需要多刷点题。。不过最近没啥时间，要期末考了。。等暑假吧。</p>
<p>我们可以用$dp[i][j][h]$来表示第i列到序列最右端的最大和，其中j代表第几行，h代表这一位取或者而不取。</p>
<p>那么我们便可以得到状态转移方程。</p>
<p>假如我第i位不取，那么无论是第1行，还是第2行，都是右边所有情况的最大值，因为我这一位不取，不会影响到后面的取舍，所以只需要取其中的最大值即可。</p>
<p>$dp[i][1][0] = dp[i][2][0] = max(max(dp[i + 1][1][0], dp[i + 1][1][1]), max(dp[i + 1][2][0], dp[i + 1][2][1]))$</p>
<p>假如我第i位取，那么对第一行来说，我不能取第一行后面相邻的那个数，但是对第二行的取舍是没有影响的，所以取这三种情况的最大值并且加上该位上的值即可。</p>
<p>$dp[i][1][1] = max(dp[i + 1][1][0], max(dp[i + 1][2][0], dp[i + 1][2][1])) + num[i][1]$</p>
<p>对于第二行来说是类似的，我不能取第二行后面相邻的那个数，但是对第一行的取舍是没有没有影响的，所以也是取这三种情况的最大值加上该位上的值即可。</p>
<p>$dp[i][2][1] = max(dp[i + 1][2][0], max(dp[i + 1][1][0], dp[i + 1][1][1])) + num[i][2]$</p>
<p>但是需要注意，我们需要从右边开始倒序转移，因为重叠的子问题都是与右边的情况有关的。</p>
<p>最后的结果就是第一列中第一行取或不取，第二行取或不取四种情况中的最大值。</p>
<p>即$max(max(dp[1][1][0], dp[1][1][1]), max(dp[1][2][0], dp[1][2][1]))$。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll dp[N][<span class="number">3</span>][<span class="number">2</span>],num[N][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)	<span class="built_in">cin</span>&gt;&gt;num[i][<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)	<span class="built_in">cin</span>&gt;&gt;num[i][<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">		dp[i][<span class="number">1</span>][<span class="number">0</span>] = dp[i][<span class="number">2</span>][<span class="number">0</span>] = <span class="built_in">max</span>(<span class="built_in">max</span>(dp[i + <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>], dp[i + <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>]), <span class="built_in">max</span>(dp[i + <span class="number">1</span>][<span class="number">2</span>][<span class="number">0</span>], dp[i + <span class="number">1</span>][<span class="number">2</span>][<span class="number">1</span>]));<span class="comment">//这一位没取的情况</span></span><br><span class="line">		dp[i][<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>], <span class="built_in">max</span>(dp[i + <span class="number">1</span>][<span class="number">2</span>][<span class="number">0</span>], dp[i + <span class="number">1</span>][<span class="number">2</span>][<span class="number">1</span>])) + num[i][<span class="number">1</span>];<span class="comment">//这一位第1行取了的情况</span></span><br><span class="line">		dp[i][<span class="number">2</span>][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][<span class="number">2</span>][<span class="number">0</span>], <span class="built_in">max</span>(dp[i + <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>], dp[i + <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>])) + num[i][<span class="number">2</span>];<span class="comment">//这一位第2行取了的情况</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">max</span>(<span class="built_in">max</span>(dp[<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>], dp[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>]), <span class="built_in">max</span>(dp[<span class="number">1</span>][<span class="number">2</span>][<span class="number">0</span>], dp[<span class="number">1</span>][<span class="number">2</span>][<span class="number">1</span>])) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线性DP</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-1243B2 Character Swap (Hard Version) 题解</title>
    <url>/2020/07/13/CF-1234B2-Character-Swap-(Hard-Version)-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforces.com/contest/1243/problem/B2" target="_blank" rel="noopener">题目大意</a></h3><p>给你一个长度为n的两个字符串，你可以交换$s1[i],s2[j]$，最多可以交换2n次，需要你判断能否使两字符串相同，能的话输出交换顺序。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>说实话这个题目还真不难。。</p>
<p>但是我就是没想到啊啊啊。</p>
<p>感觉自己脑袋越来越不好用了。</p>
<p>这个字符串长度不长，可以直接用模拟。</p>
<p>模拟两个字符串的交换过程，并且记录交换顺序即可。</p>
<p>当他们两个位置相同的时候不需要去交换。</p>
<p>然后交换的时候分两种情况，具体看代码吧。</p>
<p>顺便记录一下，了解到了一个新算法：sunday算法，用来匹配字符串的，有机会之后再补。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;v;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		<span class="keyword">char</span> s1[<span class="number">100</span>], s2[<span class="number">100</span>];</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; s1+<span class="number">1</span> &gt;&gt; s2+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> cnt[<span class="number">200</span>];</span><br><span class="line">		<span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">		v.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			cnt[s1[i]]++, cnt[s2[i]]++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="string">'a'</span>; i &lt;= <span class="string">'z'</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (cnt[i] &amp; <span class="number">1</span>) &#123;</span><br><span class="line">				flag = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"No"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Yes"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (s1[i] != s2[i]) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">					<span class="keyword">if</span> (s1[i] == s1[j]) &#123;</span><br><span class="line">						swap(s2[i], s1[j]);</span><br><span class="line">						v.push_back(make_pair(j, i));</span><br><span class="line">						c++;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (s1[i] == s2[j]) &#123;</span><br><span class="line">						swap(s1[i + <span class="number">1</span>], s2[j]);</span><br><span class="line">						v.push_back(make_pair(i+<span class="number">1</span>, j));</span><br><span class="line">						swap(s2[i], s1[i + <span class="number">1</span>]);</span><br><span class="line">						v.push_back(make_pair(i+<span class="number">1</span>, i));</span><br><span class="line">						c += <span class="number">2</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> x : v) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; x.first &lt;&lt; <span class="string">' '</span> &lt;&lt; x.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-1197C Array Splitting 题解</title>
    <url>/2020/11/27/CF-1197C-Array-Splitting-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforces.com/problemset/problem/1197/C" target="_blank" rel="noopener">题目大意</a></h3><p>一个长度为n单调递增的序列（即ai&lt;=ai+1),将其分为k段，让每一段的极差（最大值-最小值）的和最小，求这个最小的极差的和（每段长度至少为1，当长度为1时，其极差为0）。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>首先我们可以把每个数看成一段，这样贡献是0。</p>
<p>但是题目需要我们分成k段，这时候，每一段都可以选择向左扩张或者向右扩张。</p>
<p>这时候，可以用一个差分数组记录相邻两个数的差值。</p>
<p>把他们按照从小到大的顺序排序，向左向右的贡献刚好就是相邻的差值。</p>
<p>所以只需要从头开始选n-k个即可。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for (ll i=a;i&lt;=n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,n) for (ll i=n;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(x,y) make_pair(x,y)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bg begin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rbg rbegin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ed end</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dbg(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">"==="</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> num[N],dif[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)	ans *= a;</span><br><span class="line">		a &lt;&lt;= <span class="number">1</span>, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\in.txt", "r", stdin);</span></span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\out.txt", "w+", stdout);</span></span><br><span class="line">	<span class="keyword">int</span> n, k; <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	rep(i, <span class="number">1</span>, n)	<span class="built_in">cin</span> &gt;&gt; num[i];</span><br><span class="line">	<span class="keyword">if</span> (k == n)	<span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		rep(i, <span class="number">2</span>, n) &#123;</span><br><span class="line">			dif[i] = num[i] - num[i - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		sort(dif + <span class="number">2</span>, dif + <span class="number">1</span> + n);</span><br><span class="line">		<span class="keyword">int</span> cnt = n - k;</span><br><span class="line">		ll sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n &amp;&amp; cnt; cnt--, i++) &#123;</span><br><span class="line">			sum += dif[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-1206D Shortest Cycle 题解</title>
    <url>/2020/07/08/CF-1206D-Shortest-Cycle-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforces.com/problemset/problem/1206/D" target="_blank" rel="noopener">题目大意</a></h3><p>给你n个数，如果两个数之间进行与运算的结果不为0，即ai&amp;aj≠0，则说明两点之间有一条无向边。问最小环的权值，如果不存在则输出-1。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>（比赛的时候看到这个题目完全是懵的。。直接跳了</p>
<p>学长简直是魔鬼啊。。又考了一个我不会的。</p>
<p>自闭ing。。</p>
<p>也好，又学了点新知识。</p>
<p>首先用Floyd是可以求最小环的，但是n的范围为1e5，不可能就这么简单的用FLoyd。</p>
<p>（其实之前完全不知道Floyd可以求最小环。。</p>
<p>a的范围为1e18，也就是说最多二进制60位。</p>
<p>由题意可得，ai&amp;aj≠0就可以确定一条无向边，所以对于非0点来说，只要有一位同时存在三个1，那么那三个点就必然成环。即n&gt;(60+60)，就必定最小环是3。</p>
<p>如果n&lt;120，就可以直接建图，用<a href="https://www.cnblogs.com/FuTaimeng/p/5610406.html" target="_blank" rel="noopener">Floyd求最小环</a>。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>,INF = <span class="number">1e8</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[N];</span><br><span class="line"><span class="keyword">int</span> Map[<span class="number">200</span>][<span class="number">200</span>], dis[<span class="number">200</span>][<span class="number">200</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,cnt = <span class="number">0</span> ;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> m;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">		<span class="keyword">if</span> (m)	a[cnt++] = m;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (cnt &gt; <span class="number">120</span>) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="number">3</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) &#123;<span class="comment">//初始化</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++)</span><br><span class="line">			Map[i][j] = dis[i][j] = INF;</span><br><span class="line">		Map[i][i] = dis[i][i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; cnt; j++)</span><br><span class="line">			<span class="keyword">if</span> ((a[i] &amp; a[j]) != <span class="number">0</span>)</span><br><span class="line">				Map[i][j] = Map[j][i] = dis[j][i] = dis[i][j] = <span class="number">1</span>;<span class="comment">//建图</span></span><br><span class="line">	<span class="keyword">int</span> m = INF;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cnt; k++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;<span class="comment">//求最小环</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; k; j++) &#123;</span><br><span class="line">				m = <span class="built_in">min</span>(m, Map[i][k] + Map[k][j] + dis[i][j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) &#123;<span class="comment">//正常的Floyd</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++) &#123;</span><br><span class="line">				dis[i][j] = <span class="built_in">min</span>(dis[i][j], dis[i][k] + dis[k][j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (m == INF)	<span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; m;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Floyd</tag>
        <tag>最小环</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-120E Put Knight! 题解</title>
    <url>/2020/11/08/CF-120E-Put-Knight!-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforces.com/problemset/problem/120/E" target="_blank" rel="noopener">题目大意</a></h3><p>有一个n*n大小的棋盘，两人轮流在棋盘里放象棋里的马，要求两马之间不能互相攻击，谁先不能放谁就输，问后手是否能赢。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这题是典型的对称博弈。</p>
<p>简单来说，对称博弈就是对方做啥你做啥，与如何做没有关系。</p>
<p>这题就是，当n为奇数的时候，先手先占据棋盘中心，之后后手下啥位置，先手只需要下与他中心对称的位置即可，能保证后手能下到的地方，先手都能下到，先手必赢。</p>
<p>同理，当n为偶数的时候，先手相当于为奇数时的后手，后手必赢。</p>
<p>其实还有一个对称博弈的题，<a href="https://vjudge.net/problem/HDU-3951/origin" target="_blank" rel="noopener">HDU - 3951</a>，思想是差不多的，就不写题解了。（懒。。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for (ll i=a;i&lt;=n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,n) for (ll i=n;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(x,y) make_pair(x,y)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bg begin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rbg rbegin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ed end</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dbg(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">"==="</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)	ans *= a;</span><br><span class="line">		a &lt;&lt;= <span class="number">1</span>, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"input.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>); </span><br><span class="line">	freopen(<span class="string">"output.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\in.txt", "r", stdin);</span></span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\out.txt", "w+", stdout);</span></span><br><span class="line">	<span class="keyword">int</span> t; <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		<span class="keyword">if</span> (n &amp; <span class="number">1</span>)	<span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-1221C Perfect Team 题解</title>
    <url>/2020/07/08/CF-1221C-Perfect-Team-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://vjudge.net/problem/CodeForces-1221C/origin" target="_blank" rel="noopener">题目大意</a></h3><p>每个队伍有三种人，c，m，x，其中x可以被c和m替换掉，输入c，m，x的数量，请问最多可以组成多少个队伍。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>（其实我只想到的贪心的思路，TLE了。。</p>
<p>这里说一下吧。</p>
<p>首先优先使用c，m，x，直到其中有一个为0的时候结束。如果c或者m为0，则无法继续。</p>
<p>如果x为0，则可以使用c或者m代替x，用数量多的来代替，使c，m趋向相同。</p>
<p>思路大概就是这样，但是超时了。。</p>
<p>（不甘心啊啊</p>
<p>看了看别人大佬的思路。。</p>
<p>最大团队数为$min(c,m)$，此外，构成团队还需要3个人，所以还要和$(c+m+x)/3$取$min$。</p>
<p>这个还能推广到n个人的队伍。</p>
<p>$min(min(c,m),(c+m+x)/3)$</p>
<p>我的思路是，先用完x之后，剩下的就是$(c+m)/3$了，加上即可。</p>
<p>（其实是一样的。。这个除以3就是取平均的意思</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> a, b, c;</span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">		<span class="keyword">int</span> m = <span class="built_in">min</span>(a, b);</span><br><span class="line">		m = <span class="built_in">min</span>(m, c);</span><br><span class="line">		a -= m, b -= m, c -= m, ans += m;</span><br><span class="line">		<span class="keyword">if</span> (!a || !b) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (a &gt;= <span class="number">2</span> * b)	ans += b;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (b &gt;= <span class="number">2</span> * a)	ans += a;</span><br><span class="line">			<span class="keyword">else</span> ans += (a + b) / <span class="number">3</span>;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>公式</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-12D Ball 题解</title>
    <url>/2020/07/08/CF-12D-Ball-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://codeforces.com/problemset/problem/12/D" target="_blank" rel="noopener">题目大意</a></h3><p>在一个舞会上，有许多女士，每个女士有三个属性（b，l，r），如果存在其他的女士三项属性都比她要高，那么她就会选择死亡。问有多少人会死亡。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这道题可以用线段树做，也可以用树状数组做，线段树太麻烦了，还是用树状数组写吧。</p>
<p>（其实是线段树不是很会。。</p>
<p>按b的大小来从大到小排序，记录下位置，以这个位置为下标构造树状数组，数组的值为r的值。</p>
<p>然后按l的大小从大到小排序，就已经确定一个属性了。</p>
<p>剩下的关系就通过线段树来判断。</p>
<p>（网上好像还有用map做的，代码不长，看不懂。。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> t[N], n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">it</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	<span class="keyword">int</span> l;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">&#125;p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">//单点修改</span></span><br><span class="line">	<span class="keyword">while</span> (pos &lt;= n) &#123;</span><br><span class="line">		t[pos] = <span class="built_in">max</span>(t[pos], x);</span><br><span class="line">		pos += lowbit(pos);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findmax</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;<span class="comment">//查询区间的最大值</span></span><br><span class="line">	<span class="keyword">int</span> M = <span class="number">-1e9</span>;</span><br><span class="line">	<span class="keyword">while</span> (pos) &#123;</span><br><span class="line">		M = <span class="built_in">max</span>(M, t[pos]);</span><br><span class="line">		pos -= lowbit(pos);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> M;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp1</span><span class="params">(it a, it b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.b &gt; b.b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp2</span><span class="params">(it a, it b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.l &gt; b.l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p[i].b);</span><br><span class="line">    <span class="comment">/*使用cin超时了，如果要使用cin的话</span></span><br><span class="line"><span class="comment">    需要加上ios::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">	cin.tie(0);</span></span><br><span class="line"><span class="comment">	cout.tie(0);</span></span><br><span class="line"><span class="comment">	换行用"\n"</span></span><br><span class="line"><span class="comment">	原理自行百度*/</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p[i].l);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p[i].r);</span><br><span class="line">	sort(p + <span class="number">1</span>, p + <span class="number">1</span> + n, cmp1);<span class="comment">//按x从大到小</span></span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;<span class="comment">//记录树状数组下标</span></span><br><span class="line">		<span class="keyword">if</span> (p[i].b == p[i - <span class="number">1</span>].b)	p[i].id = p[i - <span class="number">1</span>].id;<span class="comment">//判重</span></span><br><span class="line">		<span class="keyword">else</span> p[i].id = ++cnt;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(p + <span class="number">1</span>, p + <span class="number">1</span> + n, cmp2);<span class="comment">//按y从大到小</span></span><br><span class="line">	<span class="keyword">int</span> j,ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j = i; j &lt;= n &amp;&amp; p[j].l == p[i].l; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (findmax(p[j].id - <span class="number">1</span>) &gt; p[j].r)	ans++;</span><br><span class="line">            <span class="comment">//比她b要大的人中，如果存在最大值比她自己的r大的话，答案加一</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (j = i; j &lt;= n &amp;&amp; p[j].l == p[i].l; j++)</span><br><span class="line">			modify(p[j].id, p[j].r);</span><br><span class="line">		i = j;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-1353D Constructing the Array 题解</title>
    <url>/2020/07/08/CF-1353D-Constructing-the-Array-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforc.es/problemset/problem/1353/D" target="_blank" rel="noopener">题目大意</a></h3><p>给你一个长度为n的数组，这个数组中每一位都为0，你需要选择仅由0组成的最长子数组，如果最大长度相同的话，选择最左边那一个。</p>
<p>对你每一个选择的子数组来说，如果长度为奇，则$a[\frac{l+r}{2}]$赋值为$i$。如果长度为偶，则$a[\frac{l+r-1}{2}]$赋值为$i$。$i$为进行的第几步。</p>
<a id="more"></a>

<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>这题本来没什么思路的。。。</p>
<p>群里大佬提醒了一下可以用优先队列</p>
<p>我就试了一下，一遍过了。。</p>
<p>其实思路很简单，构造一个按照长度由长到短，相等的时候优先靠左的优先队列。</p>
<p>定义一个结构体，储存$l,r,len$。优先队列的类型即为这个结构体。</p>
<p>起点为$l = 1,r = n,len = n$。</p>
<p>每次从队列中取出一个，按照题意分为左右两块区域。</p>
<p>然后一步一步插入即可。</p>
<p>需要手写一个判断的类函数。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">a</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> l, r, len;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(a n, a m)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (n.len == m.len)	<span class="keyword">return</span> n.l &gt; m.l;</span><br><span class="line">		<span class="keyword">return</span> n.len &lt; m.len;<span class="comment">//注意，和排序的时候是相反的</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;a, <span class="built_in">vector</span>&lt;a&gt;, cmp&gt; q;<span class="comment">//优先队列</span></span><br><span class="line"><span class="keyword">int</span> num[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		a m;</span><br><span class="line">		m.l = <span class="number">1</span>, m.r = n, m.len = n;</span><br><span class="line">		q.push(m);</span><br><span class="line">		<span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="keyword">sizeof</span>(num));</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			a t = q.top();</span><br><span class="line">			q.pop();</span><br><span class="line">			<span class="keyword">int</span> mid = (t.l + t.r) / <span class="number">2</span>;</span><br><span class="line">			num[mid] = i;</span><br><span class="line">			a m1, m2;</span><br><span class="line">			m1.l = t.l, m1.r = mid - <span class="number">1</span>, m1.len = mid - t.l;</span><br><span class="line">			m2.l = mid + <span class="number">1</span>, m2.r = t.r, m2.len = t.r - mid;</span><br><span class="line">			q.push(m1);</span><br><span class="line">			q.push(m2);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="built_in">string</span> s = i == n ? <span class="string">"\n"</span> : <span class="string">" "</span>;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; num[i] &lt;&lt; s;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (!q.empty())	q.pop();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>优先队列</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-1287C Garland 题解</title>
    <url>/2020/07/08/CF-1287C-Garland-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforc.es/contest/1287/problem/C" target="_blank" rel="noopener">题目大意</a></h3><p>给你一个数列，数列中每一个数不能重复，大小为1~n，0则表示该位置为空，需要填上数字。问你如何填满数列，使相邻两个数奇偶性不同的个数最小。求这个最小值。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这个题目有两个方法，一个是DP，一个是贪心。</p>
<p>贪心代码太麻烦了，就不用贪心了。</p>
<p>我们可以用dp[i] [j] [flag]表示，前i位中有j个偶数并且当前为奇数或偶数的最优解，即最小的个数。当flag为0时，为偶数，flag为1时，为奇数。</p>
<p>（三维DP。。第一次写这种题。。完全没有思路，看的别人大佬的代码。。</p>
<p>这样就可以得出状态转移方程</p>
<blockquote>
<p>当该位为奇数或者为0时</p>
<p>dp[i] [j] [1] = min(dp[i] [j] [1],dp[i-1] [j] [1]);（前一个数为奇数时）</p>
<p>dp[i] [j] [1] = min(dp[i] [j] [1],dp[i-1] [j] [0]+1);（前一个数为偶数时）</p>
<p>当该位为偶数或者为0时</p>
<p>dp[i] [j+1] [0] = min(dp[i] [j+1] [0],dp[i-1] [j] [0]);（前一个数为偶数时）</p>
<p>dp[i] [j+1] [0] = min(dp[i] [j+1] [0],dp[i-1] [j] [1]+1);（前一个数为奇数时）</p>
</blockquote>
<p>（太难想了吧。。根本想不到</p>
<p>答案为min(dp[n] [n/2] [1],dp[n] [n/2] [0])。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num[<span class="number">110</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">110</span>][<span class="number">110</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; num[i];</span><br><span class="line">	<span class="built_in">memset</span>(dp, <span class="number">127</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="comment">//补充知识</span></span><br><span class="line">    <span class="comment">//一般用memset只赋值0，1，-1，127</span></span><br><span class="line">    <span class="comment">//127表示填充最大值，即INF</span></span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n / <span class="number">2</span> ; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (num[i] % <span class="number">2</span> == <span class="number">0</span> || !num[i]) &#123;</span><br><span class="line">				dp[i][j + <span class="number">1</span>][<span class="number">0</span>] = <span class="built_in">min</span>(dp[i][j + <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][j][<span class="number">0</span>]);<span class="comment">//前一个数为偶数时</span></span><br><span class="line">				dp[i][j + <span class="number">1</span>][<span class="number">0</span>] = <span class="built_in">min</span>(dp[i][j + <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][j][<span class="number">1</span>] + <span class="number">1</span>);<span class="comment">//前一个数为奇数时</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (num[i] % <span class="number">2</span> == <span class="number">1</span> || !num[i]) &#123;</span><br><span class="line">				dp[i][j][<span class="number">1</span>] = <span class="built_in">min</span>(dp[i][j][<span class="number">1</span>], dp[i - <span class="number">1</span>][j][<span class="number">1</span>]);<span class="comment">//前一个数为奇数时</span></span><br><span class="line">				dp[i][j][<span class="number">1</span>] = <span class="built_in">min</span>(dp[i][j][<span class="number">1</span>], dp[i - <span class="number">1</span>][j][<span class="number">0</span>] + <span class="number">1</span>);<span class="comment">//前一个数为偶数时</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">min</span>(dp[n][n / <span class="number">2</span>][<span class="number">1</span>], dp[n][n / <span class="number">2</span>][<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-1251B Binary Palindromes 题解</title>
    <url>/2020/07/08/CF-1251B-Binary-Palindromes-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你n个01串，你可以交换每个串中任意一个数字的位置，无论是不是同一个串，问能构成多少个回文串。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>吐了。。</p>
<p>刚刚看到这个题目的时候，数据这么小，我以为是一些时间复杂度比较大的算法。</p>
<p>自己直接去模拟去了。</p>
<p>结果不好模拟，没啥思路。。</p>
<p>卡了好久，去看了眼题解。</p>
<p>发现自己就根本没往这方面想。。</p>
<p>我们可以统计所有串中的0和1的数量。</p>
<p>可以分为三种情况。</p>
<p>1、0为偶，1为偶</p>
<blockquote>
<p>显然，这些串是由l个偶长度串和m个奇长度串（m为偶数）构成的，不管m是否为0，都可以满足条件，所以n个串都可以是回文串。</p>
</blockquote>
<p>2、0为奇，1为偶（0为偶，1为奇）</p>
<blockquote>
<p>这些串是由l个偶长度串和m个奇长度串（m为奇数）构成的，可以把其中的奇数的插到一个奇长度串的中间，可以等价于第一种情况，所以n个串都可以是回文串。</p>
</blockquote>
<p>3、0为奇，1为奇</p>
<blockquote>
<p>这些串也是由l个偶长度串和m个奇长度串（m为偶数）构成的，但是如果m为0是不行的，会有一个串无法构成回文串，所以需要判断一下m是否小于2，因为m为2*k</p>
</blockquote>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">t</span>&#123;</span></span><br><span class="line">	<span class="built_in">string</span> s;</span><br><span class="line">	<span class="keyword">int</span> l;</span><br><span class="line">&#125;s[<span class="number">55</span>];<span class="comment">//之前写法留下来的，懒得改了，其实不需要这么麻烦的</span></span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		<span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)	<span class="built_in">cin</span> &gt;&gt; s[i].s, s[i].l = s[i].s.length();</span><br><span class="line">		<span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (s[i].l &amp; <span class="number">1</span>)	c++;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s[i].l; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (s[i].s[j] == <span class="string">'1'</span>)	cnt[<span class="number">1</span>]++;</span><br><span class="line">				<span class="keyword">else</span> cnt[<span class="number">0</span>]++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ((cnt[<span class="number">1</span>] &amp; <span class="number">1</span>) &amp;&amp; (cnt[<span class="number">0</span>] &amp; <span class="number">1</span>) &amp;&amp; c &lt; <span class="number">2</span>)	n--;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-1389B Array Walk 题解</title>
    <url>/2020/11/25/CF-1389B-Array-Walk-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforces.com/problemset/problem/1389/B" target="_blank" rel="noopener">题目大意</a></h3><p>给你一个数组，你从第一个位置开始走，每次可以选择向左走或者向右走，你最多有z次向右走的机会，最多走k步，你踩到的数字算你获得的积分，问你最多获得多少积分。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>DP题。</p>
<p>设$dp[i] [j]$表示在位置i处，已经用了j次左移机会的最大值。</p>
<p>从左边转移的值为$dp[j-1][i]+num[j]$，从右边转移的值为$dp[j+1][i-1]+num[j]$。</p>
<p>需要注意当j在位置最右边的时候不能从右边转移。</p>
<p>这个答案取的就很妙。</p>
<p>当$j-1+2*i$的值等于m时更新最大值。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for (ll i=a;i&lt;=n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,n) for (ll i=n;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(x,y) make_pair(x,y)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bg begin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rbg rbegin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ed end</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dbg(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">"==="</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line">ll dp[N][<span class="number">6</span>];</span><br><span class="line"><span class="keyword">int</span> num[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)	ans *= a;</span><br><span class="line">		a &lt;&lt;= <span class="number">1</span>, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\in.txt", "r", stdin);</span></span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\out.txt", "w+", stdout);</span></span><br><span class="line">	<span class="keyword">int</span> t; <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n, k, z;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k &gt;&gt; z;</span><br><span class="line">		rep(i, <span class="number">1</span>, n)	<span class="built_in">cin</span> &gt;&gt; num[i];</span><br><span class="line">		ll ans = <span class="number">0</span>;</span><br><span class="line">		rep(i, <span class="number">0</span>, z) &#123;</span><br><span class="line">			rep(j, <span class="number">1</span>, n) &#123;</span><br><span class="line">				dp[j][i] = dp[j - <span class="number">1</span>][i] + num[j];</span><br><span class="line">				<span class="keyword">if</span> (i &amp;&amp; j != n)	dp[j][i] = <span class="built_in">max</span>(dp[j][i], dp[j + <span class="number">1</span>][i - <span class="number">1</span>] + num[j]);</span><br><span class="line">				<span class="keyword">if</span> (j - <span class="number">1</span> + <span class="number">2</span> * i == k)	ans = <span class="built_in">max</span>(ans, dp[j][i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-1251C Minimize The Integer 题解</title>
    <url>/2020/07/10/CF-1251C-Minimize-The-Integer-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="">题目大意</a></h3><p>给你一串数字序列，如果两个数奇偶性不同，就可以交换位置，问这一串数字序列最小值是多少。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>属实没想到这个题的正解。。</p>
<p>卡了我好久。</p>
<p>想的时候就没啥好思路。</p>
<p>好久没写题了。。脑子有点僵化了。（其实本来就不是很好用</p>
<p>因为只能交换奇偶性不同的数字的位置。</p>
<p>那么奇数列和偶数列中的每一个元素的相对位置是不变的，</p>
<p>所以只需要判断哪个小，便填入那个小的数即可。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (c == <span class="string">'1'</span> || c == <span class="string">'3'</span> || c == <span class="string">'5'</span> || c == <span class="string">'7'</span> || c == <span class="string">'9'</span>)	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;q1, q2, q3;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="built_in">string</span> s;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">		<span class="keyword">int</span> l = s.length();</span><br><span class="line">		q1.<span class="built_in">clear</span>();</span><br><span class="line">		q2.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (check(s[i]))	q1.push_back(s[i]);</span><br><span class="line">			<span class="keyword">else</span> q2.push_back(s[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> i, j;</span><br><span class="line">		i = j = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; q1.<span class="built_in">size</span>() &amp;&amp; j &lt; q2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (q1[i] &lt; q2[j])	<span class="built_in">cout</span> &lt;&lt; q1[i], i++;</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; q2[j], j++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; q1.<span class="built_in">size</span>())	<span class="keyword">for</span> (<span class="keyword">int</span> g = i; g &lt; q1.<span class="built_in">size</span>(); g++)	<span class="built_in">cout</span> &lt;&lt; q1[g];</span><br><span class="line">		<span class="keyword">if</span> (j &lt; q2.<span class="built_in">size</span>())	<span class="keyword">for</span> (<span class="keyword">int</span> g = j; g &lt; q2.<span class="built_in">size</span>(); g++)	<span class="built_in">cout</span> &lt;&lt; q2[g];</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-1260C Infinite Fence 题解</title>
    <url>/2020/07/13/CF-1260C-Infinite-Fence-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforces.com/problemset/problem/1260/C" target="_blank" rel="noopener">题目大意</a></h3><p>从0开始有$10^{100}$堵墙，当序号为b的倍数时，涂成蓝色，当序号为r的倍数时，涂成红色，当既是b的倍数又是r的倍数时，可以任意选择颜色。问连续相同颜色的墙的数量是否大于k。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这个题是真的坑。。</p>
<p>我想了好久，但是我的思路一直wa。。</p>
<p>没想到什么好的方法，最后还是去看了题解。。</p>
<p>发现我的思路很接近正解了，就是找的区间不一样。</p>
<p>正解的区间是两个区间起点最近的一个区间，我是$[b,2b]$。。</p>
<p>其实这种题还是挺考验数学思维的。</p>
<p>首先，我们假设r小于b。</p>
<p>显然，最长的连续的区间肯定是在两个b的倍数之间的。</p>
<p>那么对于r来说，最长的区间长度就是b-1。</p>
<p>接下来就需要找到r的区间了。</p>
<p>设b的区间为$[n_1b,n_2b]$。</p>
<p>设距离左端点最近的距离为l。</p>
<p>那么则有$n_1b+t=kr$，由拓欧得，式子可以变为$n_1b+kr=t$，当$gcd(b,r)|t$时有解，t最小为$gcd(b,r)$。</p>
<p>得到r的区间长度为$(b-1)-gcd(b,r)$。</p>
<p>所以这个区间的红色木板的个数为$\frac{(b-1)-gcd(b,r)}{r}+1$,显然，这个也是最大的连续的个数。</p>
<p>判断这个与k的大小关系即可。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !b ? a: gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t,m;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		ll r, b, k;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; r &gt;&gt; b &gt;&gt; k;</span><br><span class="line">		<span class="keyword">if</span> (r &gt; b)	swap(r, b);</span><br><span class="line">		ll ans = (b - <span class="number">1</span> - gcd(r, b)) / r + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (ans&gt;=k)	<span class="built_in">cout</span> &lt;&lt; <span class="string">"REBEL"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"OBEY"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-1358C Celex Update 题解</title>
    <url>/2020/10/07/CF-1358C-Celex-Update-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforces.com/contest/1358/problem/C" target="_blank" rel="noopener">题目大意</a></h3><p>如图表格，左上角坐标为（1,1），给你两个点的坐标，你只能往右走或者往下走，求不同路径和的路径数量。</p>
<p><img src="http://inews.gtimg.com/newsapp_ls/0/12573039235/0" alt=""></p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>刚开始想了好久了，想到了一个思路，能保证是正解，但是不够快，只能爆搜。</p>
<p><img src="http://inews.gtimg.com/newsapp_ls/0/12573055369/0" alt=""></p>
<p>以最上面的那一条路径为基础，每往下走就算是加一，向右走就保持不动，每个点的权值就靠这个确定。</p>
<p>（其实和正解很相似了。。只是根本没想到。。</p>
<p>这样可以靠爆搜的代码来跑出规律，答案就是$dx* dy+1$。</p>
<p>但是正解应该是以最上面那一条路为基础，每把右上角一个点掰到左下角就相当于是加了一，保证了每条路径的和不同，这样获得的路径数就是除去第一条路左下角的格子数量，即$dx\times dy$。</p>
<p>再加上原本的路径便是正确答案。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t; <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> x1, x2, y1, y2;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">		ll dx = <span class="built_in">abs</span>(x1 - x2), dy = <span class="built_in">abs</span>(y1 - y2);</span><br><span class="line">		ll ans = dx * dy + <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>规律</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-1422B Nice Matrix 题解</title>
    <url>/2021/02/19/CF-1422B-Nice-Matrix-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforces.com/problemset/problem/1422/B" target="_blank" rel="noopener">题目大意</a></h3><p>给你一个矩阵，你需要使矩阵的每一行和每一列都是回文串，你可以使任意一个数字加一或者减一，问最少修改次数。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>没啥好说的，就是单纯的贪心。</p>
<p>贪心思路和之前的acwing写过的<a href="https://www.acwing.com/problem/content/106/" target="_blank" rel="noopener">货仓选址</a>一样。</p>
<p>就是给你n个数，问哪个整数与其他数的差的绝对值的和最小。</p>
<p>如果是奇数个，答案就是最中间的数。</p>
<p>如果是偶数个，答案就是中间两个任取。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for (int i=a;i&lt;=n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,n) for (int i=a;i&gt;=n;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bg begin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rbg rbegin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ed end</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dbg(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">"==="</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line">ll num[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)	ans *= a;</span><br><span class="line">		a &lt;&lt;= <span class="number">1</span>, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\in.txt", "r", stdin);</span></span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\out.txt", "w+", stdout);</span></span><br><span class="line">	<span class="keyword">int</span> t; <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n, m; <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">		rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">			rep(j, <span class="number">1</span>, m) <span class="built_in">cin</span> &gt;&gt; num[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">		ll ans = <span class="number">0</span>;</span><br><span class="line">		rep(i, <span class="number">1</span>, <span class="built_in">ceil</span>(n * <span class="number">1.0</span> / <span class="number">2</span>)) &#123;</span><br><span class="line">			rep(j, <span class="number">1</span>, <span class="built_in">ceil</span>(m * <span class="number">1.0</span> / <span class="number">2</span>)) &#123;</span><br><span class="line">				<span class="built_in">vector</span>&lt;ll&gt; v;</span><br><span class="line">				v.push_back(num[i][j]);</span><br><span class="line">				<span class="keyword">if</span>(j!=m-j+<span class="number">1</span>)	v.push_back(num[i][m - j + <span class="number">1</span>]);</span><br><span class="line">				<span class="keyword">if</span>(i!=n-i+<span class="number">1</span>)	v.push_back(num[n - i + <span class="number">1</span>][j]);</span><br><span class="line">				<span class="keyword">if</span>(i!=n-i+<span class="number">1</span>&amp;&amp;j!=m-j+<span class="number">1</span>)	v.push_back(num[n - i + <span class="number">1</span>][m - j + <span class="number">1</span>]);</span><br><span class="line">				sort(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">				<span class="keyword">if</span> (v.<span class="built_in">size</span>() != <span class="number">1</span>) &#123;</span><br><span class="line">					ll t = v[<span class="number">1</span>];</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">auto</span> x : v) &#123;</span><br><span class="line">						ans += <span class="built_in">abs</span>(x - t);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;	</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-1426C Increase and Copy 题解</title>
    <url>/2020/10/07/CF-1426C-Increase-and-Copy-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforces.com/problemset/problem/1426/C" target="_blank" rel="noopener">题目大意</a></h3><p>有个数组，最初只有一个1，你可以对他进行两种操作，复制其中的一个数，或者让其中一个数加一。问至少大于n需要的最小操作数。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>显然，先加在复制是最优解。</p>
<p>但是你不知道加到哪个数的时候是最优解。</p>
<p>而且他的n特别大，有1e9。</p>
<p>貌似我也没想到二分搜怎么做。</p>
<p>后面他们说了要打表找规律。</p>
<p>一看，规律就是0,1,2,2,3,3,4,4,4,5,5,5。</p>
<p>跟着规律输出就行了。</p>
<p>（以后看到这么大的数据，且算法复杂度不知道如何优化的题，要想到打表来做。。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line">ll num[<span class="number">70050</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t; <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">65000</span>; i++)	num[i] = i * i + i;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">1e9</span>;</span><br><span class="line">		<span class="comment">/*for (int i = 1; i &lt;= n; i++) &#123; 打表用</span></span><br><span class="line"><span class="comment">			int t = (i - 1);</span></span><br><span class="line"><span class="comment">			double tmp = 1.0*(n - i) / i;</span></span><br><span class="line"><span class="comment">			if ((int)tmp != tmp)	t++;</span></span><br><span class="line"><span class="comment">			t += (int)tmp;</span></span><br><span class="line"><span class="comment">			ans = min(ans, t);</span></span><br><span class="line"><span class="comment">		&#125;*/</span></span><br><span class="line">		<span class="keyword">int</span> pos = lower_bound(num + <span class="number">1</span>, num + <span class="number">65001</span>, n) - num;</span><br><span class="line">		n -= num[pos - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">int</span> i = pos;</span><br><span class="line">		<span class="keyword">if</span> (n &lt;= pos)	ans = <span class="number">2</span> * i - <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">else</span> ans = <span class="number">2</span> * i - <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>规律</tag>
        <tag>打表</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-1430D String Deletion 题解</title>
    <url>/2021/02/20/CF-1430D-String-Deletion-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforces.com/problemset/problem/1430/D" target="_blank" rel="noopener">题目大意</a></h3><p>给你一个字符串，每个回合这个字符串都会将最前面的连续一段删除，但是你能在删除之前任意删除一个字符，问最多可以持续多少回合。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>首先统计字符串中长度大于2的字符串，并且记住位置。</p>
<p>最优解很简单，如果最前面的字符串连续的长度超过2，则删除其中的任意一个。</p>
<p>如果不连续，则选择删除后面的连续长度超过2的字符串中的一个，如果后面没有，则可以直接退出。</p>
<p>用一个模拟指针表示你选择的字符串即可。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for (int i=a;i&lt;=n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,n) for (int i=a;i&gt;=n;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bg begin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rbg rbegin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ed end</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dbg(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">"==="</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> len[N], pos[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b, ll mod)</span> </span>&#123;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)	ans = (ans * a) % mod;</span><br><span class="line">		a = (a * a) % mod, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\in.txt", "r", stdin);</span></span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\out.txt", "w+", stdout);</span></span><br><span class="line">	<span class="keyword">int</span> t; <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		<span class="built_in">string</span> s; <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">1</span>, cnt1 = <span class="number">0</span>,cnt2 = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">char</span> f = s[<span class="number">0</span>];</span><br><span class="line">		rep(i, <span class="number">1</span>, s.length() - <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (s[i] == f) sum++;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (sum &gt; <span class="number">1</span>) pos[cnt2++] = cnt1;</span><br><span class="line">				len[cnt1++] = sum;</span><br><span class="line">				f = s[i];</span><br><span class="line">				sum = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (sum &gt; <span class="number">1</span>) pos[cnt2++] = cnt1;</span><br><span class="line">		len[cnt1++] = sum;</span><br><span class="line">		<span class="keyword">int</span> t = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">		rep(i, <span class="number">0</span>, cnt1 - <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (len[i] &gt; <span class="number">1</span>)	t++;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (t == cnt2) &#123;</span><br><span class="line">					ans += (cnt1 - i + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				len[pos[t]]--;</span><br><span class="line">				<span class="keyword">if</span> (len[pos[t]] == <span class="number">1</span>) t++;</span><br><span class="line">			&#125;</span><br><span class="line">			ans++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-1437B Reverse Binary Strings 题解</title>
    <url>/2020/11/02/CF-1437B-Reverse-Binary-Strings-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforces.com/contest/1437/problem/B" target="_blank" rel="noopener">题目大意</a></h3><p>给你一个01字符串，你可以反转任意一个字符串子串，需要让这个字符串01交替，问最少需要反转多少次。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这题不难，就是一道思维题。。</p>
<p>（思维真不行。。</p>
<p>因为需要所有0和1都不连续，所以可以统计连续的1和连续的0的数量。</p>
<p>每次反转最多同时使连续的1和0数量减一，所以答案就是连续的1和0中的最大值。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for (ll i=a;i&lt;=n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,n) for (ll i=n;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(x,y) make_pair(x,y)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bg begin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rbg rbegin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ed end</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dbg(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">"==="</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)	ans *= a;</span><br><span class="line">		a &lt;&lt;= <span class="number">1</span>, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\in.txt", "r", stdin);</span></span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\out.txt", "w+", stdout);</span></span><br><span class="line">	<span class="keyword">int</span> t; <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		<span class="built_in">string</span> s; <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">		<span class="keyword">int</span> cnt0 = <span class="number">0</span>,cnt1 = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (s[i] - <span class="string">'0'</span> == <span class="number">0</span> &amp;&amp; s[i + <span class="number">1</span>] - <span class="string">'0'</span> == <span class="number">0</span>)	cnt0++;</span><br><span class="line">			<span class="keyword">if</span> (s[i] - <span class="string">'0'</span> == <span class="number">1</span> &amp;&amp; s[i + <span class="number">1</span>] - <span class="string">'0'</span> == <span class="number">1</span>)	cnt1++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">max</span>(cnt0,cnt1) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-1425A Arena of Greed 题解</title>
    <url>/2020/10/24/CF-1425A-Arena-of-Greed-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforces.com/problemset/problem/1425/A" target="_blank" rel="noopener">题目大意</a></h3><p>一个箱子里有<code>n</code>个金币，两个人轮流取金币，每个人可以进行两种操作，第一种是取出一个金币，第二种是取出其中一半。只有当箱子中的金币数量为偶数的时候，才能进行第二种操作。问先手最多取出多少金币，两个人都是最优策略。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>刚开始有了思路，并且是对的。。</p>
<p>但是样例过不了，卡了好久。</p>
<p>后面看了题解，发现4要特判，我吐了。。</p>
<p>其他的都没问题。</p>
<p>（以后要注意特判啊啊啊</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t; <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		ll n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		ll a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (n) &#123;</span><br><span class="line">			<span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (n &amp; <span class="number">1</span>)	a += <span class="number">1</span>, n--;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> (n == <span class="number">4</span>)	a += <span class="number">3</span>, n = <span class="number">0</span>;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="keyword">if</span> ((n - n / <span class="number">2</span>) &amp; <span class="number">1</span>)	a += n / <span class="number">2</span>, n -= n / <span class="number">2</span>;</span><br><span class="line">						<span class="keyword">else</span> a++, n--;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (n &amp; <span class="number">1</span>)	n--;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> (n == <span class="number">4</span>)	a++, n = <span class="number">0</span>;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="keyword">if</span> ((n - n / <span class="number">2</span>) &amp; <span class="number">1</span>)	n -= n / <span class="number">2</span>;</span><br><span class="line">						<span class="keyword">else</span> n--;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			flag *= <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-198B Jumping on Walls 题解</title>
    <url>/2020/11/09/CF-198B-Jumping-on-Walls-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforces.com/problemset/problem/198/B" target="_blank" rel="noopener">题目大意</a></h3><p>给你两个墙，你一开始在第一面墙的最下面，你每次可以进行三种操作，向上爬一格，向下爬一格或者跳到对面的向上k格的位置。</p>
<p>刚开始的时候水在-1层，你每移动一次，水就上升一层，你不能进入被水覆盖的区域，问能否爬出墙。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>刚开始就被cf的标签骗了，写个最短路。。</p>
<p>我刚开始还发现好像可以用最短路写，写了好久写出Dijkstra，后面发现不对。。</p>
<p>结果一搜发现是搜索，我吐了。。</p>
<p>这个搜索倒是挺简单的，只是需要剪枝，走过的地方就不用在走了。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for (ll i=a;i&lt;=n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,n) for (ll i=n;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(x,y) make_pair(x,y)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bg begin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rbg rbegin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ed end</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dbg(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">"==="</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">500</span>, INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>, vis[<span class="number">2</span>][N], n, k;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">2</span>][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)	ans *= a;</span><br><span class="line">		a &lt;&lt;= <span class="number">1</span>, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> num, <span class="keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (pos &gt;= n || flag) &#123;</span><br><span class="line">		flag = <span class="number">1</span>; <span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (pos &lt;= cnt || s[num][pos] == <span class="string">'X'</span> || vis[num][pos])	<span class="keyword">return</span>;</span><br><span class="line">	vis[num][pos] = <span class="number">1</span>;</span><br><span class="line">	dfs(pos + k, num ^ <span class="number">1</span>, cnt + <span class="number">1</span>);</span><br><span class="line">	dfs(pos + <span class="number">1</span>, num, cnt + <span class="number">1</span>);</span><br><span class="line">	dfs(pos - <span class="number">1</span>, num, cnt + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\in.txt", "r", stdin);</span></span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\out.txt", "w+", stdout);</span></span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; s[<span class="number">0</span>] &gt;&gt; s[<span class="number">1</span>];</span><br><span class="line">	dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">if</span> (flag)	<span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-1426D Non-zero Segments 题解</title>
    <url>/2020/11/14/CF-1426D-Non-zero-Segments-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforces.com/problemset/problem/1426/D" target="_blank" rel="noopener">题目大意</a></h3><p>给你一个数组，你可以在数组中任意位置插入任意的数，需要满足数组的任意子段的和不为0，求最少的插入数。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>刚开始这题没有什么思路，后面发现应该是用前缀和来做。</p>
<p>因为需要所有子段，但是没想到怎么具体去做。</p>
<p>看了题解，发现这个思路是真的妙。</p>
<p>对数组进行求前缀和，统计每次的值，当某个值出现两次时，说明有一段是被抵消了，即那一段为零，或者某一段的前缀和就是0，这时候在这个位置之前加入一个无穷大的值，相当于将前面那一段去掉了，只需要对之后继续进行求前缀和即可。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for (ll i=a;i&lt;=n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,n) for (ll i=n;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(x,y) make_pair(x,y)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bg begin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rbg rbegin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ed end</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dbg(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">"==="</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="built_in">set</span>&lt;ll&gt; s;</span><br><span class="line"><span class="keyword">int</span> num[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)	ans *= a;</span><br><span class="line">		a &lt;&lt;= <span class="number">1</span>, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\in.txt", "r", stdin);</span></span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\out.txt", "w+", stdout);</span></span><br><span class="line">	<span class="keyword">int</span> n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	rep(i, <span class="number">1</span>, n)	<span class="built_in">cin</span> &gt;&gt; num[i];</span><br><span class="line">	ll cnt = <span class="number">0</span>,sum = <span class="number">0</span>;</span><br><span class="line">	rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">		sum += num[i];</span><br><span class="line">		<span class="keyword">if</span> (!s.count(sum) &amp;&amp; sum)	s.insert(sum);</span><br><span class="line">		<span class="keyword">else</span> s.<span class="built_in">clear</span>(), cnt++, s.insert(num[i]), sum = num[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-293A Weird Game 题解</title>
    <url>/2020/07/08/CF-293A-Weird-Game-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://codeforces.com/problemset/problem/293/A" target="_blank" rel="noopener">题目大意</a></h3><p>输入两串长度为2*n的0,1序列，一串是Y的，一串是A的。Y先手，A后手，每人可以任意选一个位置，选了之后两人都不能再选这个位置，比较他们的选择的串的大小。每人都是最优选择。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>很明显的博弈题目。。但是WA了我好几发。</p>
<p>（确实博弈相当苦手</p>
<p>分四种情况</p>
<blockquote>
<p>1、1–1，这个肯定是优先选的，这样自己能选一个1，又能让对方少一个1.</p>
<p>2、1–0，这个除了1–1Y会优先选择，可以让Y多一个1.</p>
<p>3、0–1，这个除了1–1A会优先选择，可以让A多一个1.</p>
<p>4、0–0，这个肯定是最后选的。</p>
</blockquote>
<p>把2记为ans1，3记为ans2。</p>
<p>如果1–1为奇数的话，就相当于第二种情况多加了一个，因为Y是先手，会优先选择这个。也就是ans1++。</p>
<p>答案情况也分为四种</p>
<blockquote>
<p>1、ans1&gt;ans2 这个情况，Y的1的数量大于A的1的数量，Y获胜。</p>
<p>2、ans1==ans2 这个情况，Y的1的数量等于A的1的数量，平局。</p>
<p>3、ans1==ans2-1 这个情况，A多了一个0–1，因为Y为先手，可以取掉这个，使Y和A相等，平局。（这个情况卡了我好久啊啊）</p>
<p>4、ans1&lt;ans2-1 这个情况，Y的1数量小于A的数量，且差值大于1，故A获胜。</p>
</blockquote>
<p>（博弈是真的难。。感觉自己智商不够。。太难想了</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> ch1[N], ch2[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; ch1 &gt;&gt; ch2;</span><br><span class="line">	<span class="keyword">int</span> ans1, ans2, cnt;</span><br><span class="line">	ans1 = ans2 = cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ch1[i] == <span class="string">'1'</span> &amp;&amp; ch2[i] == <span class="string">'0'</span>)	ans1++;</span><br><span class="line">		<span class="keyword">if</span> (ch1[i] == <span class="string">'0'</span> &amp;&amp; ch2[i] == <span class="string">'1'</span>)	ans2++;</span><br><span class="line">		<span class="keyword">if</span> (ch1[i] == <span class="string">'1'</span> &amp;&amp; ch2[i] == <span class="string">'1'</span>)	cnt++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (cnt % <span class="number">2</span> != <span class="number">0</span>)	ans1 ++;</span><br><span class="line">	<span class="keyword">if</span> (ans1 &gt; ans2)	<span class="built_in">cout</span> &lt;&lt; <span class="string">"First"</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (ans2 &gt; ans1 + <span class="number">1</span>)	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Second"</span>;</span><br><span class="line">	<span class="keyword">else</span>  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Draw"</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-567D One-Dimensional Battle Ships 题解</title>
    <url>/2021/02/21/CF-567D-One-Dimensional-Battle-Ships-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforces.com/problemset/problem/567/D" target="_blank" rel="noopener">题目大意</a></h3><p>有一个$1\times n$的矩形，上面有k条船，每条船的长度为a，两条船之间不能接触（至少相隔1格）。</p>
<p>给定你m个点，告诉你这些点没有船，问第几次能发现在说谎。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这个题目我还真没想到可以这么写。</p>
<p>准确说没啥思路。</p>
<p>先求出最多能放的船的数量。</p>
<p>这个计算一段区间能放船的数量的方法有点神奇，$ans = \frac{(len + 1)}{(a+1)}$。</p>
<p>每条船需要占用$a+1$的空间，但是最后一条船不需要，所以相当于可以补个1.</p>
<p>之后枚举每个点，计算加上这个点之后，减少了多少船，如果船的数量少于k了，就不行。</p>
<p>对于这个点，减少的船的数量就是up<del>down（总的）-mid</del>down（右边）-up~mid（左边）。</p>
<p>up和down分别为这个最近的前一个点和后一个点。</p>
<p>为了保证点为有序，需要使用set（其实优先队列也可以，但是不好维护）。</p>
<p>对于set需要用set.upper_bound()来查找，不能使用stl里面的。</p>
<p>这个让我又发现了一个bug，因为stl的upper_bound对set用的时候超时了。</p>
<p>后来查了半天，发现有大佬提出来了，这边贴一下。</p>
<blockquote>
<p><code>set::upper_bound</code>将使用集合的功能有效地搜索值（与容器大小成对数关系）。</p>
<p>对于<code>std::upper_bound</code>，使用非<code>LegacyRandomAccessIterators</code>，比如<code>std::set</code>s迭代器（即<code>LegacyBidirectionalIterator</code>s），迭代器增量的数量是线性的。</p>
</blockquote>
<p>所以以后需要注意。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for (int i=a;i&lt;=n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,n) for (int i=a;i&gt;=n;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bg begin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rbg rbegin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ed end</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dbg(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">"==="</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> pos[N];</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b, ll mod)</span> </span>&#123;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)	ans = (ans * a) % mod;</span><br><span class="line">		a = (a * a) % mod, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\in.txt", "r", stdin);</span></span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\out.txt", "w+", stdout);</span></span><br><span class="line">	<span class="keyword">int</span> n, k, a, m; <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k &gt;&gt; a &gt;&gt; m;</span><br><span class="line">	rep(i, <span class="number">1</span>, m) <span class="built_in">cin</span> &gt;&gt; pos[i];</span><br><span class="line">	s.insert(<span class="number">0</span>), s.insert(n + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> cnt = (n + <span class="number">1</span>) / (a + <span class="number">1</span>), ans = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">auto</span> up = s.<span class="built_in">begin</span>(), down = s.<span class="built_in">end</span>();</span><br><span class="line">	rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = pos[i];</span><br><span class="line">		up = down = upper_bound(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), mid);</span><br><span class="line">		down--;</span><br><span class="line">		cnt -= (*up - *down) / (a + <span class="number">1</span>) - (*up - mid) / (a + <span class="number">1</span>) - (mid - *down) / (a + <span class="number">1</span>);</span><br><span class="line">		s.insert(mid);</span><br><span class="line">		<span class="keyword">if</span> (cnt &lt; k) &#123;</span><br><span class="line">			ans = i; <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-634E1/2 Three Blocks Palindrome (easy/hard version) 题解</title>
    <url>/2020/07/08/CF-634E12-Three-Blocks-Palindrome-(easyhard-version)-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforc.es/contest/1335/problem/E1" target="_blank" rel="noopener">题目大意</a></h3><p>定义一个三段串为一种序列，每一个序列为x个a，y个b，x个a组成，x，y大于等于0.</p>
<p><img src="https://ae01.alicdn.com/kf/Hf028e3af9072427888a4f2963736ff3ek.png" alt=""></p>
<p>可以是全为a这样一种数字，或者是2个x个a夹着y个b，也就是一种对称的数字夹着另一种数字。</p>
<p>求这种序列的最长长度。</p>
<a id="more"></a>

<p>（说实话，我写的时候可能题目都没看懂。。</p>
<p>导致往最长回文子序列去想了。。。以后还是要注意看题。</p>
<p>有一次div2的A，光看懂题就看了半个多小时。</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>用vector数组去记录每一个数字的位置。</p>
<p>分两种情况去考虑：</p>
<p>第一种：全为一种数字</p>
<blockquote>
<p>很简单，只用判断哪一种数字的v.size()最大即可。</p>
</blockquote>
<p>第二种：一种数字夹着另一种数字</p>
<blockquote>
<p>设每一种数字的数量为cnt=v.size()。</p>
<p>那么左右两边最大长度为c=cnt/2。</p>
<p>如果c&lt;=1，那么就不用考虑，直接continue。</p>
<p>cnt分为奇数和偶数。</p>
<p>当cnt为奇数的时候，左区间为0 ~ c-1，右区间为c+1 ~ cnt-1。</p>
<p>当cnt为偶数的时候，左区间为0 ~ c-1，右区间为c ~ cnt-1。</p>
<p>但实际上，我们可以将他们都表示为左区间为0 ~ c-1，右区间为cnt-c ~ cnt-1。</p>
<p>论证如下：(其实看规律也看得出)</p>
<p>当cnt为奇数的时候，cnt-c=2*c+1-c=c+1。</p>
<p>当cnt为偶数的时候，cnt-c=2*c-c=c。</p>
<p>第一个状态就是从区间[v.[c-1]+1~v.[cnt-c]-1]中找出出现最多次数的数字的个数为M。</p>
<p>用n数组表示大小为i的数字的个数。</p>
<p>那么答案为M+2*c。</p>
<p>之后的状态便是枚举长度，从j = c-1开始，枚举到1。</p>
<p>不断更新答案，答案为M+2*j。</p>
</blockquote>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p>主要还是看代码吧。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> num[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v[<span class="number">220</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">200</span>; i++)	v[i].<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; num[i];</span><br><span class="line">			v[num[i]].push_back(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">-1e9</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">200</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> cnt = v[i].<span class="built_in">size</span>(), c;</span><br><span class="line">			ans = <span class="built_in">max</span>(ans, cnt);</span><br><span class="line">			c = cnt / <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span> (cnt &lt;= <span class="number">1</span>)	<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">int</span> n[<span class="number">220</span>] = &#123; <span class="number">0</span> &#125;, M = <span class="number">-1e9</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = v[i][c - <span class="number">1</span>] + <span class="number">1</span>; j &lt; v[i][cnt - c]; j++) &#123;</span><br><span class="line">				n[num[j]]++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">200</span>; j++)	M = <span class="built_in">max</span>(M, n[j]);</span><br><span class="line">			ans = <span class="built_in">max</span>(ans, M + <span class="number">2</span> * c);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = c - <span class="number">1</span>; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> g = v[i][j - <span class="number">1</span>] + <span class="number">1</span>; g &lt; v[i][j]; g++)	n[num[g]]++;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> g = v[i][cnt - j - <span class="number">1</span>] + <span class="number">1</span>; g &lt; v[i][cnt - j]; g++)	n[num[g]]++;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> g = <span class="number">1</span>; g &lt;= <span class="number">200</span>; g++)	M = <span class="built_in">max</span>(M, n[g]);</span><br><span class="line">				ans = <span class="built_in">max</span>(ans, M + <span class="number">2</span> * j);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-636D Constant Palindrome Sum 题解</title>
    <url>/2020/07/08/CF-636D-Constant-Palindrome-Sum-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforces.ml/contest/1343/problem/D" target="_blank" rel="noopener">题目大意</a></h3><p>给你n个不超过k的数（n为偶数），要求a[i]+a[n-i+1]都等于一个数x，你可以替换任意一个数，使其变成1到k中任意一个数，问你最少替换多少个数，使数组满足条件。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>（我写到这里用了45分钟，后面就动不了了。。。我还是太菜了。。</p>
<p>我是没想到用差分。。</p>
<p>用一个数组d[i]来表示，x为i时，需要替换多少个数字。</p>
<p>令sum=a[i]+a[n-i+1]，maxn=max（a[i]，a[n-i+1]），minn=min（a[i]，a[n-i+1]）。</p>
<p>我们取极端情况，当大的那个数字为1时，在修改一个数字的时候，和最小，为minn+1。</p>
<p>当小的那个数字为k时，在修改一个数字的时候，和最大，为maxn+k。</p>
<p>所以</p>
<blockquote>
<p>1、x在[2,minn]时，需要修改两个数字，d[2]+=2，d[minn+1] -=2。</p>
<p>2、x在[minn+1,maxn+k]时，需要修改一个数字，d[minn+1]++，d[maxn+k+1]- -。</p>
<p>3、x在[maxn+k+1,2 * k]时，需要修改两个数字，d[maxn+k+1]+=2，d[2 * k+1]-=2（这个可以不用）。</p>
<p>4、x为sum时，不需要修改，但是sum在第二种情况中已经被修改了，所以需要补上来 ，d[sum]- -，d[sum+1]++。</p>
</blockquote>
<p>整理后</p>
<blockquote>
<p>d[2] += 2;<br>d[minn+1]- -;<br>d[maxn + k + 1]++;<br>d[sum]- -;<br>d[sum + 1]++;</p>
</blockquote>
<p>然后从2到2*k跑一边差分取最小值即可。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> num[N],d[<span class="number">2</span>*N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">int</span> n,k;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">		<span class="keyword">int</span> sum, maxn, minn;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; num[i];</span><br><span class="line">			<span class="keyword">if</span> (i &gt; n / <span class="number">2</span>) &#123;</span><br><span class="line">				sum = num[i] + num[n - i + <span class="number">1</span>];</span><br><span class="line">				maxn = <span class="built_in">max</span>(num[i], num[n - i + <span class="number">1</span>]);</span><br><span class="line">				minn = <span class="built_in">min</span>(num[i], num[n - i + <span class="number">1</span>]);</span><br><span class="line">				d[<span class="number">2</span>] += <span class="number">2</span>;<span class="comment">//差分</span></span><br><span class="line">				d[minn+<span class="number">1</span>]--;</span><br><span class="line">				d[maxn + k + <span class="number">1</span>]++;</span><br><span class="line">				d[sum]--;</span><br><span class="line">				d[sum + <span class="number">1</span>]++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">1e9</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">2</span> * k; i++) &#123;</span><br><span class="line">			d[i] += d[i - <span class="number">1</span>];</span><br><span class="line">			ans = <span class="built_in">min</span>(ans, d[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-455A Boredom 题解</title>
    <url>/2020/07/08/CF-455A-Boredom-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://codeforces.com/problemset/problem/455/A" target="_blank" rel="noopener">题目大意</a></h3><p>给你一个数组a，里面有n个整数。你每次可以选择数组中的一个元素ak，从数组中删掉它，再删掉所有值等于ak + 1 或者 ak - 1的元素，这样你可以得到 ak 分。你可以重复进行多次该操作，请问你最后最多能得多少分？</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>每个数字都分为两种情况，选和不选。</p>
<p>（这样其实和01背包有点类似</p>
<p>这样我们可以用一个数组，储存每个数字的出现次数。</p>
<p>用DP的思想，令数组dp[i]为1~i的最大分数。</p>
<p>对于每一个数来说，分为两种情况</p>
<blockquote>
<p>1、选这个数 那么i-1这个数就不能选，dp[i]=dp[i-2]+cnt[i]*i。</p>
<p>2、不选这个数 那么dp[i]=dp[i-1]。</p>
</blockquote>
<p>得出状态转移方程dp[i]=max(dp[i-1],dp[i-2]+cnt[i]*i)。</p>
<p>答案为dp[n]。</p>
<p>（DP苦手啊。。</p>
<p>本来可以一遍过的。。</p>
<p>结果没考虑数据范围，卡了我半个多小时。。</p>
<p>一定要注意啊啊啊</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,m=<span class="number">-1e9</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> a;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">		cnt[a]++;</span><br><span class="line">		m = <span class="built_in">max</span>(m, a);</span><br><span class="line">	&#125;</span><br><span class="line">	dp[<span class="number">1</span>] = cnt[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">2</span>; i &lt;= m; i++) &#123;</span><br><span class="line">		dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">2</span>] + cnt[i] * i, dp[i - <span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; dp[m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-466C Number of Ways 题解</title>
    <url>/2020/07/14/CF-466C-Number-of-Ways-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforces.com/problemset/problem/466/C" target="_blank" rel="noopener">题目大意</a></h3><p>给你n个数，问你有多少种方式将其分为大小相同的三份$[l,i],[i,j],[j,r]$。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>之前写这个题目的时候完全没有思路。</p>
<p>比完一看题解。。。这个方法是真的妙。</p>
<p>我们可以先用前缀和，然后从一开始暴力枚举。</p>
<p>当枚举的前面部分的和为总和的三分之二时，则后面部分则必为总和的三分之一，这时只需要加上前面的和为总和三分之一的个数即可。</p>
<p>当枚举的前面的部分为总和的三分之一的时候，只需要统计个数。</p>
<p>需要注意这两条语句的个数，为三分之一的时候必须要在后面，不然会重复统计。</p>
<p>数据有点大，注意开ll。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll sum[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> a;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">		sum[i] = sum[i - <span class="number">1</span>] + a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (sum[n] % <span class="number">3</span> != <span class="number">0</span> || n &lt; <span class="number">3</span>) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	ll ans, c;</span><br><span class="line">	ans = c = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (sum[i] == sum[n] / <span class="number">3</span> * <span class="number">2</span>)	ans += c;</span><br><span class="line">		<span class="keyword">if</span> (sum[i] == sum[n] / <span class="number">3</span>)	c++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-706C Hard problem 题解</title>
    <url>/2020/09/15/CF-706C-Hard-problem-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforces.com/problemset/problem/706/C" target="_blank" rel="noopener">题目大意</a></h3><p>给你n个字符串，每个字符串可以反转，反转需要$c_i$的花费，求使这n个字符串呈升序所花费的最小花费。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>刚开始没想到是dp。</p>
<p>后面想到了倒是很简单写完了。</p>
<p>发现wa在了61。。</p>
<p>后面卡了好久，去cf看了看样例。</p>
<p>发现有个判断没判断到。</p>
<p>吐了。。</p>
<p>发现还是自己的思维不够全面。</p>
<p>因为有可能前面那一项需要反转，但是你只能比前一项不反转大，这个时候是不行的。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="built_in">string</span> s[N], f[N];</span><br><span class="line">ll cost[N];</span><br><span class="line">ll dp[N][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)	<span class="built_in">cin</span> &gt;&gt; cost[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; s[i];</span><br><span class="line">		dp[i][<span class="number">1</span>] = dp[i][<span class="number">0</span>] = INF;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = s[i].length() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)	f[i] += s[i][j];</span><br><span class="line">	&#125;</span><br><span class="line">	dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>; dp[<span class="number">1</span>][<span class="number">1</span>] = cost[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">max</span>(s[i], f[i]) &lt; <span class="built_in">min</span>(s[i - <span class="number">1</span>], f[i - <span class="number">1</span>])) &#123;<span class="comment">//就是这个判断</span></span><br><span class="line">			flag = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (s[i] &gt;= s[i - <span class="number">1</span>])	dp[i][<span class="number">0</span>] = <span class="built_in">min</span>(dp[i][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">if</span> (s[i] &gt;= f[i - <span class="number">1</span>])	dp[i][<span class="number">0</span>] = <span class="built_in">min</span>(dp[i][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">if</span> (f[i] &gt;= s[i - <span class="number">1</span>])	dp[i][<span class="number">1</span>] = <span class="built_in">min</span>(dp[i][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + cost[i]);</span><br><span class="line">		<span class="keyword">if</span> (f[i] &gt;= f[i - <span class="number">1</span>])	dp[i][<span class="number">1</span>] = <span class="built_in">min</span>(dp[i][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + cost[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">min</span>(dp[n][<span class="number">0</span>], dp[n][<span class="number">1</span>]) != INF)	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">min</span>(dp[n][<span class="number">0</span>], dp[n][<span class="number">1</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-484A Bits 题解</title>
    <url>/2020/07/15/CF-484A-Bits-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforces.com/problemset/problem/484/A" target="_blank" rel="noopener">题目大意</a></h3><p>给你一个范围$[l,r]$，问在这个范围中二进制中1最多且最小的数是什么。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>想了几种方法都是错的。。</p>
<p>想到了可以用全是1的数来计算。</p>
<p>但是没想到这个方法。。</p>
<p>感觉写题就总是抓不住那重要的一点。。</p>
<p>不过写题还是有好处，确实位运算不是很熟悉。</p>
<p>暴露了很多自己的弱点。</p>
<p>先假设一个全是1的数，如果这个数在范围中，那么这个数就是答案。</p>
<p>如果把第i位换成0，这个数会小于l，则这一位是不能换的。</p>
<p>否则就将这一位换成0。</p>
<p>这个方法真的好妙啊。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		ll l, r;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">		ll ans = (<span class="number">1L</span>L &lt;&lt; <span class="number">63</span>) - <span class="number">1L</span>L;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">62</span>; ~i; i--) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ans &gt;= l &amp;&amp; ans &lt;= r)	<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">if</span> ((ans ^ (<span class="number">1L</span>L &lt;&lt; i)) &lt; l)	<span class="keyword">continue</span>;</span><br><span class="line">			ans ^= (<span class="number">1L</span>L &lt;&lt; i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>CF 888D Almost Identity Permutations 题解</title>
    <url>/2020/07/08/CF-888D-Almost-Identity-Permutations-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://codeforces.com/problemset/problem/888/D" target="_blank" rel="noopener">题目大意</a></h3><p>将n封信件的信和信封全部打乱之后，至少有n-k封信装在了原来的信封里的情况有多少？</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>一看题意觉得不难，就是计算不同的排列种类。</p>
<p>后来发现。。</p>
<p>我不会算啊。</p>
<p>其实因为数据不大，所以可以手推有多少种差排方式。</p>
<p>但是为了以后留下知识漏洞，这里补一下差排公式。</p>
<p>设$D(i)$为$i$个数的差排种类数量，$D(1)=0$,$D(2) = 1$。<br>$$<br>D(i)=(n-1)*(D(n-1)+D(n-2))<br>$$<br><a href="https://blog.csdn.net/bengshakalakaka/article/details/83420150" target="_blank" rel="noopener">推导过程</a>由此去。</p>
<p>知道错排公式就很简单了。</p>
<blockquote>
<p>有1个信封错排时，答案为$1$。</p>
<p>有2个信封错排时，答案为$1*C_n^2$。</p>
<p>有3个信封错排时，答案为$2*C_n^3$。</p>
<p>有4个信封错排时，答案为$9*C_n^4$。</p>
</blockquote>
<p>因为是至少$n-k$个，所以累加即可。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> n, k;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line">	<span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">		ans = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (k == <span class="number">2</span>) &#123;</span><br><span class="line">		ans = <span class="number">1</span> + (n * (n - <span class="number">1</span>)) / <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (k == <span class="number">3</span>) &#123;</span><br><span class="line">		ans = <span class="number">1</span> + (n * (n - <span class="number">1</span>)) / <span class="number">2</span> + (n * (n - <span class="number">1</span>) * (n - <span class="number">2</span>)) / <span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (k == <span class="number">4</span>) &#123;</span><br><span class="line">		ans = <span class="number">1</span> + (n * (n - <span class="number">1</span>)) / <span class="number">2</span> + (n * (n - <span class="number">1</span>) * (n - <span class="number">2</span>)) / <span class="number">3</span> + (<span class="number">9</span> * n * (n - <span class="number">1</span>) * (n - <span class="number">2</span>) * (n - <span class="number">3</span>)) / <span class="number">24</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>公式</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-636E Weights Distributing 题解</title>
    <url>/2020/07/08/CF-636E-Weights-Distributing-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforces.ml/problemset/problem/1343/E" target="_blank" rel="noopener">题目大意</a></h3><p>给你一个n个点m条边的无向图，同时给你每条边的权值，你需要从a到b再到c，问你如何安排权值，使路径最短，求最短路径。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>可以分为两种情况</p>
<blockquote>
<p>第一种情况，a，b，c之间没有重复，a-&gt;b-&gt;c。</p>
<p>第二种情况，a，b，c之间有重复的点，a-&gt;x-&gt;b-&gt;x-&gt;c。</p>
</blockquote>
<p>其实两种情况是一样的，无论有没有重复的点，都可以使用第二种情况。</p>
<p>可以使用三个数组dis1[i]，dis2[i]，dis3[i]，分别来表示a，b，c到i节点最少需要走多少条边。</p>
<p>这样，这个题目就转变成了一个BFS的题目。</p>
<p>（搜索是真的不会，。。多练。。</p>
<p>将边权值从小到大排序后，可以使用前缀和，优化计算。</p>
<p>使用贪心的思想，因为b那段距离需要走两遍，所以优先给他最小的距离。</p>
<p>答案为num[dis1[i]+dis2[i]+dis3[i]]+num[dis2[i]]的最小值。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span>  vis[N], dis1[N], dis2[N], dis3[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> num[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> dis[])</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">	q.push(node);</span><br><span class="line">	vis[node] = <span class="number">1</span>;</span><br><span class="line">	dis[node] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		<span class="keyword">int</span> n = q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> x : v[n]) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!vis[x]) &#123;</span><br><span class="line">				q.push(x);</span><br><span class="line">				vis[x] = <span class="number">1</span>;</span><br><span class="line">				dis[x] = dis[n] + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n, m, a, b, c;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)	v[i].<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)	<span class="built_in">cin</span>&gt;&gt;num[i];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> l, r;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">			v[l].push_back(r);</span><br><span class="line">			v[r].push_back(l);</span><br><span class="line">		&#125;</span><br><span class="line">		sort(num + <span class="number">1</span>, num + <span class="number">1</span> + m);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)	num[i] += num[i - <span class="number">1</span>];<span class="comment">//前缀和</span></span><br><span class="line">		bfs(a, dis1);</span><br><span class="line">		bfs(b, dis2);</span><br><span class="line">		bfs(c, dis3);</span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1e18</span>;<span class="comment">//需要开long long，数据有点大		</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (dis1[i] + dis2[i] + dis3[i] &gt; m)	<span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//如果需要走的边数大于m，直接continue</span></span><br><span class="line">			ans = <span class="built_in">min</span>(ans, num[dis1[i] + dis2[i] + dis3[i]] + num[dis2[i]]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-735D Taxes 题解</title>
    <url>/2020/11/08/CF-735D-Taxes-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你一个数，对于这个数n你需要付出的代价是自身的最大的非本身因子$（n\ge 2)$，你可以将这个数拆成任何多的整数，求所需的最小代价。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这题需要用到哥德巴赫猜想。</p>
<p>哥德巴赫猜想：任意一个大于4的偶数，都可以分解为两个奇质数的和。</p>
<p>首先判断是不是质数，是质数就输出1。</p>
<p>之后判断是不是偶数，是偶数就输出2。</p>
<p>如果还不是偶数的话，就可以把这个数拆成2+（n-2），还需要判断这个（n-2）是不是质数，如果是答案为2，否则答案为4。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for (ll i=a;i&lt;=n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,n) for (ll i=n;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(x,y) make_pair(x,y)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bg begin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rbg rbegin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ed end</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dbg(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">"==="</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> prime[N], cnt;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)	ans *= a;</span><br><span class="line">		a &lt;&lt;= <span class="number">1</span>, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	rep(i, <span class="number">2</span>, <span class="built_in">sqrt</span>(n)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n % i==<span class="number">0</span>)	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\in.txt", "r", stdin);</span></span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\out.txt", "w+", stdout);</span></span><br><span class="line">	<span class="keyword">int</span> n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">if</span> (check(n))	<span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> ((n&amp;<span class="number">1</span>)==<span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (check(n - <span class="number">2</span>))	<span class="built_in">cout</span> &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="number">3</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-6E Exposition 题解</title>
    <url>/2020/11/30/CF-6E-Exposition-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforces.com/problemset/problem/6/E" target="_blank" rel="noopener">题目大意</a></h3><p>给定一个长度为n的数组，请在之中挑出最长的子数组，要求子数组中元素差的最大值不超过k。问有几个最长子数组，最长子数组的长度，以及这几个子数组的开始点、尾点。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>刚开始看到这题，就想着这个区间的最大值和最小值不好维护。</p>
<p>想了一下，看了眼题解，发现怎么可以这么暴力。。</p>
<p>（好像还有什么线段树，RMQ的解法，那些都不会啊</p>
<p>维护区间最大值只需要用multiset就可以了。</p>
<p>剩下的就是尺取了。</p>
<p>具体看代码。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for (ll i=a;i&lt;=n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,n) for (ll i=a;i&gt;=n;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bg begin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rbg rbegin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ed end</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dbg(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">"==="</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> num[N];</span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)	ans *= a;</span><br><span class="line">		a &lt;&lt;= <span class="number">1</span>, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\in.txt", "r", stdin);</span></span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\out.txt", "w+", stdout);</span></span><br><span class="line">	<span class="keyword">int</span> n, k; <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	ll len = <span class="number">1</span>;</span><br><span class="line">	rep(i, <span class="number">1</span>, n)	<span class="built_in">cin</span> &gt;&gt; num[i];</span><br><span class="line">	ll l, r;</span><br><span class="line">	l = r = <span class="number">1</span>;</span><br><span class="line">	s.insert(num[<span class="number">1</span>]);</span><br><span class="line">	v.push_back(&#123; <span class="number">1</span>,<span class="number">1</span> &#125;);</span><br><span class="line">	<span class="keyword">while</span> (r &lt; n) &#123;</span><br><span class="line">		r++; s.insert(num[r]);</span><br><span class="line">		<span class="keyword">while</span> (*s.rbg() - *s.<span class="built_in">begin</span>() &gt; k &amp;&amp; !s.empty()) &#123;</span><br><span class="line">			s.erase(s.<span class="built_in">find</span>(num[l]));</span><br><span class="line">			l++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (r - l + <span class="number">1</span> &gt; len) &#123;</span><br><span class="line">			v.<span class="built_in">clear</span>();</span><br><span class="line">			len = r - l + <span class="number">1</span>;</span><br><span class="line">			v.push_back(&#123; l,r &#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (r - l + <span class="number">1</span> == len)	v.push_back(&#123; l,r &#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; len &lt;&lt; <span class="string">' '</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> x : v) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; x.first &lt;&lt; <span class="string">' '</span> &lt;&lt; x.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-816B Karen and Coffee 题解</title>
    <url>/2020/11/07/CF-816B-Karen-and-Coffee-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforces.com/problemset/problem/816/B" target="_blank" rel="noopener">题目大意</a></h3><p>给你n个范围，给你q个能力值范围，问在能力值范围中，有多少个能力是满足至少满足k个范围的。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>首先用差分，求出每个能力能够满足多少个范围。</p>
<p>之后刚开始用的暴力写的，直接超时了。。。</p>
<p>后面发现可以在遍历一遍，将满足条件的点用1标记，再跑一遍前缀和即可。</p>
<p>之前还真没写过跑两遍前缀和的题目。</p>
<p>学到了。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for (ll i=a;i&lt;=n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,n) for (ll i=n;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(x,y) make_pair(x,y)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bg begin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rbg rbegin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ed end</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dbg(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">"==="</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> sum[N], ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)	ans *= a;</span><br><span class="line">		a &lt;&lt;= <span class="number">1</span>, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\in.txt", "r", stdin);</span></span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\out.txt", "w+", stdout);</span></span><br><span class="line">	<span class="keyword">int</span> m, k, q; <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; k &gt;&gt; q;</span><br><span class="line">	<span class="keyword">int</span> L = <span class="number">1e9</span>, R = <span class="number">-1e9</span>;</span><br><span class="line">	rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">		<span class="keyword">int</span> l, r; <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">		sum[l]++, sum[r + <span class="number">1</span>]--;</span><br><span class="line">		L = <span class="built_in">min</span>(L, l), R = <span class="built_in">max</span>(R, r);</span><br><span class="line">	&#125;</span><br><span class="line">	rep(i, <span class="number">1</span>, <span class="number">2e5</span>+<span class="number">5</span>) &#123;</span><br><span class="line">		sum[i] += sum[i - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span> (sum[i] &gt;= k)	ans[i]++;</span><br><span class="line">	&#125;</span><br><span class="line">	rep(i, <span class="number">1</span>, <span class="number">2e5</span>+<span class="number">5</span>) &#123;</span><br><span class="line">		ans[i] += ans[i - <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	rep(i, <span class="number">1</span>, q) &#123;</span><br><span class="line">		<span class="keyword">int</span> l, r; <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans[r] - ans[l - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-986B Petr and Permutations 题解</title>
    <url>/2020/09/27/CF-986B-Petr-and-Permutations-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforces.com/problemset/problem/986/B" target="_blank" rel="noopener">题目大意</a></h3><p>原本有一个1~n按照大小排列的序列，有两个人会交换他，P会交换$3n$次，U会交换$7n+1$次，给你交换后的数组，问是谁交换的。</p>
<p>每对数字只能被交换一次。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这题是和富哥一起讨论的，主要是他得出的思路，我是被带的。。</p>
<p>所以还是写个题解吧。</p>
<p>前排提示，这个思路虽然过了，但是正确性没有证明。</p>
<p>按照他给的交换后的排序，我们先考虑把这个序列交换回原来的序列，并记录次数。</p>
<p>因为这个序列是按照步骤最少的交换来还原的，所以这个次数肯定比他们所交换的次数要少。</p>
<p>但是可以将剩下的次数理解为是让他们两两交换，并且使交换后的序列仍然是完好的。</p>
<p>这个交换的次数肯定是偶数。</p>
<p>所以当n与cnt奇偶的时候，必定是P交换的。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> num[N],pos[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; num[i];</span><br><span class="line">		pos[num[i]] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	ll cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (pos[i] != i) &#123;</span><br><span class="line">			swap(num[i], num[pos[i]]);</span><br><span class="line">			swap(pos[i], pos[num[pos[i]]]);</span><br><span class="line">			cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((cnt &amp; <span class="number">1</span>) == (n &amp; <span class="number">1</span>))	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Petr"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"Um_nik"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-919D Substring 题解</title>
    <url>/2020/07/15/CF-919D-Substring-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你一个n个点，m条边的有向图，给你一个字符串，分别代表每一个点的值，定义一个路的大小为这个路上出现的最多的字母个数，问这个图的最大值是否可以无限大，可以则输出-1，否则求这个图中所有路中的最大值。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这个题目还是有点难度的。</p>
<p>其实一开始是想到了需要用拓扑排序来判环，但是不知道如何求出最大路。</p>
<p>刚开始写的时候是理解成了最长路，后来发现不一定是最长的。</p>
<p>想了半天，都没想到dp的状态是咋写。</p>
<p>还是dp的题目写的不够多啊。 </p>
<p>后面还是学长指点了我一下，就大致懂了。</p>
<p>可以用$dp[i][j]$来表示第i个点，字母j的最多的数量。</p>
<p>这样，在拓扑排序的过程中不断更新，最后枚举出最大值即可。</p>
<p>这个题目的解法还是很妙啊。</p>
<p>需要注意，只有起点需要初始化。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;Map[N];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> in[N];</span><br><span class="line"><span class="keyword">int</span> dp[N][<span class="number">200</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="built_in">string</span> s;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> a, b;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">		Map[a].push_back(b);</span><br><span class="line">		in[b]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!in[i]) &#123;</span><br><span class="line">			q.push(i);</span><br><span class="line">			dp[i][s[i<span class="number">-1</span>]]++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> t = q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		c++;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> x : Map[t]) &#123;</span><br><span class="line">			in[x]--;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="string">'a'</span>; i &lt;= <span class="string">'z'</span>; i++)</span><br><span class="line">				dp[x][i] = <span class="built_in">max</span>(dp[x][i], dp[t][i]+(<span class="keyword">int</span>)(s[x<span class="number">-1</span>]==i));</span><br><span class="line">			<span class="keyword">if</span> (!in[x])	q.push(x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="string">'a'</span>; j &lt;= <span class="string">'z'</span>; j++)</span><br><span class="line">			ans = <span class="built_in">max</span>(ans, dp[i][j]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (c == n)	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>CFR-634E Restorer Distance 题解</title>
    <url>/2020/07/08/CFR-634E-Restorer-Distance-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforc.es/contest/1355/problem/E" target="_blank" rel="noopener">题目大意</a></h3><p>给你n个墙壁的高度，你可以花a块钱让墙壁高度减一，也可以花r块钱让墙壁高度减一，还可以花m块钱让高的墙壁转移一个高度给矮的墙壁，问你让墙壁的高度全都相等所花费的最小代价为多少。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>看到题目就知道是我不会写的题目。。</p>
<p>（其实之前是听过三分的，但是没有去学过。。</p>
<p>刚好补题的时候去学一下三分。</p>
<p>三分其实和二分很相似，都是将一块区间分隔开来，二分是分成两份，三分是分成三份，通过一步步排除区间来缩小时间复杂度。</p>
<p>但是二分适用于单调函数，三分适用于二次函数，可以用来求出二次函数的最值。</p>
<p>对于三分来说，凹函数和凸函数的情况是不一样的。</p>
<p>那对于这个题目来说，我们可以用三分来搜索某一个高度来使其他的墙等于这个高度的代价最小，很显然，这个关于h的函数是一个凹函数。</p>
<p>在计算花费时，我们可以先算出添加的数量和减少的数量，如果$m&lt;a+r$，那么肯定优先选择m，然后剩下的乘以a或者r。</p>
<p>否则直接按照a和r来计算。</p>
<p><a href="https://www.cnblogs.com/lukelmouse/p/12545973.html" target="_blank" rel="noopener">三分模板</a></p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> h[N],n,a,R,m;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">check</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">	ll add, minu, ans;</span><br><span class="line">	add = minu = ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (t &gt;= h[i])	add += t - h[i];<span class="comment">//需要添加的数量</span></span><br><span class="line">		<span class="keyword">else</span> minu += h[i] - t;<span class="comment">//需要减小的数量</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (m &lt; a + R) &#123;</span><br><span class="line">		ll x = <span class="built_in">min</span>(add, minu);</span><br><span class="line">		ans += x * m;</span><br><span class="line">		<span class="keyword">if</span> (add &gt;= minu)	ans += a * (add - x);</span><br><span class="line">		<span class="keyword">else</span> ans += R * (minu - x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> ans += add * a + minu * R;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; a &gt;&gt; R &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)	<span class="built_in">cin</span> &gt;&gt; h[i],r = <span class="built_in">max</span>(r,h[i]);<span class="comment">//区间的最大值为高度的最大值</span></span><br><span class="line">	<span class="keyword">while</span> (l &lt; r) &#123;<span class="comment">//l==r的时候退出</span></span><br><span class="line">		<span class="keyword">int</span> mid1 = l + (r - l) / <span class="number">3</span>, mid2 = r - (r - l) / <span class="number">3</span>;</span><br><span class="line">		<span class="keyword">if</span> (check(mid1) &gt;= check(mid2))	l = mid1 + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> r = mid2 - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; check(l) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>三分</tag>
      </tags>
  </entry>
  <entry>
    <title>CFR-643C Count Triangles 题解</title>
    <url>/2020/07/08/CFR-643C-Count-Triangles-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforc.es/contest/1355/problem/C" target="_blank" rel="noopener">题目大意</a></h3><p>给你四个数字$A,B,C,D$，$A≤x≤B≤y≤C≤z≤D$，其中$x,y,z$为三角形的三边，问$xyz$能够严格构成的三角形有多少个。（三顶点不共线）</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这次比赛就离谱，C题1800，D题1400。。</p>
<p>因为数据范围为$5·10^5$，所以复杂度尽量要控制在$O(n)$左右。</p>
<p>我们可以枚举x，$x∈[A,B]，y∈[B,C]$，将x作为常数，那么z的最大值范围为$[B-x-1,C-x-1]$。</p>
<p>分情况讨论</p>
<p>当$B-x-1≥D$时，显然y取任何值，z都是满足要求的。</p>
<blockquote>
<p>$ans =  (C-B+1)*(zr-zl+1)$</p>
</blockquote>
<p>当$B-x-1&lt;D$时，我们可以分为两部分来计算</p>
<p>1、在$[C,D]$中的部分，令$l = max(zl,C),r = min(zr,D)$。</p>
<p>在其中的部分，构成了一个以$l-C+1$为首项，$r-C+1$为末项的一个公差为1的等差数列，所以我们可以用等差数列求和公式来求和。</p>
<blockquote>
<p>$ans = (r-l+1)*(l-C+1+r-C+1)/2$</p>
</blockquote>
<p>2、在$[D+1,zr]$的部分</p>
<blockquote>
<p>$ans = (zr-D)*(D-C+1)$</p>
</blockquote>
<p>（哇。。这种数学题对我来说是真的苦手，数论咋办啊。。</p>
<p>区间问题一般都能杀我。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	ll A, B, C, D;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; A &gt;&gt; B &gt;&gt; C &gt;&gt; D;</span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> x = A; x &lt;= B; x++) &#123;</span><br><span class="line">		ll zl = x + B - <span class="number">1</span>, zr = x + C - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (zl &gt;= D)	ans += (D - C + <span class="number">1</span>) * (C - B + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			ll l = <span class="built_in">max</span>(zl, C), r = <span class="built_in">min</span>(zr, D);</span><br><span class="line">			ans += (r - l + <span class="number">1</span>) * (l - C + <span class="number">1</span> + r - C + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span> (zr &gt; D)	ans += (zr - D) * (D - C + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-987C Three displays 题解</title>
    <url>/2020/11/19/CF-987C-Three-displays-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforces.com/problemset/problem/987/C" target="_blank" rel="noopener">题目大意</a></h3><p>给你一个长度为n的整数序列a[1..n].</p>
<p>以及一个长度为n的整数序列b[1..n].</p>
<p>现在,要求你选择三个正整数i,j,k(1&lt;=i&lt; j&lt; k&lt;=n).</p>
<p>使得a[i]&lt; a[j]&lt; a[k]且b[i]+b[j]+b[k]的值最小.</p>
<p>输出满足要求的b[i]+b[j]+b[k]的最小值。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>刚开始想的是暴力，但是没想到好的方法暴力。</p>
<p>（脑子真不好使。。</p>
<p>可以暴力$n^2$维护每个点大于他的最小值，之后在$n^2$枚举求解即可。</p>
<p>但是发现可以dp写就dp写吧。</p>
<p>这个dp思路好妙啊。</p>
<p>用dp[i] [x]表示x作为选取的第i的数字的最小值。</p>
<p>状态转移方程为$dp[i] [x] = min(dp[i-1] [x]+j,dp[i] [x])$</p>
<p>只需要$n^2$即可。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for (ll i=a;i&lt;=n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,n) for (ll i=n;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(x,y) make_pair(x,y)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bg begin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rbg rbegin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ed end</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dbg(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">"==="</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> s[<span class="number">3030</span>], c[<span class="number">3030</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">5</span>][<span class="number">3030</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)	ans *= a;</span><br><span class="line">		a &lt;&lt;= <span class="number">1</span>, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\in.txt", "r", stdin);</span></span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\out.txt", "w+", stdout);</span></span><br><span class="line">	<span class="keyword">int</span> n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	rep(i, <span class="number">1</span>, n)	<span class="built_in">cin</span> &gt;&gt; s[i];</span><br><span class="line">	rep(i, <span class="number">1</span>, n)	<span class="built_in">cin</span> &gt;&gt; c[i];</span><br><span class="line">	rep(i, <span class="number">1</span>, <span class="number">3</span>) &#123;</span><br><span class="line">		rep(j, <span class="number">1</span>, n)	dp[i][j] = INF;</span><br><span class="line">	&#125;</span><br><span class="line">	rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">		dp[<span class="number">1</span>][i] = c[i];</span><br><span class="line">		rep(j, <span class="number">2</span>, <span class="number">3</span>) &#123;</span><br><span class="line">			rep(k, <span class="number">1</span>, i - <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (s[k] &lt; s[i])	dp[j][i] = <span class="built_in">min</span>(dp[j][i], c[i] + dp[j - <span class="number">1</span>][k]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans = INF;</span><br><span class="line">	rep(i, <span class="number">1</span>, n)	ans = <span class="built_in">min</span>(ans, dp[<span class="number">3</span>][i]);</span><br><span class="line">	<span class="keyword">if</span> (ans == INF)	<span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>CF-992B Nastya Studies Informatics 题解</title>
    <url>/2020/07/14/CF-992B-Nastya-Studies-Informatics-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforces.com/problemset/problem/992/B?f0a28=1" target="_blank" rel="noopener">题目大意</a></h3><p>给你一个区间$[l,r]$，求其中有多少点对$(a,b)$，满足$gcd(a,b)=x,lcm(a,b)=y$。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>说实话，刚开始看到这个题目的时候，觉得这个题目应该不难。</p>
<p>wa了几发之后，人都傻了。</p>
<p>不过还是给我磨过去了，没有看题解。</p>
<p>说实话，我一直都有这种写不出看题解的习惯。</p>
<p>真的不好，但是还是有点难改。。</p>
<p>最近真的注意力不集中。。烦死了</p>
<p>写题也写不出来。</p>
<p>究极自闭。</p>
<p>首先，我们可以根据$a\times b=x\times y$这个性质，可以枚举a来确定b，这时只需要判断是否满足条件即可。</p>
<p>但是这个枚举，我之前就是从l枚举到r，当b&lt;a的时候推出，超时了。。</p>
<p>后来想到，a可以是x的倍数，然后就按照倍数枚举，就过了。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll l, r, x, y;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r &gt;&gt; x &gt;&gt; y;</span><br><span class="line">	ll mul = x * y, cnt = <span class="number">0</span>;</span><br><span class="line">	ll a = x, b;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; a &lt;= r; i++) &#123;</span><br><span class="line">		a = x * i;</span><br><span class="line">		b = mul / a;</span><br><span class="line">		<span class="keyword">if</span> (b &lt; a)	<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (a &gt;= l &amp;&amp; a &lt;= r &amp;&amp; b &gt;= l &amp;&amp; b &lt;= r &amp;&amp; b * a == mul &amp;&amp; gcd(b, a) == x) &#123;</span><br><span class="line">			<span class="keyword">if</span> (a == b)	cnt++;</span><br><span class="line">			<span class="keyword">else</span> cnt += <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>CFR-644D Buying Shovels 题解</title>
    <url>/2020/07/08/CFR-644D-Buying-Shovels%20%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforc.es/contest/1360/problem/D" target="_blank" rel="noopener">题目大意</a></h3><p> 你需要买n个东西，给你k个数$1-K$,代表你能一次买k个，你需要选择一个数，且只能选择一个数，让次数最少。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>服了。。</p>
<p>写的时候真的觉得自己可能是智障。。</p>
<p>愣是卡死在这个题目了。</p>
<p>明明纯暴力水题。。</p>
<p>吐了。</p>
<p>（还是自己太菜了。。哭</p>
<p>对于n来说，假设存在某个数i，能使n整除i，那么代价就是$min(i,n/i)$。</p>
<p>那么我只需要找到最小的i即可。</p>
<p>遍历的范围只需要从1到sqrt(n)即可。</p>
<p>注意还要考虑另一边。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n % i == <span class="number">0</span>)	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n, k;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">		<span class="keyword">if</span> (k &gt;= n) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> ans = n;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i*i&lt;=n; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (n / i &lt;= k) &#123;</span><br><span class="line">					ans = <span class="built_in">min</span>(ans,i);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (i &lt;= k) &#123;</span><br><span class="line">					ans = <span class="built_in">min</span>(ans, n / i);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title>CFR-679D Shurikens 题解</title>
    <url>/2020/10/26/CFR-679-Shurikens-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforces.com/contest/1434/problem/B" target="_blank" rel="noopener">题目大意</a></h3><p>你经营这一个商店，商店中有1~n，n个物品，给你一个账单 ，加代表你放了一个货在货架上，减代表</p>
<p>你卖出当前货架上序号最小的物品，并且告诉你他的序号，问这个账单是否成立，成立则输出任何一个上货的顺序。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这场简直有毒，D题比C题容易多了。</p>
<p>说实话，这题很有意思。</p>
<p>首先，你正着来模拟很麻烦，不好模拟。</p>
<p>于是可以倒过来模拟，减就是入栈，加就是出栈，每次输出栈顶，维护栈中最小值即可。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;v;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">int</span> cnt0, cnt1;</span><br><span class="line">	cnt0 = cnt1 = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">string</span> s;</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">while</span> (cnt0 != n || cnt1 != n) &#123;</span><br><span class="line">		getline(<span class="built_in">cin</span>, s);</span><br><span class="line">		<span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'+'</span>)	cnt0++;</span><br><span class="line">		<span class="keyword">else</span> cnt1++;</span><br><span class="line">		v.push_back(s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> m = <span class="number">1e9</span>, flag = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = v.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="keyword">if</span> (v[i][<span class="number">0</span>] == <span class="string">'-'</span>) &#123;</span><br><span class="line">			<span class="built_in">string</span> t;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; v[i].length(); j++) t += v[i][j];</span><br><span class="line">			st.push(stoi(t)), m = <span class="built_in">min</span>(m, stoi(t));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (st.empty()) &#123;</span><br><span class="line">				flag = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">int</span> t = st.top(); st.pop();</span><br><span class="line">			ans.push(t);</span><br><span class="line">			<span class="keyword">if</span> (!st.empty())	m = st.top();</span><br><span class="line">			<span class="keyword">else</span> m = <span class="number">1e9</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!st.empty()&amp;&amp;m != st.top()) &#123;</span><br><span class="line">			flag = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (flag) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">while</span> (!ans.empty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> t = ans.top(); ans.pop();</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; t &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>CFR-685D Circle Game 题解</title>
    <url>/2020/11/23/CFR-685D-Circle-Game-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforces.com/contest/1451/problem/D" target="_blank" rel="noopener">题目大意</a></h3><p>给你一个圆形的区域，你从零点出发，每次可以向右走k，或者向上走k，谁先走出这个区域就算输。问先手赢还是后手赢。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>后手能保证一定是按照斜线走的，即一右一上。</p>
<p>因为无法保证后手一定能走到他的必胜点，但是一定能按斜线走出去。</p>
<p>所以只需要判断按照斜线走出去的步数是奇还是偶即可。</p>
<p>偶数则先手胜。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for (ll i=a;i&lt;=n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,n) for (ll i=n;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(x,y) make_pair(x,y)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bg begin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rbg rbegin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ed end</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dbg(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">"==="</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)	ans *= a;</span><br><span class="line">		a &lt;&lt;= <span class="number">1</span>, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\in.txt", "r", stdin);</span></span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\out.txt", "w+", stdout);</span></span><br><span class="line">	<span class="keyword">int</span> t; <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		ll d, k; <span class="built_in">cin</span> &gt;&gt; d &gt;&gt; k;</span><br><span class="line">		ll p = <span class="number">0</span>, q = <span class="number">0</span>;</span><br><span class="line">		ll cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (cnt % <span class="number">2</span> == <span class="number">0</span>)	p += k;</span><br><span class="line">			<span class="keyword">else</span>   q += k;</span><br><span class="line">			cnt++;</span><br><span class="line">			<span class="keyword">if</span> (p * p + q * q &gt; d * d) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (cnt % <span class="number">2</span> == <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"Ashish"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"Utkarsh"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title>CFR-644F Spy-string 题解</title>
    <url>/2020/07/08/CFR-644F-Spy-string-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforc.es/contest/1360/problem/F" target="_blank" rel="noopener">题目大意</a></h3><p>给你n个长度为m的字符串，问你能否找到一个字符串，使这个字符串与每个字符串最多只有一位不同。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>其实一开始想到了暴力。</p>
<p>这个数据这么小，肯定可以暴力。</p>
<p>刚开始想着以第一个字符串为基准，去判断其他的字符串。 </p>
<p>结果错误的计算了时间复杂度，以为会TLE，就卡住了。。</p>
<p>刚好也没时间了。</p>
<p>（还是写的慢了。。</p>
<p>我们以第一个字符串为基准，更改它的每一位，这样最多也就与第一个字符串有一位不同。</p>
<p>再去判断除了第一个字符串以外的字符串是否不同的位数超过2位。</p>
<p>如果超过两位，就不行，重新枚举。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> Map[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (Map[i][j] != Map[<span class="number">1</span>][j])	cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (cnt &gt; <span class="number">1</span>)	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)	<span class="built_in">cin</span> &gt;&gt; Map[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">			<span class="keyword">char</span> t = Map[<span class="number">1</span>][i];</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">char</span> j = <span class="string">'a'</span>; j &lt;= <span class="string">'z'</span>; j++) &#123;</span><br><span class="line">				Map[<span class="number">1</span>][i] = j;</span><br><span class="line">				<span class="keyword">if</span> (check()) &#123;</span><br><span class="line">					flag = <span class="number">1</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (flag == <span class="number">1</span>)	<span class="keyword">break</span>;</span><br><span class="line">			Map[<span class="number">1</span>][i] = t;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (flag) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)	<span class="built_in">cout</span> &lt;&lt; Map[<span class="number">1</span>][i];</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>暴力</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>CFR-644G A/B Matrix 题解</title>
    <url>/2020/07/08/CFR-644G-AB-Matrix-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforc.es/contest/1360/problem/G" target="_blank" rel="noopener">题目大意</a></h3><p>给你一个n*m的矩阵，初始都为0，需要满足每一行有a个1，每一列有b个1，问你这个矩阵是否存在。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>很明显，1的数量等于$n\times a$,也等于$m\times b$。</p>
<p>所以$n\times a==m\times b$。</p>
<p>那么满足这个条件的矩阵一定存在。</p>
<p>剩下的就是需要构造矩阵了。</p>
<p>我们可以以行为单位循环的构造矩阵，使每一列的1的数量平均的增加。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">60</span>],Map[<span class="number">60</span>][<span class="number">60</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n, m, a, b;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; a &gt;&gt; b;</span><br><span class="line">		<span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">		<span class="built_in">memset</span>(Map, <span class="number">0</span>, <span class="keyword">sizeof</span>(Map));</span><br><span class="line">		<span class="keyword">if</span> (n * a != m * b) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> t = a;</span><br><span class="line">			<span class="keyword">for</span> (; j &lt;= m+<span class="number">1</span> &amp;&amp; t; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (j == m + <span class="number">1</span>)	j = <span class="number">1</span>;</span><br><span class="line">				Map[i][j] = <span class="number">1</span>, t--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; Map[i][j];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>暴力</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>CFR-679C Perform Easily 题解</title>
    <url>/2020/11/01/CFR-679C-Perform-Easily-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforces.com/contest/1434/problem/A" target="_blank" rel="noopener">题目大意</a></h3><p>给你六根弦，每个弦有自己的权值，你需要用这六根弦弹出n个音调，可以任意用六根弦的任意一个位置弹奏音调，弹出的音调为这根弦的权值加上你选的位置，即a[i]+pos，问最小的位置极差为多少。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这场比赛太毒了，c题1900。。</p>
<p>感觉这题想到了就不难，他的难点在于最小值和最大值都是固定的。</p>
<p>可以先定住最小值或者最大值，然后使端点值缩减即可。</p>
<p>用一个pair型的set，first为位置，second为所选的弦，刚好set会自动排序，按照pair的first来从小到大排序。</p>
<p>利用这个性质，就可以很好的枚举出最小值，只需要更改端点值即可。</p>
<p>（这个思路真的很妙。。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for (ll i=a;i&lt;=n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,n) for (ll i=n;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(x,y) make_pair(x,y)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bg begin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rbg rbegin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ed end</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dbg(x) cout &lt;&lt; <span class="meta-string">"#x"</span> &lt;&lt; <span class="meta-string">"==="</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)	ans *= a;</span><br><span class="line">		a &lt;&lt;= <span class="number">1</span>, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="built_in">set</span>&lt;pll&gt; s;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>], b[N], id[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\in.txt", "r", stdin);</span></span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\out.txt", "w+", stdout);</span></span><br><span class="line">	rep(i, <span class="number">1</span>, <span class="number">6</span>) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">	sort(a + <span class="number">1</span>, a + <span class="number">7</span>);</span><br><span class="line">	<span class="keyword">int</span> n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	rep(i, <span class="number">1</span>, n)	<span class="built_in">cin</span> &gt;&gt; b[i], id[i] = <span class="number">1</span>;</span><br><span class="line">	sort(b + <span class="number">1</span>, b + <span class="number">1</span> + n);</span><br><span class="line">	rep(i, <span class="number">1</span>, n)	s.insert(&#123; b[i] - a[<span class="number">1</span>],i &#125;);<span class="comment">//定住最大值</span></span><br><span class="line">	ll ans = <span class="number">1e18</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">auto</span> p = --s.<span class="built_in">end</span>();</span><br><span class="line">		ll t = p-&gt;se;</span><br><span class="line">		s.erase(p);</span><br><span class="line">		<span class="keyword">if</span> (id[t] == <span class="number">6</span>)	<span class="keyword">break</span>;</span><br><span class="line">		id[t]++;<span class="comment">//使最大的最小值减小</span></span><br><span class="line">		s.insert(&#123; b[t] - a[id[t]],t &#125;);</span><br><span class="line">		ans = <span class="built_in">min</span>(ans, s.rbg()-&gt;fi - s.bg()-&gt;fi);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>CH-0104 起床困难综合症 题解</title>
    <url>/2020/07/08/CH-0104-%E8%B5%B7%E5%BA%8A%E5%9B%B0%E9%9A%BE%E7%BB%BC%E5%90%88%E7%97%87-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://noi-test.zzstep.com/contest/0x00%E3%80%8C%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95%E3%80%8D%E4%BE%8B%E9%A2%98/0104%20%E8%B5%B7%E5%BA%8A%E5%9B%B0%E9%9A%BE%E7%BB%BC%E5%90%88%E7%97%87" target="_blank" rel="noopener">题目大意</a></h3><p>让你在$[0,m]$中选一个数字，在经过n次位运算之后，（&amp;，|，^），问求出的最大值为多少。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这个题目是蓝书上的原题，最近开始补蓝书了。</p>
<p>如果可以的话，我会尽量把上面比较好，比较经典的题目都会重新写一遍。</p>
<p>这题是一道十分经典的位运算题。</p>
<p>首先，根据位运算的特性，即每一位的运算只与这一位有关，与其他位无关。</p>
<p>那么我们可以用每一位上的1和0来进行比较，判断该位上选0还是1更优。</p>
<p>如果初始为0的运算后能得到1，那么肯定选0。</p>
<p>如果初始为1的运算后能得到1，且得到的值t不会超过m，那么就可以选1。</p>
<p>其余情况都选择0。</p>
<p>遍历的话需要从高位到低位（但是跑出来的话从低到高也是对的，不知道是不是数据太水了。。</p>
<p>假如0的话每一位都是0，假如1的话每一位都是1。</p>
<p>m为1000 0000。</p>
<p>如果逆序的话，你可以得到1000 0000。</p>
<p>如果正序的话，你可以得到0111 1111。</p>
<p>很显然，逆序的值会大一些，所以需要逆序。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="built_in">string</span> s;</span><br><span class="line">	<span class="keyword">int</span> k;</span><br><span class="line">	<span class="keyword">int</span> ans0 = <span class="number">0</span>, ans1 = <span class="number">0x7FFFFFFF</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; s &gt;&gt; k;</span><br><span class="line">		<span class="keyword">if</span> (s == <span class="string">"AND"</span>)	ans0 &amp;= k, ans1 &amp;= k;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="string">"OR"</span>)	ans0 |= k, ans1 |= k;</span><br><span class="line">		<span class="keyword">else</span> ans0 ^= k, ans1 ^= k;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">1</span>; i--) &#123;<span class="comment">//逆序的贡献大一些，所以需要逆序</span></span><br><span class="line">		<span class="keyword">int</span> t = <span class="number">1</span> &lt;&lt; (i<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">if</span> ((ans0&gt;&gt;(i<span class="number">-1</span>)) &amp; <span class="number">1</span>)	ans += t;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ((ans1 &gt;&gt; (i - <span class="number">1</span>)) &amp; <span class="number">1</span> &amp;&amp; m &gt;= t)ans += t, m -= t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>CFR-685E Bitwise Queries 题解</title>
    <url>/2020/11/23/CFR-685E-Bitwise-Queries-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforces.com/problemset/problem/1451/E2" target="_blank" rel="noopener">题目大意</a></h3><p>存在一个长度为n的数组（n为2的幂次），每个数的范围在$[0,n-1]$。现在你可以进行n次询问，询问$a[i]\bigoplus a[j] $，$a[i] &amp;  a[j]$，$a[i]\mid a[j]$的值，需要你输出这个数组。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>人生中做的第一道交互题。</p>
<p>好难啊。</p>
<p>这题目分为简单和困难。</p>
<p>唯一的差别就是一个查询n+2次，一个查询n+1次。</p>
<p>所以这边就只写困难版本的了。</p>
<p>首先我们需要知道一个公式$a+b=a\bigoplus b+2\times(a &amp; b)$。</p>
<p>先用n-1次查询，用异或把1和其他的数连接起来。</p>
<p>并且在查询的时候判断是否存在相同的异或值。</p>
<p>如果存在相同的异或值，那么这两个数肯定相同。</p>
<p>那么只需要让这两个相同的数相与或者想或就可以得出这个数的值，然后再异或$a\bigoplus b$，即可得出a[1]。</p>
<p>如果不存在，那么就可以找到$a\bigoplus b==n+1$，即可得出$a&amp; b==0$。</p>
<p>之后在随便找一个数，三个未知数解方程，即可解出a[1]。</p>
<p>得出a[1]之后，再与之前求出的异或值再异或即可求出每一个数的值。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for (ll i=a;i&lt;=n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,n) for (ll i=n;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(x,y) make_pair(x,y)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bg begin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rbg rbegin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ed end</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dbg(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">"==="</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _xor[<span class="number">1</span> &lt;&lt; <span class="number">17</span>], pos[<span class="number">1</span> &lt;&lt; <span class="number">17</span>], ans[<span class="number">1</span> &lt;&lt; <span class="number">17</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)	ans *= a;</span><br><span class="line">		a &lt;&lt;= <span class="number">1</span>, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">q</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">' '</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span> &lt;&lt; j &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	fflush(<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="keyword">int</span> t; <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\in.txt", "r", stdin);</span></span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\out.txt", "w+", stdout);</span></span><br><span class="line">	<span class="keyword">int</span> n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="built_in">memset</span>(pos, <span class="number">-1</span>, <span class="keyword">sizeof</span>(pos));</span><br><span class="line">	<span class="keyword">int</span> id1 = <span class="number">-1</span>, id2 = <span class="number">-1</span>;</span><br><span class="line">	rep(i, <span class="number">2</span>, n) &#123;</span><br><span class="line">		_xor[i] = q(<span class="string">"XOR"</span>, <span class="number">1</span>, i);</span><br><span class="line">		<span class="keyword">if</span> (pos[_xor[i]] != <span class="number">-1</span>)	id1 = pos[_xor[i]], id2 = i;</span><br><span class="line">		pos[_xor[i]] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (id1 != <span class="number">-1</span>) &#123;</span><br><span class="line">		ans[id1] = ans[id2] = q(<span class="string">"OR"</span>, id1, id2);</span><br><span class="line">		ans[<span class="number">1</span>] = _xor[id1] ^ ans[id1];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		id1 = pos[n - <span class="number">1</span>];</span><br><span class="line">		id2 = id1 == <span class="number">2</span> ? <span class="number">3</span> : <span class="number">2</span>;</span><br><span class="line">		ans[<span class="number">1</span>] = _xor[id1] + _xor[id2] + <span class="number">2</span> * q(<span class="string">"AND"</span>, <span class="number">1</span>, id2) - (_xor[id1] ^ _xor[id2]) - <span class="number">2</span> * q(<span class="string">"AND"</span>, id1, id2);</span><br><span class="line">		ans[<span class="number">1</span>] /= <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	rep(i, <span class="number">2</span>, n)	ans[i] = _xor[i] ^ ans[<span class="number">1</span>];</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	rep(i, <span class="number">1</span>, n)	<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; ans[i];</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>交互</tag>
      </tags>
  </entry>
  <entry>
    <title>CFR-697E Advertising Agency 题解</title>
    <url>/2021/01/31/CFR-697E-Advertising-Agency-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforces.com/problemset/problem/1475/E" target="_blank" rel="noopener">题目大意</a></h3><p>给你n个数，问你从中取k个数，且这k个数的和是最大和有多少种可能，答案对$1e^9+7$取模。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>题目很简单，没想到这场又是e比d简单。</p>
<p>cf你变了。</p>
<p>存在多种可能是由最后一个数导致的。</p>
<p>所以只需要判断一下取最后一类数有多少种可能。</p>
<p>需要注意，这个组合数比较大，求组合数不能直接取模哦。</p>
<p>需要用到逆元。</p>
<p>（刚开始wa了几发，后面发现原来是快速幂模板写错了，吐了。。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for (ll i=a;i&lt;=n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,n) for (ll i=a;i&gt;=n;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bg begin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rbg rbegin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ed end</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dbg(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">"==="</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N = <span class="number">1010</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">ll num[N], cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b, ll mod)</span> </span>&#123;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)	ans = (ans * a) % mod;</span><br><span class="line">		a = (a * a) % mod, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">	ll sum = <span class="number">1</span>, t = <span class="number">1</span>;</span><br><span class="line">	per(i, a, a - b + <span class="number">1</span>)	sum = (sum * i) % mod;</span><br><span class="line">	rep(i, <span class="number">1</span>, b) &#123;</span><br><span class="line">		sum = (sum * qpow(i, mod - <span class="number">2</span>, mod)) % mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (sum % mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\in.txt", "r", stdin);</span></span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\out.txt", "w+", stdout);</span></span><br><span class="line">	<span class="keyword">int</span> t; <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n, k; <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">		<span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="keyword">sizeof</span>(num));</span><br><span class="line">		<span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">		rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; num[i];</span><br><span class="line">			cnt[num[i]] ++;</span><br><span class="line">		&#125;</span><br><span class="line">		sort(num + <span class="number">1</span>, num + <span class="number">1</span> + n, greater&lt;ll&gt;());</span><br><span class="line">		ll <span class="built_in">min</span> = num[k], c = <span class="number">0</span>;</span><br><span class="line">		rep(i, <span class="number">1</span>, k) &#123;</span><br><span class="line">			<span class="keyword">if</span> (num[i] == <span class="built_in">min</span>)	c++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; C(cnt[<span class="built_in">min</span>], c) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>组合数</tag>
        <tag>逆元</tag>
      </tags>
  </entry>
  <entry>
    <title>CFR-680C Division 题解</title>
    <url>/2020/11/02/CFR-680C-Division-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforces.com/contest/1445/problem/C" target="_blank" rel="noopener">题目大意</a></h3><p>给你两个整数$p,q(1\leq p\leq10^{18},2\leq q\leq 10^9)$  ，求满足 $x\mid p,q\nmid x $ 的最大整数  $x$。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>数学方面的题目是真的不会啊。。</p>
<p>上次就一道1e18分解质数的题目就卡住我了。</p>
<p>易知，当$q\nmid p$的时候，答案就是<code>p</code>。</p>
<p>当$q\mid p$的时候，首先可以把$p$和$q$按质数乘形式表示出来，$p=p_1^{\alpha_1}p_2^{\alpha_2}····p_s^{\alpha_s}$ 和 $q=p_1^{\beta_1}p_2^{\beta_2}····p_s^{\beta_s}$ ，由 $p\mid q$知$\alpha_i\geq \beta_i(1\leq i\leq s) $ ，设$x=p_1^{\gamma_1}p_2^{\gamma_2}····p_s^{\gamma_s}$ ，由$x\mid  p,q\nmid x$知所有$\alpha_i\geq \gamma_i$ 且并非所有$\gamma_i\geq \beta_i$ ，即只需要枚举一个质因数，并取他的n-1次方，取所有结果的最大值即可，故 <img src="https://www.zhihu.com/equation?tex=x_%7Bmax%7D%3D%5Cmax_%7B1%5Cle+i%5Cle+s%2C%5Cbeta_i%5Cne0%7D%7Bp_1%5E%7B%5Calpha_1%7Dp_2%5E%7B%5Calpha_2%7D%5Ccdots+p_%7Bi-1%7D%5E%7B%5Calpha_%7Bi-1%7D%7Dp_i%5E%7B%5Cbeta_i-1%7Dp_%7Bi%2B1%7D%5E%7B%5Calpha_%7Bi%2B1%7D%7D%7D%5Ccdots+p_s%5E%7B%5Calpha%7Bs%7D%7D" alt="[公式]"> ，遍历$ q$的所有素因子$p_i$即可。</p>
<p>枚举$q$的质因数只需要从1枚举到$sqrt(q)$即可，每次计算一小一大两个因数，取结果最大值。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for (ll i=a;i&lt;=n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,n) for (ll i=n;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(x,y) make_pair(x,y)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bg begin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rbg rbegin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ed end</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dbg(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">"==="</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line">ll p, q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">div</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x == <span class="number">1</span>)	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	ll t = p;</span><br><span class="line">	<span class="keyword">while</span> (t % q == <span class="number">0</span>)	t /= x;</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\in.txt", "r", stdin);</span></span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\out.txt", "w+", stdout);</span></span><br><span class="line">	<span class="keyword">int</span> t; <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; p &gt;&gt; q;</span><br><span class="line">		<span class="keyword">if</span> (p % q)	<span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			ll ans = <span class="number">1</span>;</span><br><span class="line">			rep(i, <span class="number">1</span>, <span class="built_in">sqrt</span>(q)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (q % i == <span class="number">0</span>) &#123;</span><br><span class="line">					ans = <span class="built_in">max</span>(ans, div(i)), ans = <span class="built_in">max</span>(ans, div(q / i));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>CFR-688C Triangles 题解</title>
    <url>/2020/12/09/CFR-688C-Triangles-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforces.com/contest/1453/problem/C" target="_blank" rel="noopener">题目大意</a></h3><p>给你一个$n\times n$的矩阵，矩阵中只包含0~9，对于每个数字，你可以任意选择三点，满足这三点都是目前对应的数字，且至少有一条边水平或者竖直，你可以让任意一个点的数字暂时改变，问对于每个数字相应的最大的三角形面积为多少。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>其实这题刚开始想到的就是暴力。</p>
<p>但是没啥特别好的暴力思路，全枚举铁定会超。</p>
<p>所以这个题解的思路就特别妙。</p>
<p>首先可以记录一下对于每个数字最大最小的x和y。</p>
<p>记录完之后就可以快乐的暴力了。</p>
<p>当然，还有贪心的思想。</p>
<p>对于某个点，既然题目要求需要有水平边或者竖直边，那我就可以构造一个，当然选的是最远的。</p>
<p>这样就已经有一条边了，另外的高就是这一段与最大最小之间的距离了。</p>
<p>水平就枚举最大最小y，竖直就枚举最大最小x即可。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for (ll i=a;i&lt;=n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,n) for (ll i=a;i&gt;=n;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bg begin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rbg rbegin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ed end</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dbg(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">"==="</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e3</span> + <span class="number">5</span>, INF = <span class="number">1e9</span>;</span><br><span class="line">ll num[N][N], maxx[<span class="number">10</span>], maxy[<span class="number">10</span>], minx[<span class="number">10</span>], miny[<span class="number">10</span>];</span><br><span class="line">ll ans[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)	ans *= a;</span><br><span class="line">		a &lt;&lt;= <span class="number">1</span>, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//ios::sync_with_stdio(0);</span></span><br><span class="line">	<span class="comment">//cin.tie(0); cout.tie(0);</span></span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\in.txt", "r", s0tdin);</span></span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\out.txt", "w+", stdout);</span></span><br><span class="line">	<span class="keyword">int</span> t; <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		rep(i, <span class="number">0</span>, <span class="number">9</span>) &#123;</span><br><span class="line">			maxx[i] = maxy[i] = ans[i]= <span class="number">0</span>;</span><br><span class="line">			minx[i] = miny[i] = INF;</span><br><span class="line">		&#125;</span><br><span class="line">		rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">			rep(j, <span class="number">1</span>, n) &#123;</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">"%1lld"</span>, &amp;num[i][j]);</span><br><span class="line">				<span class="keyword">int</span> tmp = num[i][j];</span><br><span class="line">				maxx[tmp] = <span class="built_in">max</span>(maxx[tmp], j);</span><br><span class="line">				minx[tmp] = <span class="built_in">min</span>(minx[tmp], j);</span><br><span class="line">				maxy[tmp] = <span class="built_in">max</span>(maxy[tmp], i);</span><br><span class="line">				miny[tmp] = <span class="built_in">min</span>(miny[tmp], i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">			rep(j, <span class="number">1</span>, n) &#123;</span><br><span class="line">				<span class="keyword">int</span> tmp = num[i][j];</span><br><span class="line">				ans[tmp] = <span class="built_in">max</span>(ans[tmp], <span class="built_in">max</span>(i - <span class="number">1</span>, n - i) * <span class="built_in">abs</span>(j - maxx[tmp]));</span><br><span class="line">				ans[tmp] = <span class="built_in">max</span>(ans[tmp], <span class="built_in">max</span>(i - <span class="number">1</span>, n - i) * <span class="built_in">abs</span>(j - minx[tmp]));</span><br><span class="line">				ans[tmp] = <span class="built_in">max</span>(ans[tmp], <span class="built_in">max</span>(j - <span class="number">1</span>, n - j) * <span class="built_in">abs</span>(i - maxy[tmp]));</span><br><span class="line">				ans[tmp] = <span class="built_in">max</span>(ans[tmp], <span class="built_in">max</span>(j - <span class="number">1</span>, n - j) * <span class="built_in">abs</span>(i - miny[tmp]));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		rep(i, <span class="number">0</span>, <span class="number">9</span>)	<span class="built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>暴力</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>CFR-697D Cleaning the Phone 题解</title>
    <url>/2021/01/29/CFR-697D-Cleaning-the-Phone-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforces.com/contest/1475/problem/D" target="_blank" rel="noopener">题目大意</a></h3><p>有n个物品，每个物品有自己的价值$a_i$，以及花费$b_i=1,2$，现在你需要至少m价值的物品，求最小花费。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>刚开始想的是贪心。</p>
<p>把花费不同的物品放到不同的vector里面。</p>
<p>然后不断进行比对。</p>
<p>结果发现样例都过不去。。</p>
<p>看了下题解，发现这还是老题型了。</p>
<p>先求前缀和，然后枚举一类物品的数量，然后二分搜索另一类物品的数量。</p>
<p>枚举之前需要排序。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for (int i=a;i&lt;=n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,n) for (int i=a;i&gt;=n;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bg begin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rbg rbegin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ed end</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dbg(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">"==="</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll num[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;ll&gt; v1, v2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)	ans *= a;</span><br><span class="line">		a &lt;&lt;= <span class="number">1</span>, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\in.txt", "r", stdin);</span></span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\out.txt", "w+", stdout);</span></span><br><span class="line">	<span class="keyword">int</span> t; <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n, m; <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">		ll sum = <span class="number">0</span>;</span><br><span class="line">		v1.<span class="built_in">clear</span>(); v2.<span class="built_in">clear</span>();</span><br><span class="line">		rep(i, <span class="number">1</span>, n)	<span class="built_in">cin</span> &gt;&gt; num[i], sum += num[i];</span><br><span class="line">		v1.push_back(<span class="number">0</span>); v2.push_back(<span class="number">0</span>);</span><br><span class="line">		rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">			<span class="keyword">int</span> x; <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">			<span class="keyword">if</span> (x == <span class="number">1</span>)	v1.push_back(num[i]);</span><br><span class="line">			<span class="keyword">else</span> v2.push_back(num[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		sort(v1.<span class="built_in">begin</span>() + <span class="number">1</span>, v1.<span class="built_in">end</span>(), greater&lt;ll&gt;());</span><br><span class="line">		sort(v2.<span class="built_in">begin</span>() + <span class="number">1</span>, v2.<span class="built_in">end</span>(), greater&lt;ll&gt;());</span><br><span class="line">		<span class="keyword">int</span> l1 = v1.<span class="built_in">size</span>() - <span class="number">1</span>, l2 = v2.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">		rep(i, <span class="number">1</span>, l1) v1[i] += v1[i - <span class="number">1</span>];</span><br><span class="line">		rep(i, <span class="number">1</span>, l2) v2[i] += v2[i - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">int</span> pos;</span><br><span class="line">		ll ans = <span class="number">1e18</span>;</span><br><span class="line">		rep(i, <span class="number">0</span>, l1) &#123;</span><br><span class="line">			pos = lower_bound(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), m - v1[i]) - v2.<span class="built_in">begin</span>();</span><br><span class="line">			<span class="keyword">if</span> (pos != v2.<span class="built_in">size</span>())	ans = <span class="built_in">min</span>(ans, <span class="number">1L</span>L*i + pos * <span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (sum &lt; m)	<span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>ECR-102D Program 题解</title>
    <url>/2021/01/16/ECR-102D-Program-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforces.com/problemset/problem/1473/D" target="_blank" rel="noopener">题目大意</a></h3><p>假定一个未知数x，初始为0，给你一个+-字符串，+代表x+1,-代表x-1，给定m个查询，问去除掉某个区间后，x有多少个不同的值。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p> 打比赛的时候莫得思路，打完后面队友说了下，答案就是剩下的区间的最大值与最小值差。</p>
<p>才发现他只能上下移动一格，所以答案与区间的最值有关。</p>
<p>但是问题是如何构造剩下的区间，以及查询这个区间的最值。</p>
<p>我们可以先分为前一个区间和后一个区间，前一个区间的最值好维护，就是一个前缀就能搞定。</p>
<p>关键是后面的那个区间。</p>
<p>我们可以从后面开始维护，因为是倒过来维护的，所以维护后的图像应该和原图像是与x轴对称的。</p>
<p>所以维护出来的最大值就是最小值，最小值就是最大值。</p>
<p>因为合并的时候是相当于在前一个尾端点上增加的，那么就相当于维护的时候，要以那个点为原点，所以$rMax[i] = t - minn$，$rMin[i] = t - maxn$。</p>
<p>最后可以$O(1)$来查询答案。</p>
<p>需要特判一下0是不是在那个区间里面，不在的话记得加1。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for (int i=a;i&lt;=n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,n) for (int i=a;i&gt;=n;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bg begin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rbg rbegin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ed end</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dbg(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">"==="</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> Max[N], Min[N], rMax[N], rMin[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)	ans *= a;</span><br><span class="line">		a &lt;&lt;= <span class="number">1</span>, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\in.txt", "r", stdin);</span></span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\out.txt", "w+", stdout);</span></span><br><span class="line">	<span class="keyword">int</span> t; <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n, m; <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">		<span class="built_in">string</span> s; <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">		<span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> sum[N];</span><br><span class="line">		sum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		rep(i, <span class="number">1</span>, N<span class="number">-5</span>) &#123;</span><br><span class="line">			Max[i] = rMax[i] = <span class="number">-1e9</span>;</span><br><span class="line">			Min[i] = rMin[i] = <span class="number">1e9</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">			<span class="keyword">if</span> (s[i - <span class="number">1</span>] == <span class="string">'-'</span>)	t--;</span><br><span class="line">			<span class="keyword">else</span> t++;</span><br><span class="line">			sum[i] = t;</span><br><span class="line">			Max[i] = <span class="built_in">max</span>(Max[i - <span class="number">1</span>], t);</span><br><span class="line">			Min[i] = <span class="built_in">min</span>(Min[i - <span class="number">1</span>], t);</span><br><span class="line">		&#125;</span><br><span class="line">		t = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> maxn = <span class="number">0</span>, minn = <span class="number">0</span>;</span><br><span class="line">		per(i, n, <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (s[i - <span class="number">1</span>] == <span class="string">'-'</span>)	t--;</span><br><span class="line">			<span class="keyword">else</span> t++;</span><br><span class="line">			maxn = <span class="built_in">max</span>(maxn, t);</span><br><span class="line">			minn = <span class="built_in">min</span>(minn, t);</span><br><span class="line">			rMax[i] = t - minn;</span><br><span class="line">			rMin[i] = t - maxn;</span><br><span class="line">		&#125;</span><br><span class="line">		rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">			<span class="keyword">int</span> l, r; <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">			<span class="keyword">int</span> maxn = <span class="built_in">max</span>(Max[l - <span class="number">1</span>], sum[l - <span class="number">1</span>] + rMax[r + <span class="number">1</span>]), minn = <span class="built_in">min</span>(Min[l - <span class="number">1</span>], sum[l - <span class="number">1</span>] + rMin[r + <span class="number">1</span>]);</span><br><span class="line">			<span class="keyword">int</span> ans = maxn - minn + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (<span class="number">0</span> &lt; minn || <span class="number">0</span> &gt; maxn)	ans++;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>前缀</tag>
        <tag>后缀</tag>
      </tags>
  </entry>
  <entry>
    <title>CH-0201 费解的开关 题解</title>
    <url>/2020/07/08/CH-0201-%E8%B4%B9%E8%A7%A3%E7%9A%84%E5%BC%80%E5%85%B3-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://noi-test.zzstep.com/contest/0x00「基本算法」例题/0201%20费解的开关" target="_blank" rel="noopener">题目大意</a></h3><p>给你一个5*5的01矩阵，1代表开，0代表关，你可以进行一种操作，让自己和上下左右的地方01交换，问你最少需要多少次操作使矩阵内全为1。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>用状压来表示第一行的状态，最多就$2^5=32$种。</p>
<p>确定第一行以后，之后的每一行都只需要将前一行的0,按成1即可。</p>
<p>最后判断最后一行是否全为1即可。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> Map[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> ans, tmp[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> i ,<span class="keyword">int</span> j)</span> </span>&#123;<span class="comment">//进行操作</span></span><br><span class="line">	tmp[i][j] ^= <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span>)	tmp[i - <span class="number">1</span>][j] ^= <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (i + <span class="number">1</span> &lt;  <span class="number">5</span>)	tmp[i + <span class="number">1</span>][j] ^= <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span>)	tmp[i][j - <span class="number">1</span>] ^= <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (j + <span class="number">1</span> &lt;  <span class="number">5</span>)	tmp[i][j + <span class="number">1</span>] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getans</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> &amp;cnt)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (tmp[i - <span class="number">1</span>][j])	slove(i, j),cnt++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (i == <span class="number">4</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)	<span class="keyword">if</span> (tmp[<span class="number">4</span>][j])	<span class="keyword">return</span>;</span><br><span class="line">		ans = <span class="built_in">min</span>(ans, cnt);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	getans(i + <span class="number">1</span>, cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		ans = <span class="number">1e9</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)	<span class="built_in">cin</span> &gt;&gt; Map[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; <span class="number">5</span>); i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> g = <span class="number">0</span>; g &lt; <span class="number">5</span>; g++)	tmp[j][g] = (Map[j][g] - <span class="string">'0'</span>)^<span class="number">1</span>;<span class="comment">//眼瞎，题目看错了，以为是全为0。。</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) </span><br><span class="line">				<span class="keyword">if</span> (i &amp; (<span class="number">1</span> &lt;&lt; j))	slove(<span class="number">0</span>, j),cnt++;</span><br><span class="line">			getans(<span class="number">1</span>,cnt);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (ans &gt; <span class="number">6</span>)	<span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>状压</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title>ECR-103D Journey 题解</title>
    <url>/2021/01/30/ECR-103D-Journey-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://codeforces.com/contest/1476/problem/D" target="_blank" rel="noopener">题目大意</a></h3><p>有编号0~ n的n+1个点，中间有n条路，每条路有着不同的方向。</p>
<p>选择一个点作为起点，只能够按照顺着路的方向走，每走过一条路，所有的路的方向都会发生改变。</p>
<p>求每个点作为顶点，所能到达的最多的不同的点的个数。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>刚开始题目没看懂，楞是没看懂样例答案怎么来的。</p>
<p>后面仔细看才发现，走一步方向都会变。</p>
<p>看懂了，这题就不算难了。</p>
<p>对于每个点，只需要看左边和右边能走多远，以及能不能往左边和右边走。</p>
<p>第一个点和最后一个点需要特判一下。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for (int i=a;i&lt;=n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,n) for (int i=a;i&gt;=n;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bg begin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rbg rbegin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ed end</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dbg(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">"==="</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> l[N], r[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)	ans *= a;</span><br><span class="line">		a &lt;&lt;= <span class="number">1</span>, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\in.txt", "r", stdin);</span></span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\out.txt", "w+", stdout);</span></span><br><span class="line">	<span class="keyword">int</span> t; <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		<span class="built_in">string</span> s; <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">		l[<span class="number">0</span>] = r[n] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> len = s.length() - <span class="number">1</span>;</span><br><span class="line">		l[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">		rep(i, <span class="number">1</span>, len) &#123;</span><br><span class="line">			<span class="keyword">if</span> (s[i] == s[i - <span class="number">1</span>])	l[i + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> l[i + <span class="number">1</span>] = l[i] + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		r[n - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">		per(i, len - <span class="number">1</span>, <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (s[i] == s[i + <span class="number">1</span>])	r[i] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> r[i] = r[i + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'R'</span>)	<span class="built_in">cout</span> &lt;&lt; r[<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line">		rep(i, <span class="number">1</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (s[i - <span class="number">1</span>] == <span class="string">'L'</span>)	ans += l[i];</span><br><span class="line">			<span class="keyword">if</span> (s[i] == <span class="string">'R'</span>)	ans += r[i];</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; ans;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (s[len] == <span class="string">'L'</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; l[n] + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>Dijkstra及其堆优化</title>
    <url>/2020/07/08/Dijkstra%E5%8F%8A%E5%85%B6%E5%A0%86%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>Dijkstra算法使用了广度优先搜索解决赋权有向图或者无向图的单源最短路径问题，算法最终得到一个最短路径树。该算法常用于路由算法或者作为其他图算法的一个子模块。</p>
<a id="more"></a>

<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>Dijkstra采用了一种贪心的方法，每次找离起点最近的一个点，并且用这个点来更新与他相邻的点的到起点的距离。</p>
<p>用$dis[i]$来表示与起点的距离。</p>
<p>因为每次需要找到离起点最近的点，也就是$dis[i]$最小的点，需要用一个循环，会浪费一定的时间。</p>
<p>所以我们可以使用优先队列来进行优化，也就是Dijkstra的堆优化。</p>
<p><a href="https://blog.csdn.net/qq_35644234/article/details/60870719#commentBox" target="_blank" rel="noopener">Dijkstra详解</a>。</p>
<p>1、Dijkstra模板</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">110</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> Map[MAX][MAX],dis[MAX],mark[MAX];</span><br><span class="line"><span class="keyword">int</span>	n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= f;i++)&#123;</span><br><span class="line">		mark[i]=<span class="number">0</span>;</span><br><span class="line">		dis[i]=Map[s][i];</span><br><span class="line">	&#125;</span><br><span class="line">	mark[s]=<span class="number">1</span>;</span><br><span class="line">	dis[s]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> node;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> <span class="built_in">min</span> =INF;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(!mark[i]&amp;&amp;dis[i]&lt;<span class="built_in">min</span>)&#123;</span><br><span class="line">				<span class="built_in">min</span>=dis[i];</span><br><span class="line">				node=i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		mark[node]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">			<span class="keyword">int</span> tmp=<span class="built_in">min</span>+Map[node][i];</span><br><span class="line">			tmp=tmp&gt;INF?INF:tmp;</span><br><span class="line">			<span class="keyword">if</span>(!mark[i]&amp;&amp;dis[i]&gt;tmp)	dis[i]=tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dis[f];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= MAX;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= MAX;j++)&#123;</span><br><span class="line">			Map[i][j]=INF;</span><br><span class="line">		&#125;</span><br><span class="line">		Map[i][i]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m))&#123;</span><br><span class="line">		<span class="keyword">if</span>(!n||!m)	<span class="keyword">break</span>;</span><br><span class="line">		init();</span><br><span class="line">		<span class="keyword">int</span> l,r,dis;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;l,&amp;r,&amp;dis);</span><br><span class="line">			<span class="keyword">if</span>(Map[l][r]&gt;dis||Map[r][l]&gt;dis)</span><br><span class="line">				Map[l][r]=Map[r][l]=dis; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> ans=dijkstra(<span class="number">1</span>,n);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、Dijkstra堆优化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span> + <span class="number">5</span>, INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> head[N], cnt, vis[N], dis[N], n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> to, val, next;</span><br><span class="line">&#125;Map[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> u, c;</span><br><span class="line">	node(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>) :u(a), c(b) &#123; &#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> node&amp; a) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> c &gt; a.c;<span class="comment">//小顶堆</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)	dis[i] = INF;</span><br><span class="line">	dis[s] = <span class="number">0</span>;</span><br><span class="line">	priority_queue&lt;node&gt;q;</span><br><span class="line">	q.push(node(s, <span class="number">0</span>));</span><br><span class="line">	node t;</span><br><span class="line">	<span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">		t = q.top();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">int</span> u = t.u;</span><br><span class="line">		<span class="keyword">if</span> (vis[u])	<span class="keyword">continue</span>;</span><br><span class="line">		vis[u] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = Map[i].next) &#123;</span><br><span class="line">			<span class="keyword">int</span> x = Map[i].to;</span><br><span class="line">			<span class="keyword">int</span> c = Map[i].val;</span><br><span class="line">			<span class="keyword">if</span> (!vis[x] &amp;&amp; dis[x] &gt; dis[u] + c) &#123;</span><br><span class="line">				dis[x] = dis[u] + c, q.push(node(x, dis[x]));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">	Map[++cnt].to = v, Map[cnt].val = val;</span><br><span class="line">	Map[cnt].next = head[u], head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> u, v, val;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; val;</span><br><span class="line">		build(u, v, val);</span><br><span class="line">	&#125;</span><br><span class="line">	Dijkstra(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; dis[n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Dijkstra</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>EOJ 2020.7 C OLED 题解</title>
    <url>/2020/07/24/EOJ-2020.7-C-OLED-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://acm.ecnu.edu.cn/contest/292/problem/C/" target="_blank" rel="noopener">题目大意</a></h3><p>有一个$a\times b$的矩阵，中间含有一个$n\times m$的01矩阵，这个矩阵可以在大的矩阵中间移动（平移），移动不能重复，矩阵中的1可以使大矩阵这个位置加一，求大矩阵中每个位置的相对比例。即该点的值比上所有位置的最大值，乘以100。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>其实原本的题目并没有我写的大意这么容易理解。。。</p>
<p>看了半天没看懂啥意思。</p>
<p>由于小矩阵是可以进行移动的，那个可以以小矩阵中的1为对象。</p>
<p>发现他的移动区域是一块确定的空间。</p>
<p>对这块空间进行加一。</p>
<p>那么就可以使用二维差分了。</p>
<p>（应该算是模板题了。</p>
<p>取出小矩阵中的每个1，对于他的区间进行加1。</p>
<p>最后进行前缀和，求出每一位的值并输出即可。</p>
<p>其实读懂了题还挺简单的。</p>
<p>但是我还是第一次做二维差分和前缀和的。。</p>
<p>虽然之前学了一点。</p>
<p>推荐一下这个大佬写的二维差分和二维前缀和的<a href="https://www.cnblogs.com/LMCC1108/p/10753451.html" target="_blank" rel="noopener">博客</a>，讲的很好。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dif[<span class="number">4000</span>][<span class="number">3000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> a, b, n, m;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; a &gt;&gt; b;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">			<span class="keyword">int</span> num;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">			<span class="keyword">if</span> (num) &#123;</span><br><span class="line">				<span class="keyword">int</span> x = b - m + j, y = a - n + i;</span><br><span class="line">				dif[i][j]++;</span><br><span class="line">				dif[i][x + <span class="number">1</span>]--;</span><br><span class="line">				dif[y + <span class="number">1</span>][j]--;</span><br><span class="line">				dif[y + <span class="number">1</span>][x + <span class="number">1</span>]++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> M = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= b; j++) &#123;</span><br><span class="line">			dif[i][j] += dif[i - <span class="number">1</span>][j] + dif[i][j - <span class="number">1</span>] - dif[i - <span class="number">1</span>][j - <span class="number">1</span>];<span class="comment">//对差分数组进行求前缀和，得到这一位修改了多少</span></span><br><span class="line">			M = <span class="built_in">max</span>(M, dif[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= b; j++) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d%c"</span>, <span class="number">100</span> * dif[i][j] / M, j == b ? <span class="string">'\n'</span> : <span class="string">' '</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>二维前缀和</tag>
        <tag>二维差分</tag>
      </tags>
  </entry>
  <entry>
    <title>EOJ 2020.7 E 因数串 题解</title>
    <url>/2020/07/19/EOJ-2020.7-E-%E5%9B%A0%E6%95%B0%E4%B8%B2-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://acm.ecnu.edu.cn/contest/292/problem/E/" target="_blank" rel="noopener">题目大意</a></h3><p>因数串，指的是由正整数 $a$ 所有因数所构成的一个数列，需要满足从数列的第 $2$ 个数开始，每个数都必须由其前一个数乘以某个质数或除以某个质数得出的。</p>
<p>因数串需要保证正整数 $a$ 所有因数都会出现且只出现一次。现在 Cuber QQ 会告诉你正整数 $a$ ，你需要给出任意一个因数串。</p>
<p>其中正整数 $a=\prod _ {i=1} ^ n p_i ^ {k_i} $ 。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这个题目是真的难想，看到这个题目就其实有点懵。</p>
<p>首先，可以让这个串是由1开始的。</p>
<p>那么先以第一组为例，从$p^1$到$p^k$。</p>
<p>然后可以得到他们分别乘以$p_1^1$到$p_1^{k_1}$次方。</p>
<p>以此类推，就可以得到最终的因数串。</p>
<p>具体的原因，可以看官方题解。</p>
<blockquote>
<p>需要将所有的约数按照一定的排列，使得相邻的两个数只相差一个质因子。</p>
<p>倘若我们用广义 $X$ 进制编码的形式（大概可以这么命名吧？）来表示每一个因数，即将每一个因数都按照质因数分解的形式，每一位上的数分别表示包含某一个质数的个数。例如可能包含的质数有 $2,3,5,7$ ，则 $600=2^3\cdot 3\cdot 5^2$ 可以用 $(3120)_X$ 来表示。</p>
<p>用这样编码的好处是，我们要求“相邻的两个数只相差一个质因子”，也就是在两个数的编码中有且仅有其中的某一位相差 $1$ 。</p>
<p>这样构造的思路，我们可以从格雷码中学到一些经验，用类似格雷码的方式构造就可以得到一个合法的解了。</p>
</blockquote>
<p>真的。。这是人能想到的吗。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line">ll p[<span class="number">20</span>], k[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;ll&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; p[i] &gt;&gt; k[i];</span><br><span class="line">	&#125;</span><br><span class="line">	ll c = <span class="number">1</span>;</span><br><span class="line">	v.push_back(c);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k[<span class="number">1</span>]; i++)	c *= p[<span class="number">1</span>], v.push_back(c);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> len1 = v.<span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k[i]; j++) &#123;</span><br><span class="line">			<span class="keyword">int</span> len2 = v.<span class="built_in">size</span>();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; len1; l++)	v.push_back(v[len2 - l - <span class="number">1</span>] * p[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> x : v)	<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU-1005 Number Sequence 题解</title>
    <url>/2020/07/13/HDU-1005-Number-Sequence-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1005" target="_blank" rel="noopener">题目大意</a></h3><p>定义一个等式$f(n)$.</p>
<p>$f(1) = 1, f(2) = 1, f(n) = (A * f(n - 1) + B * f(n - 2)) mod 7.$</p>
<p>输入A、B和n，求出$f(n)$.</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>之前写这种题，一看就是有规律。</p>
<p>然后以49一循环，这题简单a了。。</p>
<p>但是其实是因为杭电数据太水了。。</p>
<p>附上别人的测试数据。</p>
<blockquote>
<p>input</p>
<p>247 602 35363857<br>376 392 9671521<br>759 623 18545473<br>53 399 46626337<br>316 880 10470347<br>0 0 0</p>
<p>output</p>
<p>4<br>3<br>5<br>2<br>3</p>
</blockquote>
<p>我的代码是过不了的。。</p>
<p>所以说这题正解应该是矩阵快速幂。</p>
<p>其实矩阵快速幂和快速幂差不多，就是把数字的乘法换成矩阵的乘法即可。</p>
<p>由题目可以得到$\begin{equation}    \begin{array}{c c}     \left( \begin{array}{ccc}     f(3) \\     f(2) \\    \end{array} \right)    &amp;   = \left( \begin{array}{ccc}    a &amp; b \\    1 &amp; 0 \\    \end{array} \right)    &amp;    \left( \begin{array}{ccc}    f(2)\\    f(1) \\    \end{array} \right)    \end{array}    \end{equation}$</p>
<p>$f(3)=a\times f(2)+b\times f(1)$.</p>
<p>将公式推广到n。</p>
<p>$\begin{equation}    \begin{array}{c c}     \left( \begin{array}{ccc}     f(n) \\     f(n-1) \\    \end{array} \right)    &amp;   = \left( \begin{array}{ccc}    a &amp; b \\    1 &amp; 0 \\    \end{array} \right)^{n-2}    &amp;    \left( \begin{array}{ccc}    f(2) \\    f(1) \\    \end{array} \right)    \end{array}    \end{equation}$</p>
<p>设$A =       \left( \begin{array}{ccc}     a &amp; b \\     1 &amp; 0 \\    \end{array} \right)^{n-2}$</p>
<p>可以得到$f(n)=(A[0][0]+A[0][1])%7$。</p>
<p>所以关键就是要使用快速幂计算出A，即可得出答案。</p>
<p>补充：单位矩阵为对角线为1，其余都为0的矩阵。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> m[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">&#125;M;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(M &amp;a, M b)</span> </span>&#123;</span><br><span class="line">	M ans;</span><br><span class="line">	ans.m[<span class="number">0</span>][<span class="number">0</span>] = ans.m[<span class="number">0</span>][<span class="number">1</span>] = ans.m[<span class="number">1</span>][<span class="number">0</span>] = ans.m[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; k++)</span><br><span class="line">				ans.m[i][j] += (a.m[i][k] * b.m[k][j])%<span class="number">7</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">			a.m[i][j] = ans.m[i][j]%<span class="number">7</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qpow</span><span class="params">(M a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	M ans;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;<span class="comment">//这里换成单位矩阵会更好，之前不知道。。</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">			ans.m[i][j] = a.m[i][j] % <span class="number">7</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	n--;</span><br><span class="line">	<span class="keyword">while</span> (n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n &amp; <span class="number">1</span>) mul(ans, a);</span><br><span class="line">		n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">		mul(a, a);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (ans.m[<span class="number">0</span>][<span class="number">1</span>] + ans.m[<span class="number">0</span>][<span class="number">0</span>]) % <span class="number">7</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	M m;</span><br><span class="line">	<span class="keyword">int</span> a, b, n;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; n &amp;&amp; a || b || n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		m.m[<span class="number">0</span>][<span class="number">0</span>] = a;</span><br><span class="line">		m.m[<span class="number">0</span>][<span class="number">1</span>] = b;</span><br><span class="line">		m.m[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		m.m[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">		qpow(m, n<span class="number">-2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>EOJ Monthly 2020.3 D 钢琴演奏家 题解</title>
    <url>/2020/07/08/EOJ-Monthly-2020.3-D-%E9%92%A2%E7%90%B4%E6%BC%94%E5%A5%8F%E5%AE%B6-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://acm.ecnu.edu.cn/contest/255/problem/D/" target="_blank" rel="noopener">题目大意</a></h3><p>Cuber QQ 有一个多年的弹奏习惯，他弹奏钢琴，同一时刻一定会同时按下 m 个琴键，他喜欢不同音调交织在一起的声音，可是现在不允许了。</p>
<p>可能是因为时间的原因，钢琴不支持琴键并行（音乐带师 Cuber QQ 发明的词汇）了。通俗来说，当 Cuber QQ 同时按下 $m$ 个琴键的时候，钢琴只会发出音调最高的那个琴键的声音。</p>
<p>不甘心的 Cuber QQ 开始尝试每一个 $m$ 键的组合。他会记录下每一次钢琴发出的音调，他会统计所有演奏出的音调之和，为了验证自己有没有算错，他邀请你来帮他再算一遍。</p>
<p>需要注意的是，因为钢琴坏了，所以可能存在相同音调的琴键。</p>
<p>由于这个和可能会很大，你只需要告诉 Cuber QQ 这个和模 $10^9+7$ 的结果是多少。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>因为只会发出最高的声音，所以我们可以将其从小到大排序。</p>
<p>第$i$位的贡献为他前面的数中取$m-1$个数的组合次数，即$C_{i-1}^{m-1}$，乘上这一位的大小。</p>
<p>即$a[i]*C_{i-1}^{m-1}$。</p>
<p>由高中数学可知，组合数是可以递推的。</p>
<p>就是这样$C_i ^{m-1} = C_{i-1}^{m-1}*\frac{i}{i-(m-1)}$</p>
<p>（傻乎乎的我以为这样就简单的结束了。。</p>
<p>结果一直WA。。人都傻了</p>
<p>（因为不知道除法是不可以同余的。。</p>
<p>比完之后看了看题解。。</p>
<p>逆元是啥，快速幂我不会啊。。</p>
<p>因为除法不能取余，所以我们需要将除法变为乘法，这样就需要逆元了。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> N=<span class="number">1e9</span>+<span class="number">7</span>; </span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1000005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">slove</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span></span>&#123;<span class="comment">//快速幂</span></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(b)&#123;</span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>)	ans=ans*a%N;</span><br><span class="line">		a=a*a%N;</span><br><span class="line">		b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="keyword">int</span> n,m;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> ans=a[m],sum=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=m+<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			sum=sum*(i<span class="number">-1</span>)%N*slove(i-m,N<span class="number">-2</span>)%N;<span class="comment">//逆元</span></span><br><span class="line">			ans=(ans+(sum*<span class="number">1l</span>l*a[i])%N)%N;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>逆元</tag>
      </tags>
  </entry>
  <entry>
    <title>EOJ Monthly 2020.3 B 与矩阵 题解</title>
    <url>/2020/07/08/EOJ-Monthly-2020.3-B-%E4%B8%8E%E7%9F%A9%E9%98%B5-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://acm.ecnu.edu.cn/contest/255/problem/B/" target="_blank" rel="noopener">题目大意</a></h3><p>与矩阵是一个 n×n 的矩阵。规定矩阵中的第 i 行第 j 列记为 (i,j) 。</p>
<p>生成一个与矩阵的方式是，先生成一个长度为 n 的数列 a1,a2,…,an−1,an ，而矩阵中 (i,j)=ai&amp;aj 。</p>
<p>其中 &amp; 是指<a href="https://en.wikipedia.org/wiki/Bitwise_operation#AND" target="_blank" rel="noopener">按位与运算</a>，其计算方式是参与运算的两数各对应的二进位相与。只有对应的两个二进位都为 1 时，结果位才为 1 。</p>
<p>Cuber QQ 发现，同一个与矩阵可能对应着一些不同的数列，不过 Cuber QQ 现在只想知道字典序最小的数列是什么样的。</p>
<p>对于两个数列$a1,a2,…,an−1,an $和 $b1,b2,…,bn−1,bn$ ，如果存在一个整数$ k (1≤k≤n) $满足 $a_{k+1}&lt;b_{k+1} $且 $a1=b1,a2=b2,…,ak=bk $，我们就认为数列 $a1,a2,…,an−1,an $的字典序要小于数列 $b1,b2,…,bn−1,bn $。</p>
<p>当然，Cuber QQ 不会这么容易让你得到答案，他会把矩阵所有的 $(i,i) (1≤i≤n) $的位置全部隐藏，只显示为 0 。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>很明显的位运算。</p>
<p>（但是不会啊。。</p>
<p>因为题目要求字典序最小，那么我们可以用贪心的思想，假设这个数为0。</p>
<p>只要哪一位出现了1，那么那一位必然为1，这样很明显求出来是最小的。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> N=<span class="number">1e9</span>+<span class="number">7</span>; </span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;a[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++)&#123;</span><br><span class="line">			ans|=a[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d%c"</span>,ans,i!=n?<span class="string">' '</span>:<span class="string">'\n'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU-1205 吃糖果 题解</title>
    <url>/2020/07/08/HDU-1205-%E5%90%83%E7%B3%96%E6%9E%9C-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1205" target="_blank" rel="noopener">题目大意</a></h3><p>有n种糖果，每种糖果有mi个，每次可以吃一颗，但是每次需要吃不同种类的糖果，问你是否能够吃完所有的糖果。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>补题ing。。</p>
<p>（这个题目卡了我好久啊。。感觉自己不太聪明。思维过于僵化了。</p>
<p>我们可以用最大数量的糖果为墙，中间有n-1个缝隙，只要除了最大数量的糖果以外的糖果的数量大于等于n-1即可保证不会有相同种类的糖果相邻。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> num[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>, m = <span class="number">-1e9</span>;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;num[i]);</span><br><span class="line">			sum += num[i];</span><br><span class="line">			m = <span class="built_in">max</span>(m, num[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		sum = sum - m;</span><br><span class="line">		<span class="keyword">if</span> (sum &gt;= m<span class="number">-1</span>)	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Yes"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"No"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU-1052 Tian Ji -- The Horse Racing 题解</title>
    <url>/2020/07/08/HDU-1052-Tian-Ji----The-Horse-Racing-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1052" target="_blank" rel="noopener">题目大意</a></h3><p>田忌赛马。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>贪心。</p>
<p>（今天比赛的时候碰到了差不多的题，以前写的题目差不多忘了，现在来补一下题解。。</p>
<p>先对两个人的马匹进行从大到小的排序。</p>
<p>如果我的最好的马，打不过他最好的马，那我用我的最差的马去对他最好的马。</p>
<p>如果我的最好的马，与他的最好的马打成平手，那我就需要考虑最差的马。</p>
<p>如果我最差的马打得过他最好的马，那我直接与他最差的马对上即可。</p>
<p>如果打不过，那就用我最差的马去对上他最好的马。</p>
<p>如果我的最好的马能打得过他最好的马，那我直接获胜即可。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">2000</span>]= &#123;<span class="number">0</span>&#125;,b[<span class="number">2000</span>]= &#123;<span class="number">0</span>&#125;,n;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)&amp;&amp;n) &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;b[i]);</span><br><span class="line">        sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n,greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        sort(b+<span class="number">1</span>,b+<span class="number">1</span>+n,greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">1</span>,j=n,l,r=n;</span><br><span class="line">        <span class="keyword">for</span>(l=<span class="number">1</span>; l&lt;=r&amp;&amp;i&lt;=j;) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;b[l]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                l++;</span><br><span class="line">                cnt+=<span class="number">200</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(a[i]==b[l]) &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[j]&lt;=b[r]) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(a[j]&lt;b[l])</span><br><span class="line">                        cnt-=<span class="number">200</span>;</span><br><span class="line">                    j--;</span><br><span class="line">                    l++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cnt+=<span class="number">200</span>;</span><br><span class="line">                    r--;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j--;</span><br><span class="line">                l++;</span><br><span class="line">                cnt-=<span class="number">200</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU-1237 简单计算器 题解</title>
    <url>/2020/07/08/HDU-1237-%E7%AE%80%E5%8D%95%E8%AE%A1%E7%AE%97%E5%99%A8-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你一个中缀表达式，求出这个表达式的值。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>基础的STL栈运用。</p>
<p>需要将中缀转后缀或者前缀。</p>
<p>这个是之前的基础的题了，表达式不包括括号。</p>
<p>加括号的以后在写吧。。目前懒得去找了。</p>
<p>不过其实也差不多，就是括号需要特殊处理罢了。</p>
<p>至于分割数字和符号的话，个人比较喜欢用stringstream。</p>
<p>特别好用。</p>
<p>转表达式的方法我就不多赘述了。</p>
<p>点<a href="https://blog.csdn.net/qianyayun19921028/article/details/89228263" target="_blank" rel="noopener">这里</a>。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> priority[<span class="number">220</span>];</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt;sc;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">double</span>&gt;si;</span><br><span class="line"><span class="built_in">string</span> ans[<span class="number">220</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">solve</span><span class="params">(<span class="keyword">double</span> n1, <span class="keyword">double</span> n2, <span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ch) &#123;</span><br><span class="line">    case'+':return n1 + n2;</span><br><span class="line">    case'-':return n1 - n2;</span><br><span class="line">    case'*':return n1 * n2;</span><br><span class="line">    case'/':return n1 / n2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">stringstream</span> ss;</span><br><span class="line">    priority[<span class="string">'+'</span>] = <span class="number">0</span>;</span><br><span class="line">    priority[<span class="string">'-'</span>] = <span class="number">0</span>;</span><br><span class="line">    priority[<span class="string">'*'</span>] = <span class="number">1</span>;</span><br><span class="line">    priority[<span class="string">'/'</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (getline(<span class="built_in">cin</span>, s) &amp;&amp; s != <span class="string">"0"</span>) &#123;</span><br><span class="line">        ss.<span class="built_in">clear</span>();</span><br><span class="line">        ss &lt;&lt; s;</span><br><span class="line">        <span class="keyword">int</span>  flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (ss &gt;&gt; s) &#123;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; s &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span> ((s[<span class="number">0</span>] &gt;= <span class="string">'0'</span> &amp;&amp; s[<span class="number">0</span>] &lt;= <span class="string">'9'</span>) || s.length() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                ans[flag++] = s;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (sc.empty() || (!sc.empty() &amp;&amp; priority[s[<span class="number">0</span>]] &gt; priority[sc.top()[<span class="number">0</span>]])) &#123;</span><br><span class="line">                    sc.push(s);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (!sc.empty() &amp;&amp; priority[s[<span class="number">0</span>]] &lt;= priority[sc.top()[<span class="number">0</span>]]) &#123;</span><br><span class="line">                        ans[flag++] = sc.top();</span><br><span class="line">                        sc.pop();</span><br><span class="line">                    &#125;</span><br><span class="line">                    sc.push(s);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!sc.empty()) &#123;</span><br><span class="line">            ans[flag++] = sc.top();</span><br><span class="line">            sc.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; flag; i++) &#123;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; ans[i] &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span> ((ans[i][<span class="number">0</span>] &gt;= <span class="string">'0'</span> &amp;&amp; ans[i][<span class="number">0</span>] &lt;= <span class="string">'9'</span>) || ans[i].length() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">double</span> n = stod(ans[i]);</span><br><span class="line">                si.push(n);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">double</span> n1 = si.top();</span><br><span class="line">                si.pop();</span><br><span class="line">                <span class="keyword">double</span> n2 = si.top();</span><br><span class="line">                si.pop();</span><br><span class="line">                si.push(solve(n2, n1, ans[i][<span class="number">0</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> num = si.top();</span><br><span class="line">        si.pop();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>, num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>表达式转换</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU-1317 XYZZY 题解</title>
    <url>/2020/07/08/HDU-1317-XYZZY-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1317" target="_blank" rel="noopener">题目大意</a></h3><p>有n个房间，你的初始能量是100，你需要从第一个房间到达第n个房间，每个房间的能量为-100~+100之间，你每走进一个房间，你就会加上这个房间的能量，如果能量小于0就失败了。问你能否到达第n个房间。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这个图是一个有向图。首先可以用Floyd判能否达到，如果不能到达，那么肯定不行。</p>
<p>由于这个图存在正环的情况，所以需要Spfa去处理。如果存在正环，那么只用判断是否能从正环中到达n点，如果能够到达，那必定可以，否则不行。</p>
<p>其他情况只用判断从1到n点的最长路是否大于0，大于0的话就可以到达，否则不行。</p>
<p>（Spfa初体验。。应该算是Spfa的模板题了吧</p>
<p>感觉Spfa比Bellman-Ford要简单一点</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> energy[<span class="number">110</span>], vis[<span class="number">110</span>], road[<span class="number">110</span>][<span class="number">110</span>], power[<span class="number">110</span>],out[<span class="number">110</span>],n,Map[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">100</span>; k++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">100</span>; j++)</span><br><span class="line">				<span class="keyword">if</span> (road[i][k] &amp;&amp; road[k][j])	road[i][j] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(out, <span class="number">0</span>, <span class="keyword">sizeof</span>(out));</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">	<span class="built_in">memset</span>(power, <span class="number">0</span>, <span class="keyword">sizeof</span>(power));</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">	power[<span class="number">1</span>] = <span class="number">100</span>;</span><br><span class="line">	q.push(<span class="number">1</span>);</span><br><span class="line">	vis[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> f = q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		out[f]++;</span><br><span class="line">		vis[f] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (out[f] &gt;= n) <span class="keyword">return</span> road[f][n];<span class="comment">//存在正环，判断是否能够到达n点</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (Map[f][i] &amp;&amp; power[i] &lt; power[f] + energy[i] &amp;&amp; power[f] + energy[i]&gt;<span class="number">0</span>) &#123;</span><br><span class="line">				power[i] = power[f] + energy[i];</span><br><span class="line">				<span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">					q.push(i);</span><br><span class="line">					vis[i] = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> power[n] &gt; <span class="number">0</span>;<span class="comment">//判断是否大于0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(road, <span class="number">0</span>, <span class="keyword">sizeof</span>(road));</span><br><span class="line">		<span class="built_in">memset</span>(Map, <span class="number">0</span>, <span class="keyword">sizeof</span>(Map));</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> k;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; energy[i] &gt;&gt; k;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++) &#123;</span><br><span class="line">				<span class="keyword">int</span> node;</span><br><span class="line">				<span class="built_in">cin</span> &gt;&gt; node;</span><br><span class="line">				road[i][node] = <span class="number">1</span>;</span><br><span class="line">				Map[i][node] = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		floyd();</span><br><span class="line">		<span class="keyword">if</span> (!road[<span class="number">1</span>][n])	<span class="built_in">cout</span> &lt;&lt; <span class="string">"hopeless"</span> &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//判断是否能够到达</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (!spfa())	<span class="built_in">cout</span> &lt;&lt; <span class="string">"hopeless"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">else</span>  <span class="built_in">cout</span> &lt;&lt; <span class="string">"winnable"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Floyd</tag>
        <tag>最短路</tag>
        <tag>Spfa</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU-1503 Advanced Fruits题解</title>
    <url>/2020/07/08/HDU-1503-Advanced-Fruits%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1503" target="_blank" rel="noopener">题目大意</a></h3><p>给你两个字符串，问你如何按照顺序，将两个字符串合并后，输出最短的和字符串。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>本来我是想到，用LCS求出最短字符串后，用第二个字符串删去最长公共子序列，但是WA了。。。</p>
<p>后来查了题解才发现，应该顺序不能变。</p>
<p>那么这题就是一个LCS的应用，记录路径，倒序递归输出。</p>
<p>（明明是LCS，我也学了，但是就是写不出。。哎，还需要努力）</p>
<p>不是很熟悉LCS的话，可以参考以下这张图。</p>
<p><img src="https://ae01.alicdn.com/kf/H58afddd813f445b9bc8074e24ae630a3P.jpg" alt=""></p>
<p>很清楚的展示了路径。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	<span class="keyword">int</span> mark;<span class="comment">//记录状态</span></span><br><span class="line">&#125;dp[N][N];</span><br><span class="line"><span class="keyword">char</span> a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P</span><span class="params">(<span class="keyword">int</span> i ,<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i + j == <span class="number">0</span>)	<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (dp[i][j].mark == <span class="number">0</span>) &#123;</span><br><span class="line">		P(i<span class="number">-1</span>, j<span class="number">-1</span>);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (dp[i][j].mark == <span class="number">1</span>) &#123;	</span><br><span class="line">		P(i<span class="number">-1</span>, j);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		P(i, j<span class="number">-1</span>);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; b[j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; a + <span class="number">1</span> &gt;&gt; b + <span class="number">1</span>) &#123;</span><br><span class="line">		n = <span class="built_in">strlen</span>(a + <span class="number">1</span>);</span><br><span class="line">		m = <span class="built_in">strlen</span>(b + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			dp[i][<span class="number">0</span>].mark = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">				dp[<span class="number">0</span>][j].mark = <span class="number">-1</span>;</span><br><span class="line">				dp[i][j].mark = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">if</span> (dp[i - <span class="number">1</span>][j].val &gt; dp[i][j - <span class="number">1</span>].val) &#123;</span><br><span class="line">					dp[i][j].mark = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> dp[i][j].mark = <span class="number">-1</span>;</span><br><span class="line">				dp[i][j].val = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j].val, dp[i][j - <span class="number">1</span>].val);</span><br><span class="line">				<span class="keyword">if</span> (a[i] == b[j]) &#123;</span><br><span class="line">					<span class="keyword">if</span> (dp[i - <span class="number">1</span>][j - <span class="number">1</span>].val + <span class="number">1</span> &gt; dp[i][j].val) &#123;</span><br><span class="line">						dp[i][j].mark = <span class="number">0</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					dp[i][j].val = <span class="built_in">max</span>(dp[i][j].val, dp[i - <span class="number">1</span>][j - <span class="number">1</span>].val + <span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		P(n, m);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>记录路径</tag>
        <tag>LCS</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU-3631 Shortest Path 题解</title>
    <url>/2020/07/08/HDU-3631-Shortest-Path-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3631" target="_blank" rel="noopener">题目大意</a></h3><p>给你一张加权有向多重图，你可以对这张图进行两种操作</p>
<blockquote>
<p>（1）在图中标记一个顶点。<br>（2）仅通过标记的顶点找到两个顶点之间的最短路径。</p>
</blockquote>
<p>对于操作“ 0 x”，表示标记x点，如果点x已经被标记了，则输出“ ERROR! At point x“。</p>
<p>对于操作“ 1 x y”，如果未标记点x或点y，则输出“ERROR! At path x to y”；</p>
<p>如果无法通过标记顶点从x到达y，则输出“No such path”；</p>
<p>否则，输出最短路径的长度。</p>
<p>在两个连续的测试用例之间有一个空白行。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>看题意，很明显是多源最短路。</p>
<p>（但是我一开始没想到，直接用Dijkstra写了，然后TLE了。。</p>
<p>以标记点为中继点，不断更新最短距离，看是否能够只通过标记点到达。</p>
<p>不为INF就是可以到达。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> mark[<span class="number">330</span>],vis[<span class="number">330</span>],dis[<span class="number">330</span>],n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> Map[<span class="number">330</span>][<span class="number">330</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">			Map[i][j] = <span class="built_in">min</span>(Map[i][j], Map[i][k] + Map[k][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++)</span><br><span class="line">			Map[i][j] = INF;</span><br><span class="line">		Map[i][i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>  m, q,cnt = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; q &amp;&amp; n || m || q) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(mark, <span class="number">0</span>, <span class="keyword">sizeof</span>(mark));</span><br><span class="line">		init();</span><br><span class="line">		<span class="keyword">if</span> (cnt != <span class="number">1</span>)	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//注意恶心人的输出格式</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; cnt++ &lt;&lt; <span class="string">":"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> x, y;</span><br><span class="line">			<span class="keyword">long</span> <span class="keyword">long</span> d;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; d;</span><br><span class="line">			Map[x][y] = <span class="built_in">min</span>(d,Map[x][y]);<span class="comment">//多重图，注意找最小值</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> x;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; x ;</span><br><span class="line">			<span class="keyword">if</span> (x) &#123;</span><br><span class="line">				<span class="keyword">int</span> node1, node2;</span><br><span class="line">				<span class="built_in">cin</span> &gt;&gt; node1 &gt;&gt; node2;</span><br><span class="line">				<span class="keyword">if</span> (!mark[node1] || !mark[node2]) </span><br><span class="line">					<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR! At path "</span> &lt;&lt; node1 &lt;&lt; <span class="string">" to "</span> &lt;&lt; node2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> (Map[node1][node2] &gt;= INF)	<span class="built_in">cout</span> &lt;&lt; <span class="string">"No such path"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">					<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; Map[node1][node2] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">int</span> node;</span><br><span class="line">				<span class="built_in">cin</span> &gt;&gt; node;</span><br><span class="line">				<span class="keyword">if</span> (mark[node])</span><br><span class="line">					<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR! At point "</span> &lt;&lt; node &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					mark[node] = <span class="number">1</span>;</span><br><span class="line">					floyd(node);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Floyd</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU-2054 A == B ? 题解</title>
    <url>/2020/08/31/HDU-2054-A-==-B--%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2054" target="_blank" rel="noopener">题目大意</a></h3><p>给你两个数，让你判断这两个数是否相等。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>很早之前写的题了，那时候不怎么会写，就一直鸽在那里了。</p>
<p>刚好最近群里的新生在写这题，顺便就重新写一下了。</p>
<p>还挺有意思的，这个题目。</p>
<p>首先随便的用了下stoi，发现wa了，大概猜到应该就是一个字符串的题目了。</p>
<p>其实只需要判断符号，去前导零，和尾部的无用的零就可以了。</p>
<p>剩下的只需要判断两个字符串是否相等即可。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="built_in">string</span> a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a[<span class="number">0</span>] == <span class="string">'-'</span>)	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init1</span><span class="params">(<span class="built_in">string</span>&amp; t)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (t[<span class="number">0</span>] == <span class="string">'0'</span>)	t.erase(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init2</span><span class="params">(<span class="built_in">string</span>&amp; t)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= t.length(); i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (t[i] == <span class="string">'.'</span>) &#123;</span><br><span class="line">			<span class="keyword">while</span> (!t.length()<span class="number">-1</span>!=i &amp;&amp; t[t.length() - <span class="number">1</span>] == <span class="string">'0'</span>)	t.erase(t.length() - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span> (t.length()<span class="number">-1</span>==i)	t.erase(t.length() - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">string</span> a, b;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (check(a) != check(b)) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span> &lt;&lt; <span class="built_in">endl</span>; <span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		init1(a), init1(b), init2(a), init2(b);</span><br><span class="line">		<span class="keyword">if</span> (a==b)	<span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU-4277 USACO ORZ 题解</title>
    <url>/2020/09/10/HDU-4277-USACO-ORZ-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4277" target="_blank" rel="noopener">题目大意</a></h3><p>给你n条边，求将这些边用完的情况下，能组成多少个不同的三角形。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>刚开始还觉得挺简单的。</p>
<p>就一个暴力dfs加set去重。</p>
<p>但是直接TLE了，后面加了剪枝还在T。。</p>
<p>因为不怎么会用自定义类型的set，所以就用了string来去重。</p>
<p>结果看了题解，发现就是这里导致的T。</p>
<p>（string太慢了。。</p>
<p>然后就在想，怎么让他去重。</p>
<p>卡了我好久。</p>
<p>还好这里的边长度不大，所以只需要用一个类字符串的形式来去重。</p>
<p>剪枝的话，因为最大值是不能大于等于三边总和的2/3的，所以按照这个条件来剪枝。</p>
<p>在去重的时候，还需要三条边按照升序或者降序来去重，不然答案会重复。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">20</span>], n, sum;</span><br><span class="line"><span class="built_in">set</span>&lt;ll&gt;s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c,<span class="keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">max</span>(<span class="built_in">max</span>(a,b),c)*<span class="number">2</span>&gt;=sum)	<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (cnt == n ) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a &gt; b || a &gt; c || b &gt; c ) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (a + b &gt; c &amp;&amp; a + c &gt; b &amp;&amp; b + c &gt; a) &#123;</span><br><span class="line">			ll ans = (((a * <span class="number">10000</span>) + b) * <span class="number">10000</span>) + c;</span><br><span class="line">			s.insert(ans);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(a + num[cnt], b, c, cnt + <span class="number">1</span>);</span><br><span class="line">	dfs(a, b + num[cnt], c, cnt + <span class="number">1</span>);</span><br><span class="line">	dfs(a, b, c + num[cnt], cnt + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t; <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		sum = <span class="number">0</span>;</span><br><span class="line">		s.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)	<span class="built_in">cin</span> &gt;&gt; num[i], sum += num[i];</span><br><span class="line">		dfs(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>去重</tag>
        <tag>剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU-1722 Cake 题解</title>
    <url>/2020/09/15/HDU-1722-Cake-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1722" target="_blank" rel="noopener">题目大意</a></h3><p>有一块蛋糕，可能要分给q个人或者p个人，问最少该切成多少块（不一定要相等大小），才能保证两者都可以分配。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>丢人啊。。</p>
<p>这还是新生的题目，新生都是一遍过的。。</p>
<p>我卡了好久。</p>
<p>自闭了。</p>
<p>其实想到了就很简单。</p>
<p>首先分成q块需要以圆心为中心切q刀，分成p块需要切p刀，但是他们中会有重复的刀不需要切。</p>
<p>所以答案就是$p+q-gcd(p,q)$。</p>
<p>至于为啥是gcd(p,q)，我稍微的证明了一下，不严谨。</p>
<p>设c=gcd(p,q)。</p>
<p>那么以第一刀开始，每次切的角度是$\Large \frac{2π}{\Large \frac{p}{n}}$。</p>
<p>同理，第二种是$\Large \frac{2π}{\Large \frac{q}{n}}$。</p>
<p>让两者相等，可以得到$\Large \frac{p}{q}=\frac{n_1}{n_2}$。</p>
<p>显然$p=c\times k_1,q=c \times k_2$。</p>
<p>所以有$\Large \frac{k_1}{k_2}=\frac{n_1}{n_2}$。</p>
<p>在满足这个条件下，右边是可以乘上1~n的，所以重复的就是gcd。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p, q;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; p &gt;&gt; q) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; p+q-gcd(p,q) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>gcd</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU-4745 Two Rabbits 题解</title>
    <url>/2020/07/08/HDU-4745-Two-Rabbits-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4283" target="_blank" rel="noopener">题目大意</a></h3><p>给你n个数，这n个数围成一个环，有两只兔子，可以从其中任意一个数出发，一个按顺时针跳跃，一个按逆时针跳跃，但是他们需要站在相同的数上，他们不能跳过已经被踩过的数字，并且他们能踩在同一个数上。问他们最多能跳几次。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>因为他们需要踩在相同的数字上，所以其实这就是一个最长回文子序列的问题。</p>
<p>（真的难想。。</p>
<p>求最长回文子序列很简单，看代码就懂了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n; len++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= n - len + <span class="number">1</span>; l++) &#123;</span><br><span class="line">				<span class="keyword">int</span> r = l +len - <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span> (num[l] == num[r])	dp[l][r] = <span class="built_in">max</span>(dp[l][r], dp[l + <span class="number">1</span>][r - <span class="number">1</span>] + <span class="number">2</span>);</span><br><span class="line">				<span class="keyword">else</span> dp[l][r] = <span class="built_in">max</span>(dp[l + <span class="number">1</span>][r], dp[l][r - <span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>枚举长度，得到左右端点，如果左右两端相同，那就是中间区间的最长值加2,。</p>
<p>如果不相同，那要么就是左边区间添加了j，要么就是右边区间添加了i，去其中的最大值。</p>
<p>我们用$dp[l][r]$表示l到r的最长回文子序列长度。</p>
<p>有两种思路。</p>
<p>1、我们可以在1-n区间中枚举一个点i，那么就分为了$[1,i]$和$[i+1,n]$。</p>
<p>假设$[1,i]$中最长的回文子序列为$[x,y]$，$[i+1,n]$中最长的回文子序列为$[x_1,y_1]$。</p>
<p>那么一个人的路径为$x-&gt;y,x_1-&gt;y_1$，另外一个人的路径为$y-&gt;x,y_1-&gt;x_1$。</p>
<p>答案为$max(dp[1][i],dp[i+1][n])$。</p>
<p>2、因为是一个环，可以使用倍增的思路，将数组扩大两倍。</p>
<p>由题意可知，每一个人最多走n步。</p>
<p>所以只需要找到长度为n的最长回文子序列即可，这时候每个人从这个最长回文子序列的两端开始跳跃。</p>
<p>但是有一种特殊情况，当两点重合的时候，也就是从同一点出发时，这个时候找的就是长度为n-1的最长回文子序列，并且答案需要加1。</p>
<p>比如1121，我们同时以1为起点，然后$1-&gt;2-&gt;1$，答案为4。</p>
<p>也就是，起点可以不构成回文子序列。</p>
<p>答案为$max(dp[i][i+n-1],dp[i][i+n-2]+1)$。</p>
<p>（dp怎么这么难。。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2200</span>;</span><br><span class="line"><span class="keyword">int</span> num[N], dp[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span>&gt;&gt;n&amp;&amp;n) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)	</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; num[i], num[n + i] = num[i];</span><br><span class="line">		<span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)	dp[i][i] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n; len++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= <span class="number">2</span> * n - len + <span class="number">1</span>; l++) &#123;</span><br><span class="line">				<span class="keyword">int</span> r = l +len - <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span> (num[l] == num[r])	dp[l][r] = <span class="built_in">max</span>(dp[l][r], dp[l + <span class="number">1</span>][r - <span class="number">1</span>] + <span class="number">2</span>);</span><br><span class="line">				<span class="keyword">else</span> dp[l][r] = <span class="built_in">max</span>(dp[l + <span class="number">1</span>][r], dp[l][r - <span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			ans = <span class="built_in">max</span>(ans, dp[i][i + n - <span class="number">1</span>]);</span><br><span class="line">			ans = <span class="built_in">max</span>(ans, dp[i][i + n - <span class="number">2</span>] + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>区间DP</tag>
        <tag>最长回文子序列</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU-6608 Fansblog 题解</title>
    <url>/2020/08/31/HDU-6608-Fansblog-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6608" target="_blank" rel="noopener">题目大意</a></h3><p>给你一个质数p，求出小于p的最大质数n，求n的阶乘模p。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>纯纯粹粹的数论题。</p>
<p>由威尔逊定理得，当p为质数时，$(p-2)!=1$。</p>
<p>所以答案为$\Large \prod_{N+1}^{p+2} inv(i)$。</p>
<p>质数分布密度：素数分布越来越稀疏，但1e18内任意两个质数的差不会很大，好像有个人证明了不会超过246。</p>
<p>参考论文：<a href="http://www.docin.com/p-775822584.html" target="_blank" rel="noopener">http://www.docin.com/p-775822584.html</a></p>
<p>所以直接枚举判断即可。</p>
<p>但是需要判断的数太大了，所以需要用Miller-Rabin素数检测算法。</p>
<p>不懂的戳<a href="https://blog.csdn.net/forever_dreams/article/details/82314237" target="_blank" rel="noopener">这里</a>。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qmul</span><span class="params">(ll a,ll b,ll mod)</span> </span>&#123;</span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)	ans = (ans + a) % mod;</span><br><span class="line">		a = (a + a) % mod, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b, ll mod)</span> </span>&#123;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)	ans = qmul(ans,a,mod);</span><br><span class="line">		a = qmul(a,a,mod), b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(ll num)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (num == <span class="number">2</span>)	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (num &lt; <span class="number">2</span> || !(num &amp; <span class="number">1</span>))	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	ll s, t;</span><br><span class="line">	<span class="keyword">for</span> (s = <span class="number">0</span>, t = num - <span class="number">1</span>; !(t &amp; <span class="number">1</span>); s++, t &gt;&gt;= <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">		ll a = rand() % (num - <span class="number">1</span>) + <span class="number">1</span>, k = qpow(a, t, num);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= s; j++) &#123;</span><br><span class="line">			ll tmp = qmul(k, k, num);</span><br><span class="line">			<span class="keyword">if</span> (tmp == <span class="number">1</span> &amp;&amp; k != <span class="number">1</span> &amp;&amp; k != num - <span class="number">1</span>)	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			k = tmp;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (k != <span class="number">1</span>)	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//freopen("D:\\测试用\\in.txt", "r", stdin);</span></span><br><span class="line">    <span class="comment">//freopen("D:\\测试用\\out.txt", "w+", stdout);</span></span><br><span class="line">	<span class="keyword">int</span> t; <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		ll num, t; <span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">		t = num - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (!check(t))	t--;</span><br><span class="line">		ll ans = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (ll i = t + <span class="number">1</span>; i &lt;= num - <span class="number">2</span>; i++)	ans = qmul(ans,qpow(i,num<span class="number">-2</span>,num),num);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU-6745 Dec 题解</title>
    <url>/2020/07/20/HDU-6745-Dec-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6745" target="_blank" rel="noopener">题目大意</a></h3><p>初始有 a, b 两个正整数，每次可以从中选一个大于 1 的数减 1，最后两个都会减到 1，求在过程中两个数互质的次数最多是多少。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>刚开始还没啥思路。。</p>
<p>想了好久。</p>
<p>问了下队友。</p>
<p>顿时就懂了。</p>
<p>$dp[i][j]=max(dp[i-1][j],dp[i][j-1])$。</p>
<p>当i和j互质的时候加一。</p>
<p>其实就是一个很简单的dp。</p>
<p>（进一步说明了我dp不行啊。。</p>
<p>那个关系转移还真没想到。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1050</span>;</span><br><span class="line"><span class="keyword">int</span> dp[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">1000</span>; j++) &#123;</span><br><span class="line">			dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">1</span> || j == <span class="number">1</span>||gcd(i,j)==<span class="number">1</span>)	dp[i][j]++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> a, b;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[a][b]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU-4283 You Are the One 题解</title>
    <url>/2020/07/08/HDU-4283-You-Are-the-One-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4283" target="_blank" rel="noopener">题目大意</a></h3><p>有n个人，排成一列，每个人有着自己的耐心值$a[i]$，对于每个人来说，他的快乐值等于$a[i]*(j-1)$，j为他是第几个排完队的。你可以用一个类似于栈的东西来控制他们的顺序，让一部分人进去，然后逆序出来。求最小的快乐值。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>（这道题是真的好难。。。</p>
<p>菜鸡的我，看到这题完全没思路，看完题解写的。。</p>
<p>应该是我目前做过的区间dp最难的题了。。其实也没做多少题。</p>
<p>用$dp[i][j]$来表示区间$[i,j]$中的最小的快乐值。</p>
<p>对于一个区间$[i,j]$来说，我们要想使他最优，那就需要他们的顺序是最优的。</p>
<p>在$[i,j]$区间中，我们将i单独取出来，得到区间$[i+1,j]$。</p>
<p>我们可以枚举这个i插入到的位置。</p>
<p>设这个位置为k，那么就分为了两个区间$[i+1,k]$和$[k+1,j]$。</p>
<p>对于区间$[i+1,k]$来说，他们前面没有人（指在区间$[i,j]$中），所以他的贡献就是$dp[i+1][k]$。</p>
<p>那么对于k这个点来说，因为他的位置为k，原来的位置是i，就相当于是往后面移动了$k-i$位。</p>
<p>那么他的贡献就是$a[i]*(k-i)$。</p>
<p>对于区间$[k+1,j]$来说，就是相当于后移了$k-i+1$位（因为前面有个i），需要加上前面的。</p>
<p>所以他的贡献就是$dp[k+1][j]+(k-i+1)*sum[j]-sum[k]$。</p>
<p>得到区间$[i,j]$的最优解，那么一步步从最小区间$[i,i+1]$开始推，这时候只需要考虑谁先谁后即可。</p>
<p>这样便能推到区间$[1,n]$，得到最终答案$dp[1][n]$。</p>
<p>状态转移方程为$dp[l][r] = min(dp[l][r], dp[l + 1][k] + num[l] * (k - l) + dp[k + 1][r] + (k - l + 1) * (c[r] - c[k]))$。</p>
<p>初始化$dp[i][i]=1$即可，其他的均为INF。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>,INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> dp[N][N],num[N],c[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; num[i], c[i] = c[i - <span class="number">1</span>] + num[i];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt;= n; j++)  dp[i][j] = INF;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n; len++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= n - len + <span class="number">1</span>; l++) &#123;</span><br><span class="line">				<span class="keyword">int</span> r = l + len - <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> k = l; k &lt;= r; k++) &#123;</span><br><span class="line">					<span class="keyword">int</span> t = dp[l + <span class="number">1</span>][k] + num[l] * (k - l) + dp[k + <span class="number">1</span>][r] + (k - l + <span class="number">1</span>) * (c[r] - c[k]);</span><br><span class="line">					dp[l][r] = <span class="built_in">min</span>(dp[l][r], t);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; i &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; dp[<span class="number">1</span>][n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU-6781 Solo 题解</title>
    <url>/2020/07/26/HDU-6781-Solo-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6781" target="_blank" rel="noopener">题目大意</a></h3><p>一场比赛总共有n个题，A需要a[i]分钟写出这个题目，B需要b[i]分钟写出这个题目，每个题目率先通过的人得一分，如果同时通过，记A得一分。</p>
<p>A和B都是开始做一道题，就会直到这题做完或者对手通过这题。</p>
<p>做完了不一定要立马提交，可以之后再交。</p>
<p>A知道B的做题顺序是从1到n，求A最多得几分。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>比赛的时候看到这个题目的时候就是一脸懵。</p>
<p>跑到群里看了看，大佬说这个是dp。</p>
<p>更懵了。</p>
<p>这dp的状态我都没想到。。</p>
<p>刚开始是想，在前i分钟中，前j题的得分数的最大值。</p>
<p>但是这个分钟是$10^{18}$了，开不到。</p>
<p>而且好像也不好写。</p>
<p>写不出，看了眼题解。</p>
<p>发现是前i题中，得j分的最小时间。</p>
<p>这个思路好妙啊。</p>
<p>之前看y总的dp教学视频说，一般dp的值是问题所求的量。</p>
<p>但是这个题目不一样。</p>
<p>好像目前还没做过这样的题目。</p>
<p>那么这个题目的决策就是这个题目做与不做。</p>
<p>如果做，则就需要考虑B做到这个题目所需要的时间。</p>
<p>可以用前缀和数组pre来表示B做到这个题目所需要的时间。</p>
<p>如果做，所需要的时间为$dp[i - 1] [j - 1] + 1LL * a[i]$</p>
<p>如果这个值小于等于B做到这里的时间，则可以进行状态转移。</p>
<p>$\large dp[i][j] = min(dp[i][j], t)$</p>
<p>如果这个值大于B做到这里的时间，则说明在B做完之前，A是做不完这个题目的。</p>
<p>如果不做，则状态转移为$\large dp[i][j] = min(dp[i][j], dp[i - 1][j])$。</p>
<p>（dp老苦手了。。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2020</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N];</span><br><span class="line">ll dp[N][N], pre[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="built_in">memset</span>(pre, <span class="number">0</span>, <span class="keyword">sizeof</span>(pre));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    <span class="built_in">cin</span> &gt;&gt; b[i], pre[i] = pre[i - <span class="number">1</span>] + b[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++)    dp[i][j] = <span class="number">1e18</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">                ll t = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1L</span>L * a[i];</span><br><span class="line">                <span class="keyword">if</span> (t &lt;= pre[i])    dp[i][j] = <span class="built_in">min</span>(dp[i][j], t);</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] != <span class="number">1e18</span>)    ans = <span class="built_in">max</span>(ans, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU-6778 Car 题解</title>
    <url>/2020/07/26/HDU-6778-Car-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6778" target="_blank" rel="noopener">题目大意</a></h3><p>某市需要禁车，在五天中，每天可以对任意数量的尾号进行限制，但是每个尾号只能在五天内限制一次，问在所有方案中，五天内每天出来的车的最大值的最小值是多少。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>刚开始看到这个题目数据不大，就想到应该是爆搜的。</p>
<p>写完之后发现一直wa。。</p>
<p>以为是思路错了。</p>
<p>后面也没想到啥思路，其他的题目也写不出。</p>
<p>我太菜了。。</p>
<p>后面仔细看代码，自己想到应该是搜索的思路错了。</p>
<p>但是也没想到其他的方法。</p>
<p>看了大佬的代码，才知道正确的枚举思路。</p>
<p>说实话，搜索到现在都不是很会。。</p>
<p>其实就是把十种尾号枚举在五天中，总共应该是$5^{10}$。</p>
<p>跑完大概是900ms左右。</p>
<p>还需要多做题啊。。关于搜索的。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">10</span>], num[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> n, ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>, c = getchar();</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isspace</span>(c))</span><br><span class="line">        c = getchar();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">45</span>)</span><br><span class="line">        s = <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c))</span><br><span class="line">        x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (c ^ <span class="number">48</span>), c = getchar();</span><br><span class="line">    <span class="keyword">if</span> (s)</span><br><span class="line">        x = -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">10</span>) &#123;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, n - <span class="built_in">min</span>(num[<span class="number">0</span>], <span class="built_in">min</span>(<span class="built_in">min</span>(num[<span class="number">1</span>], num[<span class="number">2</span>]), <span class="built_in">min</span>(num[<span class="number">3</span>], num[<span class="number">4</span>]))));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        num[i] += cnt[x];</span><br><span class="line">        dfs(x + <span class="number">1</span>);</span><br><span class="line">        num[i] -= cnt[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">int</span> l;</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; l;</span><br><span class="line">            cnt[l % <span class="number">10</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="number">1e9</span>;</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU-6785 Permutation 题解</title>
    <url>/2020/07/27/HDU-6785-Permutation-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6785" target="_blank" rel="noopener">题目大意</a></h3><p>给你一串数字序列1~n，问你最多交换m对数字，最多能构成多少对逆序对。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>刚开始花了十分钟， a了两道，写到了这个题。</p>
<p>觉得这个题目不难。</p>
<p>写完之后，wa了一万遍。。</p>
<p>卡了好久，就没打了。</p>
<p>后面一看，发现自己思路出了点问题。</p>
<p>其实就是一个很简单的题目。</p>
<p>首先为了逆序对最多，肯定是优先交换队列首尾。</p>
<p>然后队列不断向中间移动。</p>
<p>当时不知道怎么想的，脑袋一抽，想成了第一位移动，最后一位不动了。。</p>
<p>那么首先考虑能够构造出n~1的次数，很显然是$\large \frac {n}{2}$次。</p>
<p>答案就是从1加到n-1。</p>
<p>如果$\large m&lt;\frac {n}{2}$，则说明不能全部到过来。</p>
<p>这个时候就需要自己找出公式了。</p>
<p>可以把交换m次之后的序列分为三份。</p>
<p>最前面那一份，分别与后面所有的数构成逆序对。</p>
<p>答案为n-1加到n-m。</p>
<p>中间那一份，每个都与最后面那一份构成逆序对。</p>
<p>易知中间的区间为$[m+1,n-m]$。</p>
<p>最后面的数的个数为m个。</p>
<p>所以答案为$(n-2m)*m$。</p>
<p>最后面的那一份，每个数也都与后面的数构成逆序对。</p>
<p>（之前就是忘了这个，wa了好久。</p>
<p>答案为1加到m-1。</p>
<p>我的代码思路用的是前缀和，其实用数学的等差求和也可以，应该会更快。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line">ll sum[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= <span class="number">1e6</span>; i++) &#123;</span><br><span class="line">		sum[i] = sum[i - <span class="number">1</span>] + i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		ll n, m;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">1</span> || !m) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ll ans;</span><br><span class="line">		<span class="keyword">int</span> t = n / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (t &lt;= m)	ans = sum[n - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			ans = sum[n - <span class="number">1</span>] - sum[n - m - <span class="number">1</span>] + (n - <span class="number">2</span> * m) * m + sum[m - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP算法</title>
    <url>/2020/07/08/KMP%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h3><p>KMP 算法是 D.E.Knuth、J,H,Morris 和 V.R.Pratt 三位神人共同提出的，称之为 Knuth-Morria-Pratt 算法，简称 KMP 算法。该算法相对于 Brute-Force（暴力）算法有比较大的改进，主要是消除了主串指针的回溯，从而使算法效率有了某种程度的提高。</p>
<p>使用KMP算法能够快速的找到目标串中的模式串。</p>
<p>时间复杂度为$O(m+n)$。</p>
<a id="more"></a>

<h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>首先，想要找到目标串中的模式串，很显然是有一种暴力方法的，就是通过j指针和k指针的不断移动，来判断是否存在该子串，如果相同，则j++，k++，如果不同，则j回退，并且向前移动一位,再继续匹配。</p>
<p>显然，这种方法十分易懂，但是时间复杂度太高了，根本不适合用于比较长的字符串比较。</p>
<p>那么，就提出来了KMP算法。</p>
<p><img src="https://ae01.alicdn.com/kf/Hb58d6979692a40508c4f18f2dd2cef09W.png" alt=""></p>
<p>显然，C与B是配对失败的，当电脑使用之前的暴力算法的时候，便会前移一位。</p>
<p><img src="https://ae01.alicdn.com/kf/Hf2c0f0e554294cee897458fbd75729f3Y.png" alt=""></p>
<p>很明显，这个前移是毫无意义的，因为第一位便无法匹配。</p>
<p>而当我们人自己来匹配的时候，当C与B匹配失败之后，很明显是不会回退到B再重新去配对的，因为前面的A已经被使用完了，而电脑不会思考，我们就需要想办法让j指针不动，而k指针回退到适当的位置，来缩短回溯的时间。</p>
<p><img src="https://ae01.alicdn.com/kf/H1c556193bc2d4b588548d4f691c0bf0ey.png" alt=""></p>
<p>这样，这个算法最重要、最核心、也最难懂的地方——next数组，便是用来实现这个功能的。</p>
<h3 id="NEXT数组"><a href="#NEXT数组" class="headerlink" title="NEXT数组"></a>NEXT数组</h3><p>next数组的定义就是，数组第i位之前的i-1位的前缀和后缀相等的最大长度。</p>
<p>例如，模式串为</p>
<p><img src="https://ae01.alicdn.com/kf/H9548945a441b4e759cba25098649e9dfd.png" alt=""></p>
<p><img src="https://ae01.alicdn.com/kf/H2a1a26c6bf9a43339b8704ec7e80e9e4H.png" alt=""></p>
<p>特殊的，为了方便计算，我们将next[0] = -1，取一个特殊数字。</p>
<p>先上代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> next[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getnext</span><span class="params">(<span class="built_in">string</span> t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>, k = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> n = t.length();</span><br><span class="line">	<span class="keyword">while</span> (j &lt; n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (k == <span class="number">-1</span> || t[j] == t[k]) &#123;</span><br><span class="line">			j++, k++;</span><br><span class="line">			next[j] = k;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> k = next[k];<span class="comment">//这句是最重要也最难懂的地方</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码十分简短，但是却并不好理解。</p>
<p>分为几种情况</p>
<blockquote>
<p>当k等于-1时，代表的是第一位之前，需要j++，k++，然后之后进行第一位的匹配。</p>
<p>当t[j]与t[k]相同的时候，j和k同时后移，记录最长的长度。</p>
<p>如果都不满足的话，则k回退，即$k = next[k]$。</p>
</blockquote>
<p>为什么是回退到$next[k]$呢？</p>
<p>因为当k需要回退的时候，说明这一位上是匹配失败的。</p>
<p>这时，匹配的最长长度是k-1，我们需要一步步的去回退，直到回退到$k=-1$，重新开始。</p>
<p>那上一步是回退到哪呢，就是长度k-1中前缀和后缀相同的位置，即$next[k-1]$。</p>
<p>也就是将之前的最长长度进行不断的削减。</p>
<p>（有一种递归的感觉</p>
<p>换句话说next数组的意义就是，当第k位匹配失败之后，k需要回退的地方。</p>
<h3 id="优化NEXT数组"><a href="#优化NEXT数组" class="headerlink" title="优化NEXT数组"></a>优化NEXT数组</h3><p>当我们计算next数组的时候，会出现一种情况。</p>
<p>就是当这一位匹配成功的时候，他的下一位也是匹配成功的时候。</p>
<p><img src="https://ae01.alicdn.com/kf/Hdf97290ceed64d4fa3ebfc6292c14659S.png" alt=""></p>
<p>很显然，在目标串与模式串进行配对的时候，当k指向第二个B时匹配失败的时候，按照我们之前计算的next数组，k是应该回退到第一个B的，但是我们就是因为j指向的那一位与B匹配失败才回退的，这个回退便毫无意义。</p>
<p>所以我们可以对next数组进行优化，当连续两位都相同的时候，便可以跳过这一位。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> next[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getnext</span><span class="params">(<span class="built_in">string</span> t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>, k = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> n = t.length();</span><br><span class="line">	<span class="keyword">while</span> (j &lt; n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (k == <span class="number">-1</span> || t[j] == t[k]) &#123;</span><br><span class="line">			j++, k++;</span><br><span class="line">			<span class="keyword">if</span> (t[j] == t[k])<span class="comment">//新增这个判断</span></span><br><span class="line">				next[j] = next[k];</span><br><span class="line">			<span class="keyword">else</span> next[j] = k;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> k = next[k];<span class="comment">//k回退</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="匹配方法"><a href="#匹配方法" class="headerlink" title="匹配方法"></a>匹配方法</h3><p>在知道next数组时候，便已经了解KMP算法的十之七八了。</p>
<p>接下来只要了解目标串与模式串的比较方法即可。</p>
<p><img src="https://ae01.alicdn.com/kf/Hc79b902f57df40cc96ec85db119ddb63P.png" alt=""></p>
<p>当我们匹配到这里的时候，从A开始。</p>
<p>显然前三位是相匹配的，j和k指针不断前移。</p>
<p>当匹配到C的时候，不相匹配了，这个时候就需要回退。</p>
<p>根据next数组，B之前最长的前缀长度为1，所以k为1。</p>
<p><img src="https://ae01.alicdn.com/kf/Haf9a762b93454170a8dc754b0219296cO.png" alt=""></p>
<p>然后重新比较C，看是否互相匹配。</p>
<p>直到匹配完成，或者目标串扫描结束。</p>
<p>直接看代码吧。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> next[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KMP</span><span class="params">(<span class="built_in">string</span> s,<span class="built_in">string</span> t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> n = s.length(),m = t.length();</span><br><span class="line">	<span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (j &lt; m &amp;&amp; k &lt; n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (k == <span class="number">-1</span> || s[j] == t[k])	j++, k++;</span><br><span class="line">		<span class="keyword">else</span> k = ne[k];</span><br><span class="line">		<span class="keyword">if</span> (k == n) &#123;<span class="comment">//如果k与n相等，则说明存在</span></span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; j - n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			flag = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!flag) <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="典型例题"><a href="#典型例题" class="headerlink" title="典型例题"></a>典型例题</h3><p>1、<a href="https://www.acwing.com/problem/content/description/833/" target="_blank" rel="noopener">ACWing-831 KMP字符串</a></p>
<h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h4><p>给定一个目标串S，以及一个模式串P，所有字符串中只包含大小写英文字母以及阿拉伯数字。</p>
<p>模式串P在目标串S中多次作为子串出现。</p>
<p>求出模式串P在目标串S中所有出现的位置的起始下标。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>典型的KMP模板题。</p>
<p>但是需要注意可以重叠。</p>
<p>所以当扫描完成一个之后，$k=next[k]$。</p>
<h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> ne[N];</span><br><span class="line"><span class="built_in">string</span> s, t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; t &gt;&gt; m &gt;&gt; s;</span><br><span class="line">	ne[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>, k = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span> (j &lt; n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (k == <span class="number">-1</span> || t[j] == t[k]) &#123;</span><br><span class="line">			j++, k++;</span><br><span class="line">			<span class="keyword">if</span> (t[j] == t[k])</span><br><span class="line">				ne[j] = ne[k];</span><br><span class="line">			<span class="keyword">else</span> ne[j] = k;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> k = ne[k];</span><br><span class="line">	&#125;</span><br><span class="line">	j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (j &lt; m &amp;&amp; k &lt; n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (k == <span class="number">-1</span> || s[j] == t[k])	j++, k++;</span><br><span class="line">		<span class="keyword">else</span> k = ne[k];</span><br><span class="line">		<span class="keyword">if</span> (k == n)	k = ne[k], <span class="built_in">cout</span> &lt;&lt; j - n &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2087" target="_blank" rel="noopener">HDU-2087 剪花布条</a></p>
<h4 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h4><p>从目标串中寻找模式串的数量。遇到#停止输入。</p>
<h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>KMP模板题。</p>
<p>但是这个题目不能重叠，和上面那一题不一样。</p>
<p>当扫描出一个时候，需要重新匹配，也就是从剩下的字符串中重新扫描匹配。</p>
<h4 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> ne[N];</span><br><span class="line"><span class="keyword">char</span> s[N], t[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s)&amp;&amp;<span class="built_in">strcmp</span>(s,<span class="string">"#"</span>)) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>, t);</span><br><span class="line">		<span class="keyword">int</span> n, m;</span><br><span class="line">		n = <span class="built_in">strlen</span>(t);</span><br><span class="line">		m = <span class="built_in">strlen</span>(s);</span><br><span class="line">		ne[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">int</span> j = <span class="number">0</span>, k = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">while</span> (j &lt; n) &#123;</span><br><span class="line">			<span class="keyword">if</span> (k == <span class="number">-1</span> || t[j] == t[k]) &#123;</span><br><span class="line">				j++, k++;</span><br><span class="line">				<span class="keyword">if</span> (t[j] == t[k])</span><br><span class="line">					ne[j] = ne[k];</span><br><span class="line">				<span class="keyword">else</span> ne[j] = k;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> k = ne[k];</span><br><span class="line">		&#125;</span><br><span class="line">		j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (j &lt; m &amp;&amp; k &lt; n) &#123;</span><br><span class="line">			<span class="keyword">if</span> (k == <span class="number">-1</span> || s[j] == t[k])	j++, k++;</span><br><span class="line">			<span class="keyword">else</span> k = ne[k];</span><br><span class="line">			<span class="keyword">if</span> (k == n) &#123;</span><br><span class="line">				ans++;</span><br><span class="line">				k = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU-6838 Battle for Wosneth 题解</title>
    <url>/2020/08/10/HDU-6838-Battle-for-Wosneth-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6838" target="_blank" rel="noopener">题目大意</a></h3><p>A与B两人决斗，A先攻击，有$p%$的几率命中，命中时，B扣一点血，A加一点血，B后攻击，有$q%$的几率命中，命中时，A扣一点血。</p>
<p>A的血量可以看作无限，B的血为m，求A的血量变化的期望值。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>不会啊。。</p>
<p>这次直接爆零了，丢人。。</p>
<p>求期望的题目是真的不会。</p>
<p>之前也没做过这类题目。</p>
<p>有$p$%回一点血$q$%的概率扣一点血，所以血量每轮的变化量为$p\%-q\%$。</p>
<p>本来应该是有$\Large \frac{m}{p\%}$个回合，但是因为当B只有一点血的时候，A先攻击，所以期望为$p\%$，回合数需要减一。</p>
<p>所以答案为$\Large (\frac{m}{p\%}-1)(p\%-q\%)+q\%$。</p>
<p>因为p和q都是百分数，所以需要乘上逆元。</p>
<p>整理后得$\Large(\frac{m-p\times inv(100)}{p}(p-q)+q\times inv(100))$。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>, maxn = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	a %= mod;</span><br><span class="line">	<span class="keyword">while</span> (b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)    ans = (ans * a % mod) % mod;</span><br><span class="line">		a = (a * a) % mod, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t; <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		ll m, p, q;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; m &gt;&gt; p &gt;&gt; q;</span><br><span class="line">		ll inv = qpow(<span class="number">100</span>, mod - <span class="number">2</span>);</span><br><span class="line">		ll ans = (p * inv) % mod;</span><br><span class="line">		ll res = (((m - ans) * (p - q) * inv % mod) % mod * qpow(p, mod - <span class="number">2</span>)) % mod;</span><br><span class="line">		ans = ((ans + (res) % mod) % mod + mod) % mod;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans % mod &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>期望</tag>
        <tag>逆元</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU-6889 Graph Theory Class 题解</title>
    <url>/2020/09/20/HDU-6889-Graph-Theory-Class-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6889" target="_blank" rel="noopener">题目大意</a></h3><p>给你一个n个顶点的无向图，求他的最小生成树的所有边的权值之和，第i点和第j点的边权值为$lcm(i+1,j+1)$。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>其实这个题目思路倒是挺简单的。</p>
<p>如果是合数的话，他的最小边肯定是他本身，并且是连接到他的因子。</p>
<p>如果是质数的话，最小值肯定是$lcm(i+1,2)$。</p>
<p>所以答案是3到n+1的和加上2~n+1的所有质数和减去2.</p>
<p>关键是这个n是1e10，怎么求这个质数和。。</p>
<p>后面组内大佬说可以用Min_25筛（听都没听过好吧。。</p>
<p>看了一小时，模板都没看懂。</p>
<p>后面直接套的别人大佬的模板了。。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b, ll k)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)    ans = (ans * a) % k;</span><br><span class="line">        a = (a * a) % k, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> _Min25 &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> p[N], name1[N], name2[N], flag[N], cnt, m;</span><br><span class="line">    ll G[N], sum[N], a[N], t, n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ini</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        m = n = cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">             name1[i] = name2[i] = flag[i] = G[i]  = a[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ID</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt;= t ? name1[x] : name2[n / x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> ll <span class="title">calc</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * (x + <span class="number">1</span>) / <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> ll <span class="title">f</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        t = <span class="built_in">sqrt</span>(n + <span class="number">0.5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= t; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!flag[i]) p[++cnt] = i, sum[cnt] = sum[cnt - <span class="number">1</span>] + i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * p[j] &lt;= t; j++) &#123;</span><br><span class="line">                flag[i * p[j]] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (i % p[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (ll l = <span class="number">1</span>; l &lt;= n; l = n / (n / l) + <span class="number">1</span>) &#123;</span><br><span class="line">            a[++m] = n / l;</span><br><span class="line">            <span class="keyword">if</span> (a[m] &lt;= t) name1[a[m]] = m; <span class="keyword">else</span> name2[n / a[m]] = m;</span><br><span class="line">            G[m] = calc(a[m]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m &amp;&amp; (ll)p[i] * p[i] &lt;= a[j]; j++)</span><br><span class="line">                G[j] = G[j] - (ll)p[i] * (G[ID(a[j] / p[i])] - sum[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> ll <span class="title">solve</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">return</span> ini(), n = x, init(), G[ID(n)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> t; <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        ll num, k; <span class="built_in">cin</span> &gt;&gt; num &gt;&gt; k;</span><br><span class="line">        ll fiv = qpow(<span class="number">2</span>, k - <span class="number">2</span>, k);</span><br><span class="line">        ll ans = ((num + <span class="number">4</span>) % k * (num - <span class="number">1</span>) % k * fiv) % k;</span><br><span class="line">        ll tmp = _Min25::solve(num + <span class="number">1</span>);</span><br><span class="line">        ans = (ans + tmp % k) % k;</span><br><span class="line">        ans -= <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans % k &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
        <tag>lcm</tag>
        <tag>Min_25筛</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU-6839 Binary Addition 题解</title>
    <url>/2020/08/11/HDU-6839-Binary-Addition-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6839" target="_blank" rel="noopener">题目大意</a></h3><p>给你两个01串s和t，串n之后的位置可以看做都是0，你可以对s进行两种操作，修改s的第i位，或者将s看做二进制，在二进制的情况下加一，求使s变成t的最小操作步数。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>比赛的时候完全没思路。</p>
<p>比完之后看到官方题解，才有的思路。。</p>
<p>枚举后缀，先将后缀全部变成1，然后进行加一。</p>
<p>如果第i+1位s是1，就需要先将这一位变成0，然后因为加一，这一位变成1。</p>
<p>如果第i+1为t是0，就还需要将加出来的第i+1位变成0。</p>
<p>在加一之后，后缀全部变成0，所以还需要将后缀变成t一样。</p>
<p>i+2之后的就直接改即可。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> s0[N], t1[N], dis[N];</span><br><span class="line"><span class="keyword">char</span> s[N], t[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> T; <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; s + <span class="number">1</span> &gt;&gt; t + <span class="number">1</span>;</span><br><span class="line">		s[n + <span class="number">1</span>] = t[n + <span class="number">1</span>] = <span class="string">'0'</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">			s0[i] = s0[i - <span class="number">1</span>] + (s[i] == <span class="string">'0'</span>), </span><br><span class="line">			t1[i] = t1[i - <span class="number">1</span>] + (t[i] == <span class="string">'1'</span>);</span><br><span class="line">		dis[n + <span class="number">1</span>] = dis[n + <span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">			dis[i] = dis[i + <span class="number">1</span>] + (s[i] != t[i]);</span><br><span class="line">		<span class="keyword">int</span> ans = dis[<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> tmp = (s[i + <span class="number">1</span>] == <span class="string">'1'</span>) + (t[i + <span class="number">1</span>] == <span class="string">'0'</span>);</span><br><span class="line">			tmp += s0[i] + t1[i] + <span class="number">1</span> + dis[i + <span class="number">2</span>];</span><br><span class="line">			ans = <span class="built_in">min</span>(ans, tmp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ-3614 Sunscreen 题解</title>
    <url>/2020/09/24/POJ-3614-Sunscreen-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://poj.org/problem?id=3614" target="_blank" rel="noopener">题目大意</a></h3><p>每个人有一个最大SPF值，和一个最大SPF值，每个物品能够提供$SPF_i$给n个人，问最多能够满足多少个人。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>刚开始想的是贪心，优先给区间大小最小的值，同时用优先队列维护物品的数量。</p>
<p>然后wa吐了。</p>
<p>后面看了题解，发现是思路不对。。</p>
<p>应该按照$SPF_i$的值从小到大枚举，对于当前的物品，将最小值满足要求的人放入优先队列中进行维护，按照最大值来排序，从小到大。</p>
<p>然后判断优先队列中的元素的最大值是否大于当前物品的$SPF_i$，满足则答案加一。</p>
<p>其实用了这么多次的优先队列，我觉得基本上就是用来维护一个动态的数据。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ty</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> l, r, flag;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">num</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> n, c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(ty a, ty b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a.r &gt; b.r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;ty, <span class="built_in">vector</span>&lt;ty&gt;,cmp&gt; q;</span><br><span class="line"><span class="built_in">vector</span>&lt;ty&gt; t;</span><br><span class="line"><span class="built_in">vector</span>&lt;num&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp1</span><span class="params">(num a, num b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.n &lt; b.n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> c, l; <span class="built_in">cin</span> &gt;&gt; c &gt;&gt; l;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> l, r; <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">		t.push_back(&#123; l,r,<span class="number">0</span> &#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> s, c; <span class="built_in">cin</span> &gt;&gt; s &gt;&gt; c;</span><br><span class="line">		n.push_back(&#123; s,c &#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	sort(n.<span class="built_in">begin</span>(), n.<span class="built_in">end</span>(), cmp1);</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; c; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!t[j].flag &amp;&amp; t[j].l &lt;= n[i].n) &#123;</span><br><span class="line">				t[j].flag = <span class="number">1</span>, q.push(t[j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (!q.empty() &amp;&amp; n[i].c) &#123;</span><br><span class="line">			ty tmp = q.top(); q.pop();</span><br><span class="line">			<span class="keyword">if</span> (tmp.r &gt;= n[i].n)	n[i].c--, cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ-1995 Raising Modulo Numbers 题解</title>
    <url>/2020/07/08/POJ-1995-Raising-Modulo-Numbers-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://poj.org/problem?id=1995" target="_blank" rel="noopener">题目大意</a></h3><p>有t组数据，每组输入h和m，有h组a，b，计算出$ (A_1^{B_1}+A_2^{B_2}+ … +A_H^{B_H})mod M $的结果。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>没什么好说的，标准的快速幂模板题。</p>
<p>（不熟。。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;<span class="comment">//快速幂</span></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> t = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">			t= (t*a)%m;</span><br><span class="line">		a = (a * a) % m;</span><br><span class="line">		b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> h;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; m &gt;&gt; h;</span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= h; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> a, b;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">			<span class="keyword">long</span> <span class="keyword">long</span> t = <span class="number">1</span>;</span><br><span class="line">			t = qpow(a%m, b);</span><br><span class="line">			ans += (t) % m;</span><br><span class="line">			ans %= m;</span><br><span class="line">		&#125;		</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ-1845 Sumdiv 题解</title>
    <url>/2020/07/08/POJ-1845-Sumdiv-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://poj.org/problem?id=1845" target="_blank" rel="noopener">题目大意</a></h3><p>求$A^B$的所有约数之和mod9901。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>（菜鸡的我，还在补基本算法。。</p>
<p>对A进行分解质因数，表示为$p_1^{c_1}\times p_2^{c_2}\times …..\times p_n^{c_n}$。</p>
<p>那么$A^B$就是乘以一个B。</p>
<p>由我不知道的公式得</p>
<p>约数和为$(1+p_1+p_1^2+…+p_1^{c_1\times B})\times  (1+p_2+p_2^2+…+p_2^{c_2\times B})\times …\times (1+p_n+p_n^2+…+p_n^{c_n\times B})$。</p>
<p>那么题目就转变为对这些等比数列求乘积了。</p>
<p>对每一项分治可以得到一个递推公式。</p>
<p>当c为奇数的时候$sum(p,c) = (1+p+…+p^{\frac {c-1} {2}})+p^{\frac {c+1}{2}}(1+p+…+p^{\frac {c-1} {2}})=(1+p^{\frac {c+1}{2}})\times sum(p,\frac {c-1}{2})$。</p>
<p>同理，当c为偶数的时候$sum(p,c) = (1+p^\frac {c}{2})*sum(p,\frac {c}{2}-1)\ +p^c$。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>,M = <span class="number">9901</span>;</span><br><span class="line">ll prime[N], cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b, ll m)</span> </span>&#123;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)	ans = (ans * a % m) % m;</span><br><span class="line">		a = (a*a)%m;</span><br><span class="line">		b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">slove</span><span class="params">(ll a,ll b,ll m)</span> </span>&#123;</span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!b)	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (b &amp; <span class="number">1</span>)	ans = (<span class="number">1</span> + qpow(a, (b + <span class="number">1</span>) / <span class="number">2</span>, m))%m * slove(a, (b - <span class="number">1</span>) / <span class="number">2</span>,m)%m;</span><br><span class="line">	<span class="keyword">else</span>  ans = (<span class="number">1</span> + qpow(a, b / <span class="number">2</span>, m)) * slove(a, b / <span class="number">2</span> - <span class="number">1</span>,m)%m + qpow(a, b, m)%m;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a, b;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">	<span class="keyword">if</span> (!a &amp;&amp; b)	<span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (a &amp;&amp; !b)	<span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">2</span>, c = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (i * i &lt;= a) &#123;<span class="comment">//分解质因数</span></span><br><span class="line">			<span class="keyword">if</span> (a % i == <span class="number">0</span>) &#123;</span><br><span class="line">				prime[c++] = i;</span><br><span class="line">				<span class="keyword">while</span> (a % i == <span class="number">0</span>) &#123;</span><br><span class="line">					a /= i,cnt[c - <span class="number">1</span>]++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">2</span>)	i = <span class="number">3</span>;</span><br><span class="line">			<span class="keyword">else</span> i += <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (a != <span class="number">1</span>) &#123;<span class="comment">//如果a本身是质数</span></span><br><span class="line">			prime[c++] = a, cnt[c - <span class="number">1</span>]++;</span><br><span class="line">		&#125;</span><br><span class="line">		ll ans = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c; i++)</span><br><span class="line">			ans = (ans*slove(prime[i],cnt[i]*b,M)%M) % M;<span class="comment">//记住要乘以b</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>递推</tag>
        <tag>数论</tag>
        <tag>快速幂</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ-2010 Moo University - Financial Aid 题解</title>
    <url>/2020/09/26/POJ-2010-Moo-University---Financial-Aid-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://poj.org/problem?id=2010" target="_blank" rel="noopener">题目大意</a></h3><p>总共有c个人，每个人有自己的成绩和所需要的钱，你只有f块钱，需要招n个人，你需要使这n个人的成绩的中位数尽可能的大，求出最大的中位数。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>题目要求是中位数。</p>
<p>那么我只需要枚举中位数，使他左右两边的花费最小。</p>
<p>题目的提示使用优先队列，所以我刚开始觉得是用优先队列来维护一个最小值。</p>
<p>发现被这个提示误导了。。</p>
<p>其实并不是用这个优先队列来维护。</p>
<p>是应该用优先队列预处理完每一位左边和右边的花费最小值。</p>
<p>（其实也算是用优先队列来维护，但是思路错了。。</p>
<p>最后只需要枚举判断即可。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ty</span> &#123;</span></span><br><span class="line">	ll sc, f;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp2</span> &#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(ty a, ty b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a.f &lt; b.f;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">ty num[N];</span><br><span class="line">priority_queue&lt;ty, <span class="built_in">vector</span>&lt;ty&gt;, cmp2&gt; q1, q2;</span><br><span class="line">ll minl[N], minr[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp1</span><span class="params">(ty a, ty b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.sc &lt; b.sc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	ll n, c, f; <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; c &gt;&gt; f;</span><br><span class="line">	ll suml = <span class="number">0</span>, sumr = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= c; i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; num[i].sc &gt;&gt; num[i].f;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(num + <span class="number">1</span>, num + <span class="number">1</span> + c, cmp1);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n / <span class="number">2</span>; i++)	suml += num[i].f, q1.push(num[i]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = c - n / <span class="number">2</span> + <span class="number">1</span>; i &lt;= c; i++)	sumr += num[i].f, q2.push(num[i]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span> + <span class="number">1</span>; i &lt;= c - n / <span class="number">2</span>; i++) &#123;</span><br><span class="line">		minl[i] = suml;</span><br><span class="line">		<span class="keyword">if</span> (num[i].f &lt; q1.top().f) &#123;</span><br><span class="line">			suml -= (q1.top().f - num[i].f);</span><br><span class="line">			q1.pop();</span><br><span class="line">			q1.push(num[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = c - n / <span class="number">2</span>; i &gt; n / <span class="number">2</span>; i--) &#123;</span><br><span class="line">		minr[i] = sumr;</span><br><span class="line">		<span class="keyword">if</span> (num[i].f &lt; q2.top().f) &#123;</span><br><span class="line">			sumr -= (q2.top().f - num[i].f);</span><br><span class="line">			q2.pop();</span><br><span class="line">			q2.push(num[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ll ans = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = c - n / <span class="number">2</span>; i &gt; n / <span class="number">2</span>; i--) &#123;</span><br><span class="line">		ll s = minl[i] + minr[i] + num[i].f;</span><br><span class="line">		<span class="keyword">if</span> (s &lt;= f) &#123;</span><br><span class="line">			ans = num[i].sc; <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title>L1-006 连续因子 题解</title>
    <url>/2020/11/14/L1-006-%E8%BF%9E%E7%BB%AD%E5%9B%A0%E5%AD%90-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805138600869888" target="_blank" rel="noopener">题目大意</a></h3><p>给你一个整数n，求n的最长连续因子序列。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>之前想到思路，莫名其妙的有两个数据过不了。。</p>
<p>就是枚举$sqrt(n)$之内的所有因子，看他们是不是连续的，取最大值。</p>
<p>但是过不了，就很奇怪。</p>
<p>后面看了下题解，发现13！是大于int的最大值的，所以需要只需要枚举前12个即可。</p>
<p>我以为就能过了，但是还是卡一个样例。</p>
<p>后面自己慢慢试发现，刚好有因子是大于12的质数，就判断错的。</p>
<p>所以最后判断一下即可。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for (ll i=a;i&lt;=n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,n) for (ll i=n;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(x,y) make_pair(x,y)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bg begin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rbg rbegin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ed end</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dbg(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">"==="</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v,ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)	ans *= a;</span><br><span class="line">		a &lt;&lt;= <span class="number">1</span>, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\in.txt", "r", stdin);</span></span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\out.txt", "w+", stdout);</span></span><br><span class="line">	ll n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">int</span> m = <span class="number">0</span>,flag = <span class="number">0</span>;</span><br><span class="line">	rep(i, <span class="number">2</span>, <span class="number">12</span>) &#123;</span><br><span class="line">		ll t = i;</span><br><span class="line">		<span class="keyword">for</span> (ll j = i; j&lt;= n&amp;&amp;t &lt;= <span class="number">12</span>; t++, j *= t) &#123;</span><br><span class="line">			<span class="keyword">if</span> (n % j == <span class="number">0</span> &amp;&amp; (t-i+<span class="number">1</span>) &gt; m) &#123;</span><br><span class="line">				flag = i, m = t - i + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">		rep(i, <span class="number">2</span>, <span class="built_in">sqrt</span>(n))	<span class="keyword">if</span> (n % i == <span class="number">0</span>)	flag = i, m = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!flag)	<span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="built_in">endl</span> &lt;&lt; flag;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = flag + <span class="number">1</span>, c = m - <span class="number">1</span>; c; c--, i++)	<span class="built_in">cout</span> &lt;&lt; <span class="string">'*'</span> &lt;&lt; i;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>UVA-10635 Prince and Princess 题解</title>
    <url>/2021/02/22/UVA-10635-Prince-and-Princess-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1576" target="_blank" rel="noopener">题目大意</a></h3><p>给你两个序列，每个序列中元素各不相同，求两个序列的lcs。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这个应该算是lcs转lis的模板题吧。</p>
<p>虽然他需要求lcs，但是数据范围是$250^2$，肯定会超时。</p>
<p>但是这两个序列中所有元素都不相同，所以可以用出现在a数组中的顺序映射到b数组中，然后求lis。</p>
<p>求lis的时间可以缩短到$O(nlogn)$。</p>
<p>就样例来说A{1 7 5 4 8 3 9}， B{1 4 3 5 6 2 8 9}，按照A的顺序进行映射：A{1,2,3,4,5,6,7}，B{1,4,6,3,0,0,5,7} 。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for (int i=a;i&lt;=n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,n) for (int i=a;i&gt;=n;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bg begin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rbg rbegin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ed end</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dbg(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">"==="</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300</span> * <span class="number">300</span>;</span><br><span class="line"><span class="keyword">int</span> vis[N], b[N], s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b, ll mod)</span> </span>&#123;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)	ans = (ans * a) % mod;</span><br><span class="line">		a = (a * a) % mod, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\in.txt", "r", stdin);</span></span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\out.txt", "w+", stdout);</span></span><br><span class="line">	<span class="keyword">int</span> t; <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">		<span class="keyword">int</span> n, p, q; <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; p &gt;&gt; q;</span><br><span class="line">		rep(i, <span class="number">1</span>, p + <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> x; <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">			vis[x] = i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">		rep(i, <span class="number">1</span>, q + <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> x; <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">			<span class="keyword">if</span> (vis[x])	b[++cnt] = vis[x];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">		s[<span class="number">1</span>] = b[<span class="number">1</span>];</span><br><span class="line">		rep(i, <span class="number">2</span>, cnt) &#123;</span><br><span class="line">			<span class="keyword">if</span> (b[i] &gt; s[len]) s[++len] = b[i];</span><br><span class="line">			<span class="keyword">else</span> s[lower_bound(s + <span class="number">1</span>, s + <span class="number">1</span> + len, b[i]) - s] = b[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; ++c &lt;&lt; <span class="string">": "</span> &lt;&lt; len &lt;&lt; <span class="built_in">endl</span>;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>LCS转LIS</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ-1001 Exponentiation</title>
    <url>/2020/07/08/POJ-1001-Exponentiation/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你输入一些浮点数，求这些浮点数的n次方。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>需要保留很多位小数，一看就是大数模拟。</p>
<p>但是这个题目写的我脑阔痛。</p>
<p>（模拟写起来是真的很烦。。</p>
<p>不过学到了一种大数乘法的写法，也挺好的。</p>
<p>可以用一个int数组来储存每一位的值。</p>
<p>然后对于每一位的值，都乘上需要乘的值，最后进位即可。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">130</span>], m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">		ans[i] *= num;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ans[i] &gt;= <span class="number">10</span>)</span><br><span class="line">			ans[i + <span class="number">1</span>] += ans[i] / <span class="number">10</span>, ans[i] = ans[i] % <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> t = ans[m - <span class="number">1</span>], p = m - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (t) &#123;</span><br><span class="line">		ans[p++] = t % <span class="number">10</span>, t /= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	m = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">string</span> s;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s &gt;&gt; n) &#123;</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>,l = s.length(),p;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (s[i] == <span class="string">'.'</span>)	p = (l - <span class="number">1</span> - i) * n;</span><br><span class="line">			<span class="keyword">else</span> sum = sum * <span class="number">10</span> + s[i] - <span class="string">'0'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!sum) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">memset</span>(ans, <span class="number">0</span>, <span class="keyword">sizeof</span>(ans));</span><br><span class="line">		m = <span class="number">1</span>;</span><br><span class="line">		ans[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			solve(sum);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> p1, p2;</span><br><span class="line">		p1 = <span class="number">0</span>, p2 = m - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (!ans[p1]) p1++;<span class="comment">//去后缀0</span></span><br><span class="line">		<span class="keyword">while</span> (!ans[p2]) p2--;<span class="comment">//去前缀0</span></span><br><span class="line">		<span class="keyword">if</span> (p1 &gt;= p) &#123;<span class="comment">//没有小数点</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = p2; i &gt; p - <span class="number">1</span>; i--)	<span class="built_in">cout</span> &lt;&lt; ans[i];</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = p2; i &gt; p<span class="number">-1</span>; i--)	<span class="built_in">cout</span> &lt;&lt; ans[i];</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">'.'</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i =  p - <span class="number">1</span>; i &gt;= p1; i--)	<span class="built_in">cout</span> &lt;&lt; ans[i];</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>大数模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/07/08/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>The begin</title>
    <url>/2020/07/08/The%20begin/</url>
    <content><![CDATA[<p>这个博客是某位大佬帮我写的，以后会放上友情链接（现在还不会。。。</p>
<p>开这个博客，时不时会上传一下我写过的题目的一些题解，加深一下印象，记录一下我这个菜鸡的ACM学习历程。</p>
<p>这应该也是我博客生涯的开始吧。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World"</span> &lt;&lt; <span class="built_in">endl</span> ;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ-2785 4 Values whose Sum is 0 题解</title>
    <url>/2020/10/16/POJ-2785-4-Values-whose-Sum-is-0-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你四个数列A,B,C,D。从每个数列中各取出一个数，问有多少种方案使得4个数的和为0。<br>当一个数列中有多个相同的数字的时候，把它们当做不同的数对待。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>刚开始看到题目给了15s，想着$n^3$能过，结果$n^3$加二分还是T了。</p>
<p>想来想去不知道咋优化，后面发现可以先算出前两个数组的和和后两个数组的和再二分，之前还真没想过这种优化。。</p>
<p>还是做题不够啊。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll a[<span class="number">4050</span>], b[<span class="number">4050</span>], c[<span class="number">4050</span>], d[<span class="number">4050</span>];</span><br><span class="line">ll sum1[<span class="number">4050</span> * <span class="number">4050</span>], sum2[<span class="number">4050</span> * <span class="number">4050</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; c[i];</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; d[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)	sum1[cnt] = a[i] + b[j], sum2[cnt++] = c[i] + d[j];</span><br><span class="line">	&#125;</span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	sort(sum2 + <span class="number">1</span>, sum2 + cnt);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">		ll sum = sum1[i];</span><br><span class="line">		<span class="keyword">int</span> t;</span><br><span class="line">		t = upper_bound(sum2 + <span class="number">1</span>, sum2 + cnt, sum * <span class="number">-1</span>) - lower_bound(sum2 + <span class="number">1</span>, sum2 + cnt, sum * <span class="number">-1</span>);</span><br><span class="line">		ans += t;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; a[i] &lt;&lt; "    " &lt;&lt; b[j] &lt;&lt; "    " &lt;&lt; c[k] &lt;&lt; "    " &lt;&lt;sum&lt;&lt;"    "&lt;&lt; d[pos] &lt;&lt; endl;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>Trie树</title>
    <url>/2020/07/08/Trie%E6%A0%91/</url>
    <content><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>Trie树，又称单词查找树，字典树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。</p>
<a id="more"></a>

<p>Trie树的基本性质可以归纳为：<br>（1）根节点不包含字符，除根节点意外每个节点只包含一个字符。<br>（2）从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。<br>（3）每个节点的所有子节点包含的字符串不相同。<br>Trie树有一些特性：<br>1）根节点不包含字符，除根节点外每一个节点都只包含一个字符。<br>2）从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。<br>3）每个节点的所有子节点包含的字符都不相同。<br>4）如果字符的种数为n，则每个结点的出度为n，这也是空间换时间的体现，浪费了很多的空间。<br>5）插入查找的复杂度为O(n)，n为字符串长度。</p>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>首先，我们以ACA，ACB，AD，CEMD，CEMA五个字符串为例。</p>
<p><img src="https://ae01.alicdn.com/kf/H7150f1c375964412a4b38a2e5931f6e7G.jpg" alt=""></p>
<p>很显然，我们构建出来的Trie树就是这个样子。</p>
<h4 id="1、建树"><a href="#1、建树" class="headerlink" title="1、建树"></a>1、建树</h4><p>这边我使用的是数组的形式建树，其实用链表也是可以的。</p>
<p>我们以0为根节点，这个节点是不存放任何东西的。</p>
<p>我们从根节点开始，按照需要插入的字符串，一位一位的去判断是否指向该位。</p>
<p>当一个字符串到了结尾的时候，我们可以使用一个flag数组，来表明他是一个字符串的结尾。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> trie[N][<span class="number">26</span>],flag[N],tot;\\tot表示总结点数</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> now = <span class="number">0</span>, l = s.length();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> id = s[i] - <span class="string">'a'</span>;</span><br><span class="line">		<span class="keyword">if</span> (!trie[now][id])	trie[now][id] = ++tot;</span><br><span class="line">		now = trie[now][id];</span><br><span class="line">	&#125;</span><br><span class="line">	flag[now] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、查询"><a href="#2、查询" class="headerlink" title="2、查询"></a>2、查询</h4><p>我们可以从根节点开始查找，按s来一位一位判断，判断该节点是否存在指向这一位的节点的指针。</p>
<p>如果存在，就继续查找。</p>
<p>如果不存在，就直接返回0。</p>
<p>当你查找完成之后，如果最后一位的$flag=1$，说明存在，否则不存在。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> now = <span class="number">0</span>, l = s.length();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> id = s[i] - <span class="string">'a'</span>;</span><br><span class="line">		<span class="keyword">if</span> (!trie[now][id])	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		now = trie[now][id];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> flag[now];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="典型例题"><a href="#典型例题" class="headerlink" title="典型例题"></a>典型例题</h3><p>1、<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1251" target="_blank" rel="noopener">HDU 1251 统计难题</a></p>
<h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h4><p>Ignatius最近遇到一个难题,老师交给他很多单词(只有小写字母组成,不会有重复的单词出现),现在老师要他统计出以某个字符串为前缀的单词数量(单词本身也是自己的前缀)。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>因为题目需要求的是以某个单词为前缀的数量，那么我们只需要统计每一位的数量即可。</p>
<h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> trie[N][<span class="number">30</span>], cnt[N],tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> now = <span class="number">0</span>, l = s.length();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> id = s[i] - <span class="string">'a'</span>;</span><br><span class="line">		<span class="keyword">if</span> (!trie[now][id])	trie[now][id] = ++tot;</span><br><span class="line">		cnt[now]++;</span><br><span class="line">		now = trie[now][id];</span><br><span class="line">	&#125;</span><br><span class="line">	cnt[now]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> now = <span class="number">0</span>, l = s.length();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> id = s[i] - <span class="string">'a'</span>;</span><br><span class="line">		<span class="keyword">if</span> (!trie[now][id])	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		now = trie[now][id];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cnt[now];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">string</span> s;</span><br><span class="line">	<span class="keyword">while</span> (getline(<span class="built_in">cin</span>, s) &amp;&amp; s.length() != <span class="number">0</span>) &#123;</span><br><span class="line">		insert(s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; search(s) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1075" target="_blank" rel="noopener">HDU 1075 What Are You Talking About</a></p>
<h4 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h4><p>输入几对单词，每对单词存在着对应关系，之后输入一些句子，你需要将其中的单词进行翻译，如果不存在对应关系，则不需要翻译，标点符号不需要翻译。</p>
<h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>很明显的Trie树模板，只需要将每个单词的结尾记录一下对应的单词即可。</p>
<h4 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> trie[N][<span class="number">30</span>], tot,flag[N];</span><br><span class="line"><span class="built_in">string</span> ch[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> s1,<span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> now = <span class="number">0</span>, l = s1.length();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> id = s1[i] - <span class="string">'a'</span>;</span><br><span class="line">		<span class="keyword">if</span> (!trie[now][id])	trie[now][id] = ++tot;</span><br><span class="line">		now = trie[now][id];</span><br><span class="line">	&#125;</span><br><span class="line">	flag[now] = <span class="number">1</span>;</span><br><span class="line">	ch[now] = s2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> now = <span class="number">0</span>, l = s.length();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> id = s[i] - <span class="string">'a'</span>;</span><br><span class="line">		<span class="keyword">if</span> (!trie[now][id]) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; s;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		now = trie[now][id];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (flag[now])	<span class="built_in">cout</span> &lt;&lt; ch[now];</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">string</span> s1, s2;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; s1;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span>&gt;&gt;s1&amp;&amp;s1!=<span class="string">"END"</span>) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; s2;</span><br><span class="line">		insert(s2, s1);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cin</span>.<span class="built_in">get</span>();<span class="comment">//吸收回车</span></span><br><span class="line">	<span class="keyword">while</span> (getline(<span class="built_in">cin</span>,s1)&amp;&amp;s1!=<span class="string">"END"</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> l = s1.length();</span><br><span class="line">		<span class="keyword">if</span> (s1 == <span class="string">"START"</span>)	<span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">string</span> s;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (s1[i] &gt;= <span class="string">'a'</span> &amp;&amp; s1[i] &lt;= <span class="string">'z'</span>)	s += s1[i];</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				search(s);</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; s1[i];</span><br><span class="line">				s.<span class="built_in">clear</span>();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>stringstream使用总结</title>
    <url>/2020/07/08/stringstream%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>使用stringstream需要头文件#include &lt; sstream &gt;。</p>
<p>stringstream一般用于输入一行字符串，以空格为分隔符把该行分隔开来。</p>
<p>经常用于格式转换，相当的好用。</p>
<p>还是不太熟练，所以来总结一下。</p>
<a id="more"></a>

<h3 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">stringstream</span> ss;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">ss&lt;&lt;s;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">ss&gt;&gt;a;<span class="comment">//字符串转int或者long long</span></span><br><span class="line"><span class="keyword">double</span> b;</span><br><span class="line">ss&gt;&gt;b;<span class="comment">//字符串转float或者double</span></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">ss&lt;&lt;a;</span><br><span class="line">ss&gt;&gt;s;<span class="comment">//int转字符串</span></span><br><span class="line">ss&lt;&lt;b;</span><br><span class="line">ss&gt;&gt;s;<span class="comment">//double转字符串</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">stringstream</span> ss;</span><br><span class="line">getline(<span class="built_in">cin</span>,s);<span class="comment">//读取一行</span></span><br><span class="line">ss&lt;&lt;s;</span><br><span class="line"><span class="keyword">while</span>(ss)&#123;</span><br><span class="line">	ss&gt;&gt;s;<span class="comment">//分割字符串</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">double</span> b;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line">s=to_string(a);<span class="comment">//int转字符串</span></span><br><span class="line">s=to_string(b);<span class="keyword">double</span>转字符串</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">a=stoi(s);<span class="comment">//字符串转int</span></span><br><span class="line">b=stod(s);<span class="comment">//字符串转double</span></span><br></pre></td></tr></table></figure>

<p>如果多次使用，并且使用之后stringstream不为空，记住需要清空stringstream。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stringstream</span> ss;</span><br><span class="line"><span class="comment">// 如下两部可彻底恢复ss，单独的clear是没办法清空的</span></span><br><span class="line">ss.<span class="built_in">clear</span>(); <span class="comment">// 恢复状态</span></span><br><span class="line">ss.str(<span class="string">""</span>); <span class="comment">// 恢复值</span></span><br></pre></td></tr></table></figure>

<p>如果希望按照其他的字符分割，需要将读取的方式进行修改。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> data = <span class="string">"1,2,3,4,5,6"</span>;</span><br><span class="line"><span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(data)</span></span>;<span class="comment">//或者</span></span><br><span class="line">ss&lt;&lt;data;</span><br><span class="line"><span class="built_in">string</span> item;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">while</span> (getline(ss, item, <span class="string">','</span>))</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; item &lt;&lt; <span class="string">' '</span>;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>stringstream</tag>
      </tags>
  </entry>
  <entry>
    <title>priority_queue使用总结</title>
    <url>/2020/08/03/priority_queue%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>最近刚好在补STL的题，顺便来总结一下。</p>
<p>普通的队列是按照进队的先后来决定优先级的，即先进先出。</p>
<p>而优先队列则是按照优先级来排序的，这点与普通的队列不同。</p>
<p>如果你按照大小来决定优先级的话，相同的大小的顺序并不是按照进队的先后来决定的，这里算是之前不知道的知识。</p>
<p>即优先级高的先出。</p>
<a id="more"></a>

<h3 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h3><p>正常的使用，按照大小来决定优先级。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt; q1;<span class="comment">//升序</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt;&gt; q2;<span class="comment">//降序，默认降序</span></span><br><span class="line"></span><br><span class="line">q1.push(<span class="number">3</span>);q1.push(<span class="number">2</span>);q1.push(<span class="number">1</span>)<span class="comment">//1,2,3</span></span><br><span class="line">q2.push(<span class="number">1</span>);q2.push(<span class="number">2</span>);q2.push(<span class="number">3</span>)<span class="comment">//3,2,1</span></span><br></pre></td></tr></table></figure>

<p>如果是pair类型，则是先比较第一个，再比较第二个。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; a;</span><br><span class="line">pair&lt;int, int&gt; b(1, 2);</span><br><span class="line">pair&lt;int, int&gt; c(1, 3);</span><br><span class="line">pair&lt;int, int&gt; d(2, 5);</span><br><span class="line">a.push(d);</span><br><span class="line">a.push(c);</span><br><span class="line">a.push(b);</span><br><span class="line"><span class="comment">// d,c,b</span></span><br></pre></td></tr></table></figure>

<p>如果需要自定义类型，则需要手写仿函数或者在结构体中重载运算符。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ty</span> //运算符重载 &lt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class">    int x;</span></span><br><span class="line"><span class="class">    ty(int a) &#123;x = a;&#125;</span></span><br><span class="line"><span class="class">    bool operator&lt;(const tmp1&amp; a) const&#123;</span></span><br><span class="line"><span class="class">        return x &lt; a.x; //降序</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">&#125;;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">//方法2</span></span><br><span class="line"><span class="class">struct cmp //重写仿函数</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class">    bool operator() (ty a, ty b)&#123;</span></span><br><span class="line"><span class="class">        return a.x &lt; b.x; //降序</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">&#125;;</span></span><br><span class="line"><span class="class">priority_queue&lt;ty&gt; q1;</span></span><br><span class="line"><span class="class">priority_queue&lt;ty,vector&lt;ty&gt;,cmp&gt; q2;</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>priority queue</tag>
      </tags>
  </entry>
  <entry>
    <title>lower_bound和upper_bound的使用方法</title>
    <url>/2020/10/18/lower_bound%E5%92%8Cupper_bound%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>刚好最近在给学弟学妹讲二分，应该是我没讲明白。。</p>
<p>还是写出来比较好。</p>
<p>lower_bound和upper_bound的头文件都是algorithm。</p>
<p>需要传入三个参数，数组头begin，数组尾end，以及你需要查找的数num。</p>
<p>在使用时，需要保证数组（容器）需要有序。</p>
<p>最好是递增的，因为递减需要重载，之前没讲清楚。。</p>
<p>递增数组</p>
<p>lower_bound( begin,end,num)，即在begin到end-1中查找第一个大于等于的数，并且返回该数的地址，减去begin之后，得到与begin的相对位置。</p>
<p>upper_bound与lower_bound使用方法相同，但是查找的是第一个大于的数，不会查找等于的。</p>
<p>递减数组</p>
<p>lower_bound( begin,end,num,greater&lt; Type &gt;() )，即在begin到end-1中查找第一个小于等于的数，并且返回该数的地址，减去begin之后，得到与begin的相对位置。</p>
<p>upper_bound与lower_bound使用方法相同，但是查找的是第一个小于的数，不会查找等于的。</p>
<p>greater函数头文件是functional。</p>
<p>注意二分的范围是begin~end-1。</p>
<a id="more"></a>

<h3 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> num[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	sort(num, num + n);							         <span class="comment">//按从小到大排序 </span></span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">find</span>; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;<span class="built_in">find</span>);</span><br><span class="line">	<span class="keyword">int</span> pos1 = lower_bound(num, num + n, <span class="built_in">find</span>) - num;    <span class="comment">//返回数组中第一个大于或等于被查找的数</span></span><br><span class="line">	<span class="keyword">int</span> pos2 = upper_bound(num, num + n, <span class="built_in">find</span>) - num;    <span class="comment">//返回数组中第一个大于被查找的数</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, pos1, num[pos1]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, pos2, num[pos2]);</span><br><span class="line">	sort(num, num + <span class="number">6</span>, greater&lt;<span class="keyword">int</span>&gt;());                             <span class="comment">//按从大到小排序</span></span><br><span class="line">	<span class="keyword">int</span> pos3 = lower_bound(num, num + n, <span class="built_in">find</span>, greater&lt;<span class="keyword">int</span>&gt;()) - num;  <span class="comment">//返回数组中第一个小于或等于被查找的数 </span></span><br><span class="line">	<span class="keyword">int</span> pos4 = upper_bound(num, num + n, <span class="built_in">find</span>, greater&lt;<span class="keyword">int</span>&gt;()) - num;  <span class="comment">//返回数组中第一个小于被查找的数 </span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, pos3, num[pos3]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, pos4, num[pos4]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树和平衡树</title>
    <url>/2020/07/08/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%92%8C%E5%B9%B3%E8%A1%A1%E6%A0%91/</url>
    <content><![CDATA[<h3 id="二叉搜索树基本介绍"><a href="#二叉搜索树基本介绍" class="headerlink" title="二叉搜索树基本介绍"></a>二叉搜索树基本介绍</h3><p>给定一棵二叉树，树上的每一个节点带有一个数值，称为节点的关键值$val$。</p>
<p>对于树上的每一个节点：</p>
<blockquote>
<p>1、该节点的关键码不小于它的左子树任意节点的关键码</p>
<p>2、该节点的关键码不大于它的右子树任意节点的关键码</p>
</blockquote>
<p>这样的树就叫做二叉查找树（二叉排序树），即BST。</p>
<a id="more"></a>

<p>显然二叉查找树的中序遍历就是一个按照关键值递增的节点序列。</p>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><h4 id="1、建树"><a href="#1、建树" class="headerlink" title="1、建树"></a>1、建树</h4><p>我们可以建立两个初始节点，一个点的值为$INF$，另一个为$-INF$。</p>
<p>（书上说可以避免越界，减少边界的特殊情况）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>, N = <span class="number">1e6</span>;</span><br><span class="line"><span class="keyword">int</span> tot, root;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> l, r, val;</span><br><span class="line">&#125;a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">New</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">	a[++tot].val = val;</span><br><span class="line">    <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	New(-INF), New(INF), root = <span class="number">1</span>, a[<span class="number">1</span>].r = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、搜索"><a href="#2、搜索" class="headerlink" title="2、搜索"></a>2、搜索</h4><p>从根节点开始搜索，分为三种情况</p>
<p>1、若val等于p的关键值，表示已经找到，直接退出</p>
<p>2、若val大于p的关键值</p>
<blockquote>
<p>1、若p的右节点为空，说明不存在val</p>
<p>2、若p的右节点不为空，在右子树中进行递归查找</p>
</blockquote>
<p>3、若val小于p的关键值</p>
<blockquote>
<p>1、若p的左节点为空，说明不存在val</p>
<p>2、若p的左节点不为空，在左子树中进行递归查找</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="number">0</span>)	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (val == a[p].val)	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> val &gt; a[p].val ? search(a[p].r, val) : search(a[p].l, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、插入"><a href="#3、插入" class="headerlink" title="3、插入"></a>3、插入</h4><p>当我们发现走向p节点的子节点为空时，说明不存在，直接建立新节点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;p,<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="number">0</span>) &#123;</span><br><span class="line">		p = New(val);<span class="comment">//这里是引用，其父节点l，r同时也会被更新</span></span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (val == a[p].val)	<span class="keyword">return</span> ;</span><br><span class="line">	val &gt; a[p].val ? insert(a[p].r, val) : insert(a[p].l, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4、求前驱后继"><a href="#4、求前驱后继" class="headerlink" title="4、求前驱后继"></a>4、求前驱后继</h4><p>前驱就是在BST中关键值小于val的情况下，关键值最大的节点，而后继就是在BST中关键值大于val的情况下，关键值最小的节点。</p>
<p>这里以后继为例。</p>
<p>分为三种情况。</p>
<blockquote>
<p>1、没有找到val,说明val的后继已经在所遍历的节点中，ans即为所求</p>
<p>2、找到了关键值为val的节点p,但是该节点没有右子树，结果和1一样</p>
<p>3、找到了关键值为val的节点p，且有右子树，则从它的右子节点开始遍历，从左走，就找到了val的后继</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetNext</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">2</span>;<span class="comment">//a[p].val为INF</span></span><br><span class="line">	<span class="keyword">int</span> p = root;</span><br><span class="line">	<span class="keyword">while</span> (p) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[p].val == val) &#123;</span><br><span class="line">			<span class="keyword">if</span> (a[p].r) &#123;</span><br><span class="line">				p = a[p].r;</span><br><span class="line">				<span class="keyword">while</span> (p) p = a[p].l;</span><br><span class="line">				ans = p;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (a[p].val &gt; val &amp;&amp; a[p].val &lt; a[ans].val)	ans = p;<span class="comment">//不断更新</span></span><br><span class="line">		p = a[p].val &gt; val ? a[p].l : a[p].r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4、删除"><a href="#4、删除" class="headerlink" title="4、删除"></a>4、删除</h4><p>我们先查找到关键值为val的节点p。</p>
<p>若p的子节点数小于二，那么直接删除P，令p的子节点代替p的位置，与p的父节点相连。</p>
<p>若p既有左子树又有右子树，那么就先求出val的后继节点next,然后直接删除next(没有左子树)，并令next的右子树代替next的位置，最后让next节点代替p，删除p即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> &amp;p,<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!p)	<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (val == a[p].val) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!a[p].l)	p = a[p].r;<span class="comment">//左子树为空</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!a[p].r)	p = a[p].l;<span class="comment">//右子树为空</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">int</span> next = a[p].r;</span><br><span class="line">			<span class="keyword">while</span> (a[next].l)	next = a[p].l;<span class="comment">//找到后缀</span></span><br><span class="line">			<span class="built_in">remove</span>(a[p].r, a[next].val);<span class="comment">//删除后缀</span></span><br><span class="line">			a[next].l = a[p].l, a[next].r = a[p].r, p = next;<span class="comment">//用后缀来替代p</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	val &gt; a[p].val ? <span class="built_in">remove</span>(a[p].r, val) : <span class="built_in">remove</span>(a[p].l, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为数据的随机性，很有可能BST会变成链，那么时间复杂度又会从$O(logN)$变成$O(n)$。</p>
<p>所以出现了平衡树。</p>
<h3 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h3><p>（平衡树还不是很会啊。。</p>
<p>这边先放一下模板吧</p>
<p>到时候会了再补上。</p>
<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p><a href="https://www.acwing.com/problem/content/255/" target="_blank" rel="noopener">普通平衡树</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ycx的代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, INF = <span class="number">1e8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">int</span> key, val;</span><br><span class="line">    <span class="keyword">int</span> cnt, <span class="built_in">size</span>;</span><br><span class="line">&#125;tr[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> root, idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p].<span class="built_in">size</span> = tr[tr[p].l].<span class="built_in">size</span> + tr[tr[p].r].<span class="built_in">size</span> + tr[p].cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_node</span><span class="params">(<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[ ++ idx].key = key;</span><br><span class="line">    tr[idx].val = rand();</span><br><span class="line">    tr[idx].cnt = tr[idx].<span class="built_in">size</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zig</span><span class="params">(<span class="keyword">int</span> &amp;p)</span>    <span class="comment">// 右旋</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> q = tr[p].l;</span><br><span class="line">    tr[p].l = tr[q].r, tr[q].r = p, p = q;</span><br><span class="line">    pushup(tr[p].r), pushup(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zag</span><span class="params">(<span class="keyword">int</span> &amp;p)</span>    <span class="comment">// 左旋</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> q = tr[p].r;</span><br><span class="line">    tr[p].r = tr[q].l, tr[q].l = p, p = q;</span><br><span class="line">    <span class="comment">//之前一直对这个东西保有疑惑，后面发现必须要配合insert(&amp;p,val)和remove(&amp;p，key)来理解</span></span><br><span class="line">    pushup(tr[p].l), pushup(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    get_node(-INF), get_node(INF);</span><br><span class="line">    root = <span class="number">1</span>, tr[<span class="number">1</span>].r = <span class="number">2</span>;</span><br><span class="line">    pushup(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tr[<span class="number">1</span>].val &lt; tr[<span class="number">2</span>].val) zag(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;p, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) p = get_node(key);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tr[p].key == key) tr[p].cnt ++ ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tr[p].key &gt; key)</span><br><span class="line">    &#123;</span><br><span class="line">        insert(tr[p].l, key);</span><br><span class="line">        <span class="keyword">if</span> (tr[tr[p].l].val &gt; tr[p].val) zig(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        insert(tr[p].r, key);</span><br><span class="line">        <span class="keyword">if</span> (tr[tr[p].r].val &gt; tr[p].val) zag(p);</span><br><span class="line">    &#125;</span><br><span class="line">    pushup(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> &amp;p, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (tr[p].key == key)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (tr[p].cnt &gt; <span class="number">1</span>) tr[p].cnt -- ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tr[p].l || tr[p].r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!tr[p].r || tr[tr[p].l].val &gt; tr[tr[p].r].val)</span><br><span class="line">            &#123;</span><br><span class="line">                zig(p);</span><br><span class="line">                <span class="built_in">remove</span>(tr[p].r, key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                zag(p);</span><br><span class="line">                <span class="built_in">remove</span>(tr[p].l, key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> p = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tr[p].key &gt; key) <span class="built_in">remove</span>(tr[p].l, key);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">remove</span>(tr[p].r, key);</span><br><span class="line"></span><br><span class="line">    pushup(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_rank_by_key</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> key)</span>    <span class="comment">// 通过数值找排名</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">// 本题中不会发生此情况</span></span><br><span class="line">    <span class="keyword">if</span> (tr[p].key == key) <span class="keyword">return</span> tr[tr[p].l].<span class="built_in">size</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (tr[p].key &gt; key) <span class="keyword">return</span> get_rank_by_key(tr[p].l, key);</span><br><span class="line">    <span class="keyword">return</span> tr[tr[p].l].<span class="built_in">size</span> + tr[p].cnt + get_rank_by_key(tr[p].r, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_key_by_rank</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> rank)</span>   <span class="comment">// 通过排名找数值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> INF;     <span class="comment">// 本题中不会发生此情况</span></span><br><span class="line">    <span class="keyword">if</span> (tr[tr[p].l].<span class="built_in">size</span> &gt;= rank) <span class="keyword">return</span> get_key_by_rank(tr[p].l, rank);</span><br><span class="line">    <span class="keyword">if</span> (tr[tr[p].l].<span class="built_in">size</span> + tr[p].cnt &gt;= rank) <span class="keyword">return</span> tr[p].key;</span><br><span class="line">    <span class="keyword">return</span> get_key_by_rank(tr[p].r, rank - tr[tr[p].l].<span class="built_in">size</span> - tr[p].cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_prev</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> key)</span>   <span class="comment">// 找到严格小于key的最大数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> -INF;</span><br><span class="line">    <span class="keyword">if</span> (tr[p].key &gt;= key) <span class="keyword">return</span> get_prev(tr[p].l, key);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(tr[p].key, get_prev(tr[p].r, key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_next</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> key)</span>    <span class="comment">// 找到严格大于key的最小数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">if</span> (tr[p].key &lt;= key) <span class="keyword">return</span> get_next(tr[p].r, key);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(tr[p].key, get_next(tr[p].l, key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    build();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> opt, x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;opt, &amp;x);</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>) insert(root, x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">2</span>) <span class="built_in">remove</span>(root, x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, get_rank_by_key(root, x) - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">4</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, get_key_by_rank(root, x + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">5</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, get_prev(root, x));</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, get_next(root, x));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>BST</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ-2478 Farey Sequence 题解</title>
    <url>/2020/11/06/poj-2478-Farey-Sequence-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://poj.org/problem?id=2478" target="_blank" rel="noopener">题目大意</a></h3><p>法理序列Fn是指对于任意整数n( n &gt;= 2)，由不可约的分数a/b（0 &lt; a &lt; b &lt;= n），gcd(a,b) = 1升序排列构成的序列，最开始的几个如下<br>F2 = {1/2}<br>F3 = {1/3, 1/2, 2/3}<br>F4 = {1/4, 1/3, 1/2, 2/3, 3/4}<br>F5 = {1/5, 1/4, 1/3, 2/5, 1/2, 3/5, 2/3, 3/4, 4/5}</p>
<p>你的任务是计算法理序列Fn中的元素个数。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>裸的欧拉函数。</p>
<p>欧拉函数：对于一个正整数n，小于n且和n互质的正整数（包括1 ）的个数，记做φ(n) 。</p>
<p>通式：$φ(x)=x\times (1-1/p1)\times (1-1/p2)\times (1-1/p3)\times (1-1/p4)…..(1-1/pn)$,其中$p1,p2,···,pn$为x的所有质因子（不包括1，1不是质数），x是不为0的整数。$φ(1)=1$（唯一和1互质的数就是1本身）。</p>
<p>直接用埃氏筛，枚举到质数时，对于每个他的倍数，乘上$\Large \frac{p_i - 1}{p_i}$即可。</p>
<p>但是每输入一遍就跑一遍会超时，所以可以提前跑一遍最大值，然后前缀和，输出答案即可。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for (ll i=a;i&lt;=n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,n) for (ll i=n;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(x,y) make_pair(x,y)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bg begin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rbg rbegin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ed end</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dbg(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">"==="</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> prime[N], les[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)	ans *= a;</span><br><span class="line">		a &lt;&lt;= <span class="number">1</span>, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(ll maxn)</span> </span>&#123;</span><br><span class="line">	cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (ll i = <span class="number">2</span>; i &lt;= maxn; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">			<span class="keyword">for</span> (ll j = <span class="number">2</span>; i * j &lt;= maxn; j++) &#123;</span><br><span class="line">				vis[i * j] = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span> (!les[i * j])	les[i * j] = i * j;</span><br><span class="line">				les[i * j] = les[i * j] / i * (i - <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\in.txt", "r", stdin);</span></span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\out.txt", "w+", stdout);</span></span><br><span class="line">	ll n;</span><br><span class="line">	init(N - <span class="number">5</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N - <span class="number">5</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(les[i]) les[i] = i - <span class="number">1</span> - les[i];</span><br><span class="line">		les[i] += les[i - <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n) &#123;</span><br><span class="line">		ll ans = n * (n - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">		ans -= les[n];</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>欧拉函数</tag>
        <tag>质数筛</tag>
      </tags>
  </entry>
  <entry>
    <title>哈理工第十届程序设计竞赛 F 三角形 题解</title>
    <url>/2020/07/08/%E5%93%88%E7%90%86%E5%B7%A5%E7%AC%AC%E5%8D%81%E5%B1%8A%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B-F-%E4%B8%89%E8%A7%92%E5%BD%A2-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://ac.nowcoder.com/acm/contest/5758/F" target="_blank" rel="noopener">题目大意</a></h3><p>小明有一根长度为a的木棒，现在小明想将木棒分为多段（每段木棒长度必须为整数），<br>使得分隔后的木棍中，取出的任意三段都不能构成三角形，小明想知道木棒最多被分成几段？</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>由斐波那契数列得到，最佳的情况是每一段长度由斐波那契数列构成的。</p>
<p>因为斐波那契数列刚好是$a+b=c$，所以都不能构成三角形。</p>
<p>（可能这世界上就我不知道了吧。。</p>
<p>那我只需要构造出一个斐波那契数列的前缀和数组。</p>
<p>对这个数组进行二分查找即可。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> n[<span class="number">200</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">double</span> c = <span class="number">1</span>, cq = <span class="number">1</span>;</span><br><span class="line">	n[<span class="number">1</span>] = <span class="number">1</span>, n[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= <span class="number">150</span>; i++) &#123;</span><br><span class="line">		n[i] = n[i - <span class="number">1</span>] + c+cq;</span><br><span class="line">		swap(c, cq);</span><br><span class="line">		c += cq;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">double</span> a;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">		<span class="keyword">int</span> pos = upper_bound(n + <span class="number">1</span>, n + <span class="number">150</span>, a) - n;</span><br><span class="line">		pos--;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; pos &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
        <tag>打表</tag>
        <tag>二分查找</tag>
        <tag>斐波那契</tag>
      </tags>
  </entry>
  <entry>
    <title>哈理工第十届程序设计竞赛 B 减成一 题解</title>
    <url>/2020/07/08/%E5%93%88%E7%90%86%E5%B7%A5%E7%AC%AC%E5%8D%81%E5%B1%8A%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B-B-%E5%87%8F%E6%88%90%E4%B8%80-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://ac.nowcoder.com/acm/contest/5758/B" target="_blank" rel="noopener">题目大意</a></h3><p>给你一些数字，你可以进行一种操作，令一个区间的数字减少1，问令这些数字全为1的最小操作数。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这题刚刚开始看的时候完全没思路。</p>
<p>后面感谢大佬抬我一手。</p>
<p>这就是一道纯差分题。</p>
<p>（我感觉自己都不会差分。。跟没学过一样。</p>
<p>上次比赛也是一道差分题卡了我好久。</p>
<p>对这一串数字进行构造差分数组。</p>
<p>由题意得，这种操作可以变成在差分数组中选取一位减1，一位加1。</p>
<p>而最终的数组应该除了第一位为1以外，其他的都为0。</p>
<p><img src="https://ae01.alicdn.com/kf/Hb766e75c07844c0393a776f4583eb870v.jpg" alt=""></p>
<p>所以最终的答案就是所有大于0的数加起来减一。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>;</span><br><span class="line">ll num[N],cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; num[i];</span><br><span class="line">			cnt[i] = num[i] - num[i - <span class="number">1</span>];<span class="comment">//构造差分数组</span></span><br><span class="line">		&#125;</span><br><span class="line">		ll ans = cnt[<span class="number">1</span>]<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (cnt[i] &gt; <span class="number">0</span>)	ans += cnt[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title>区间dp</title>
    <url>/2020/07/08/%E5%8C%BA%E9%97%B4dp/</url>
    <content><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>区间dp，简单来说就是以一个子区间为最小元素，一步步递推到根区间的过程。就是通过一个个小区间的最优解来推出大区间的最优解的过程。</p>
<a id="more"></a>

<h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><p>（区间dp好难啊啊。。不是很理解啊</p>
<p>一般的思路就是，我们需要求大区间的最优解，那么我可以把这个大区间分隔成一个个小区间，找出每个小区间的最优解，然后将这一个个小区间进行合并，得到大区间的最优解。</p>
<p>一般的情况下，是通过枚举区间的长度$len$，作为阶段，然后得到一个区间的$l$和$r$，作为状态，然后在这个区间中枚举分隔点$k$，取得最优解。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n; len++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - len + <span class="number">1</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt; j; k++) &#123;</span><br><span class="line">				dpm[i][j] = <span class="built_in">min</span>(dpm[i][j], dpm[i][k] + dpm[k + <span class="number">1</span>][j] + c[j] - c[i - <span class="number">1</span>]);</span><br><span class="line">				dpM[i][j] = <span class="built_in">max</span>(dpM[i][j], dpM[i][k] + dpM[k + <span class="number">1</span>][j] + c[j] - c[i - <span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四边形优化"><a href="#四边形优化" class="headerlink" title="四边形优化"></a>四边形优化</h3><p>自己不是很会四边形优化，就不怎么详细讲解了。</p>
<p>详细讲解点<a href="https://blog.csdn.net/NOIAu/article/details/72514812" target="_blank" rel="noopener">这里</a>。</p>
<p>就讲一下我稍微懂的一点吧，以后再补吧，真的dp不能足够的理解，就很头痛。</p>
<p>如果需要证明四边形优化是否成立的话，可以使用打表的形式，观察是否$p[i][j-1]\leq p[i][j]\leq p[i+1][j]$。</p>
<p>如果成立便可以使用四边形优化。</p>
<p>对石子合并来说的，最小值可以使用四边形优化，但是最大值不能。</p>
<p>这里贴一下模板吧。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _rep(i, a, b) for (int i = (a); i &lt;= (b); ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _rev(i, a, b) for (int i = (a); i &gt;= (b); --i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _for(i, a, b) for (int i = (a); i &lt; (b); ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _rof(i, a, b) for (int i = (a); i &gt; (b); --i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> oo 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 0.00001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(), x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> met(a, b) memset(a, b, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> id(x) ((x + 8))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> what_is(x) cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) x &amp;(-x)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e3</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e6</span> + <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> dpmin[maxn][maxn], n, a[maxn], dpmax[maxn][maxn], sum[maxn], kma[maxn][maxn], kmi[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	met(dpmin, oo);</span><br><span class="line">	_rep(i, <span class="number">1</span>, n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">		a[i + n] = a[i];</span><br><span class="line">		dpmin[i][i] = dpmin[i + n][i + n] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	_rep(i, <span class="number">1</span>, <span class="number">2</span> * n) &#123;</span><br><span class="line">		sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">		kmi[i][i] = kma[i][i] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	_rep(len, <span class="number">2</span>, n)</span><br><span class="line">	&#123;</span><br><span class="line">		_rep(l, <span class="number">1</span>, <span class="number">2</span> * n - len + <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> r = l + len - <span class="number">1</span>;</span><br><span class="line">			_rep(k, l, r - <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="comment">/*dpmax[l][r] = max(dpmax[l][k] + dpmax[k + 1][r] + sum[r] - sum[l - 1], dpmax[l][r]);</span></span><br><span class="line"><span class="comment">				dpmin[l][r] = min(dpmin[l][k] + dpmin[k + 1][r] + sum[r] - sum[l - 1], dpmin[l][r]);*/</span></span><br><span class="line">				<span class="keyword">if</span> (dpmax[l][k] + dpmax[k + <span class="number">1</span>][r] + sum[r] - sum[l - <span class="number">1</span>] &gt; dpmax[l][r]) &#123;</span><br><span class="line">					dpmax[l][r] = dpmax[l][k] + dpmax[k + <span class="number">1</span>][r] + sum[r] - sum[l - <span class="number">1</span>];</span><br><span class="line">					kma[l][r] = k;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (dpmin[l][k] + dpmin[k + <span class="number">1</span>][r] + sum[r] - sum[l - <span class="number">1</span>] &lt; dpmin[l][r]) &#123;</span><br><span class="line">					dpmin[l][r] = dpmin[l][k] + dpmin[k + <span class="number">1</span>][r] + sum[r] - sum[l - <span class="number">1</span>];</span><br><span class="line">					kmi[l][r] = k;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	_rep(i, <span class="number">1</span>, n + <span class="number">1</span>) &#123;</span><br><span class="line">		_rep(j, i+<span class="number">1</span>, i + n<span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="comment">//assert(kma[i][j - 1] &lt;= kma[i][j] &amp;&amp; kma[i][j] &lt;= kma[i + 1][j]);</span></span><br><span class="line">			<span class="comment">//assert(kmi[i][j - 1] &lt;= kmi[i][j] &amp;&amp; kmi[i][j] &lt;= kmi[i + 1][j]);</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"kma[%d][%d]=%d &lt;= kma[%d][%d]=%d &lt;= kma[%d][%d]=%d "</span>,i,j<span class="number">-1</span>,kma[i][j<span class="number">-1</span>],i,j,kma[i][j],i+<span class="number">1</span>,j,kma[i+<span class="number">1</span>][j]);</span><br><span class="line">			<span class="keyword">if</span>(kma[i][j - <span class="number">1</span>] &lt;= kma[i][j] &amp;&amp; kma[i][j] &lt;= kma[i + <span class="number">1</span>][j])	<span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	_rep(i, <span class="number">1</span>, n + <span class="number">1</span>) &#123;</span><br><span class="line">		_rep(j, i+<span class="number">1</span>, i + n<span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="comment">//assert(kma[i][j - 1] &lt;= kma[i][j] &amp;&amp; kma[i][j] &lt;= kma[i + 1][j]);</span></span><br><span class="line">			<span class="comment">//assert(kmi[i][j - 1] &lt;= kmi[i][j] &amp;&amp; kmi[i][j] &lt;= kmi[i + 1][j]);</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"kmi[%d][%d]=%d &lt;= kmi[%d][%d]=%d &lt;= kmi[%d][%d]=%d "</span>,i,j<span class="number">-1</span>,kmi[i][j<span class="number">-1</span>],i,j,kmi[i][j],i+<span class="number">1</span>,j,kmi[i+<span class="number">1</span>][j]);</span><br><span class="line">			<span class="keyword">if</span>(kmi[i][j - <span class="number">1</span>] &lt;= kmi[i][j] &amp;&amp; kmi[i][j] &lt;= kmi[i + <span class="number">1</span>][j])	<span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于最大值来说，他区间$[i,j]$的最大值，等于区间$[i,j−1]$和$[i+1,j]$中的最大值加上$w(i,j)$。</p>
<p>因为区间$[i+1,j-1]$的最大值是相同的，只需要看先合并左边还是先合并右边了，取其中的最大值。</p>
<h3 id="典型例题"><a href="#典型例题" class="headerlink" title="典型例题"></a>典型例题</h3><p><a href="https://www.luogu.com.cn/problem/P1880" target="_blank" rel="noopener">洛谷-P1880 石子合并</a></p>
<h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h4><p>有一圈石子，你需要把他们合成一堆，求最小花费和最大花费。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>模板题。</p>
<h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">310</span>, INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> dpm[N][N],dpM[N][N], p[N], num[N], c[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="built_in">memset</span>(dpm, <span class="number">127</span>, <span class="keyword">sizeof</span>(dpm));</span><br><span class="line">	<span class="built_in">memset</span>(dpM, <span class="number">0</span>, <span class="keyword">sizeof</span>(dpM));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; num[i],num[i+n] = num[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i++) c[i] = c[i - <span class="number">1</span>] + num[i], dpm[i][i] = <span class="number">0</span>, dpM[i][i] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n; len++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span>*n - len + <span class="number">1</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt; j; k++) &#123;</span><br><span class="line">				dpm[i][j] = <span class="built_in">min</span>(dpm[i][j], dpm[i][k] + dpm[k + <span class="number">1</span>][j] + c[j] - c[i - <span class="number">1</span>]);</span><br><span class="line">				dpM[i][j] = <span class="built_in">max</span>(dpM[i][j], dpM[i][k] + dpM[k + <span class="number">1</span>][j] + c[j] - c[i - <span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans1 = <span class="number">1e9</span>, ans2 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		ans1 = <span class="built_in">min</span>(ans1, dpm[i][i + n - <span class="number">1</span>]);</span><br><span class="line">		ans2 = <span class="built_in">max</span>(ans2, dpM[i][i + n - <span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>数位DP</title>
    <url>/2020/07/08/%E6%95%B0%E4%BD%8DDP/</url>
    <content><![CDATA[<h3 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h3><p>简单来说，数位DP就是在数的每一位上进行DP，可以说是另类的暴力枚举了。</p>
<p>相比于简单的暴力枚举来说，数位DP具有记忆化的特点。</p>
<p>其实我感觉数位DP和状压DP有一点类似。</p>
<p>也是对每一位来进行DP。</p>
<a id="more"></a>

<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>刚好我们学长给我们贴了模板，那我就直接贴上来吧。</p>
<p>注意事项都是在代码里面了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> sta, <span class="keyword">bool</span> lead<span class="comment">/*前导 0，不是所有题目都有，题目不同不一样*/</span>, <span class="keyword">bool</span> limit<span class="comment">/*判断数位上限*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//递归边界</span></span><br><span class="line">    <span class="keyword">if</span>(pos == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//返回值因题而异</span></span><br><span class="line">    <span class="comment">//记忆化</span></span><br><span class="line">    <span class="keyword">if</span>(!limit &amp;&amp; !lead &amp;&amp; dp[pos][sta] == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[pos][sta];</span><br><span class="line">    <span class="keyword">int</span> len = limit?a[pos]:<span class="number">9</span>; <span class="comment">//判断上限</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//开始计数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//剪枝与状态转移</span></span><br><span class="line">        <span class="keyword">if</span>()</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>()</span><br><span class="line">        ans += dfs(pos - <span class="number">1</span>, sta<span class="comment">/*转移的状态*/</span>,lead &amp;&amp; i == <span class="number">0</span>, limit &amp;&amp; i == a[pos]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//完成记忆化</span></span><br><span class="line">    <span class="keyword">if</span>(!limit)</span><br><span class="line">        dp[pos][sta] = ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x) <span class="comment">// 分解数位</span></span><br><span class="line">    &#123;</span><br><span class="line">        a[pos ++] = x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dfs(pos - <span class="number">1</span>, <span class="number">-1</span>, <span class="literal">true</span>, <span class="literal">true</span>); <span class="comment">// 开始对数位从高位进行枚举</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; solve(r) - solve(l - <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="典型例题"><a href="#典型例题" class="headerlink" title="典型例题"></a>典型例题</h3><h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2089" target="_blank" rel="noopener">题目大意</a></h4><p>给你两个数n和m，问在n和m区间中，有多少数是不含4和62的。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>可以用$dp[pos][s]$来表示前一位是否是6的所有情况。s为1的时候代表前一位为6，那么这一位就不能为2，当s为0的时候，代表前一位不为6，那么就不用特殊考虑。</p>
<h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50</span>;</span><br><span class="line"><span class="keyword">int</span> dp[N][<span class="number">5</span>],num[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> s,<span class="keyword">bool</span> limit)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="number">-1</span>)	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (!limit &amp;&amp; dp[p][s])	<span class="keyword">return</span> dp[p][s];</span><br><span class="line">	<span class="keyword">int</span> l = limit ? num[p] : <span class="number">9</span>;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= l; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i == <span class="number">4</span>||(s &amp;&amp; i == <span class="number">2</span>))	<span class="keyword">continue</span>;</span><br><span class="line">		ans += dfs(p - <span class="number">1</span>, i == <span class="number">6</span>, limit&amp;&amp;i == num[p]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!limit)	dp[p][s] = ans;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (m) &#123;</span><br><span class="line">		num[c++] = m % <span class="number">10</span>,m /= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dfs(c - <span class="number">1</span>, <span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &amp;&amp; n || m) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; solve(m) - solve(n - <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数位DP</tag>
      </tags>
  </entry>
  <entry>
    <title>拓展域</title>
    <url>/2020/07/08/%E6%8B%93%E5%B1%95%E5%9F%9F/</url>
    <content><![CDATA[<p>拓展域，个人感觉算是并查集中比较难的部分了。（网上都没什么详细的教学。。。全靠理解代码</p>
<p>简而言之，就是用多个并查集，多个空间，来表示节点之间的一些相互关系，比如x的敌人，x的朋友，我需要找到x的敌人的敌人，就也是我的朋友，x的敌人的朋友，就也是我的敌人。（【NOIP 2010 提高组】关押罪犯）</p>
<a id="more"></a>

<p>不多说，直接看例题吧。</p>
<p>（我感觉我说肯定说不清楚。。。</p>
<h3 id="例题解释"><a href="#例题解释" class="headerlink" title="例题解释"></a>例题解释</h3><p>1、<a href="http://poj.org/problem?id=1182" target="_blank" rel="noopener">POJ-1182 食物链</a></p>
<p>题目大意就是，告诉你一些动物之间的关系（同类或者捕食），如果满足这三个条件</p>
<blockquote>
<p>1）    当前的话与前面的某些真的话冲突，就是假话；<br>2）    当前的话中X或Y比N大，就是假话；<br>3）    当前的话表示X吃X，就是假话；</p>
</blockquote>
<p>就是假话。问你假话的数量。</p>
<p>我们可以用在同一个并查集的表示是同一类，x+n表示捕食关系。</p>
<blockquote>
<p>x-&gt;x+n-&gt;x+2*n-&gt;x</p>
</blockquote>
<p>如果x和y是同类，那么</p>
<blockquote>
<p>1）    x和y是同一类；<br>2）    x+n和y+n是同一类；<br>3）    x+2 * n和y+2 * n是同一类; </p>
</blockquote>
<p>如果x和y是捕食关系，那么</p>
<blockquote>
<p>1）    x和y+2 * n是同一类；<br>2）    x+n和y是同一类；<br>3）    x+2 * n和y+n是同一类; </p>
</blockquote>
<p>这样就可以用三个并查集来表达之间的关系了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">3</span> * N + <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> son = root, t;</span><br><span class="line">	<span class="keyword">while</span> (root != f[root])	root = f[root];</span><br><span class="line">	<span class="keyword">while</span> (son != root) &#123;</span><br><span class="line">		t = f[son];</span><br><span class="line">		f[son] = root;</span><br><span class="line">		son = t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> root1,<span class="keyword">int</span> root2)</span> </span>&#123;</span><br><span class="line">	root1 = <span class="built_in">find</span>(root1);</span><br><span class="line">	root2 = <span class="built_in">find</span>(root2);</span><br><span class="line">	<span class="keyword">if</span> (root1 != root2)	f[root1] = root2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, k;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;k);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">3</span>*n; i++) &#123;<span class="comment">//初始化，三倍空间</span></span><br><span class="line">		f[i] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> d, x, y;</span><br><span class="line">	<span class="keyword">while</span> (k--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;d, &amp;x, &amp;y);</span><br><span class="line">		<span class="keyword">if</span> (x &gt; n || y &gt; n) &#123;<span class="comment">//大于n就是假话，直接continue</span></span><br><span class="line">			ans++;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (d == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">find</span>(x + n) == <span class="built_in">find</span>(y) || <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y + n))	ans++;</span><br><span class="line">            <span class="comment">//x捕食y或者y捕食x，关系不符，就是假话</span></span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				join(x, y);</span><br><span class="line">				join(x + n, y + n);</span><br><span class="line">				join(x + <span class="number">2</span> * n, y + <span class="number">2</span> * n);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">find</span>(x) == <span class="built_in">find</span>(y) || <span class="built_in">find</span>(y + n) == <span class="built_in">find</span>(x))	ans++;</span><br><span class="line">            <span class="comment">//x和y是同一类或者y捕食x，关系不符，就是假话</span></span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				join(x + n, y);</span><br><span class="line">				join(x + <span class="number">2</span> * n, y + n);</span><br><span class="line">				join(x, y + <span class="number">2</span> * n);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、<a href="http://poj.org/problem?id=1733" target="_blank" rel="noopener">POJ-1733 Parity game</a></p>
<p>你有一串由0和1构成的序列，告诉你一些关系（[L,R]中1的个数是奇或偶），问你哪个地方出现了矛盾，输出最早出现矛盾的位置。</p>
<p>（这个题目。。相当头疼，想了好久，根本看不懂，我也不确定我能解释清楚。。</p>
<p>首先要离散化，n太大了，数组放不下，需要先离散化。</p>
<p>然后我们可以用d[x]表示x到根节点之间是奇是偶，用f[x]（并查集）表示前后关系。</p>
<p>如果根节点相同的时候，就需要判断是否矛盾。判断矛盾的时候可以用</p>
<blockquote>
<p>d[x]^d[y]  表示x到y之间的1的个数</p>
<p>1）    d[x] = 0,d[y] = 0 时，d[x]-d[y] == d[x]^d[y] == 0;<br>2）    d[x] = 0,d[y] = 1 时，d[x]-d[y] == d[x]^d[y] == 1;<br>3）    d[x] = 1,d[y] = 0 时，d[x]-d[y] == d[x]^d[y] == 1;<br>4）    d[x] = 1,d[y] = 1 时，d[x]-d[y] == d[x]^d[y] == 0;</p>
</blockquote>
<p>在路径压缩上，也可以使用同样的方法</p>
<blockquote>
<p>d[x]^d[f[x]]  表示x到f[x]之间的1的个数（用递归来实现）</p>
<p>1）    d[x] = 0,d[y] = 0 时，d[x]+d[y] == d[x]^d[y] == 0;<br>2）    d[x] = 0,d[y] = 1 时，d[x]+d[y] == d[x]^d[y] == 1;<br>3）    d[x] = 1,d[y] = 0 时，d[x]+d[y] == d[x]^d[y] == 1;<br>4）    d[x] = 1,d[y] = 1 时，d[x]+d[y] == d[x]^d[y] == 0;</p>
</blockquote>
<p>关系表示完后，即可写出正确代码。</p>
<p>（。。。我觉得没那么简单，我是真的菜。。根本想不到的好吧</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5050</span>;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">2</span> * N], d[<span class="number">2</span> * N];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; num;<span class="comment">//n太大了，不能用数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root != f[root]) &#123;</span><br><span class="line">		<span class="keyword">int</span> t = search(f[root]);<span class="comment">//递归寻找根节点</span></span><br><span class="line">		d[root] = d[root] ^ d[f[root]];<span class="comment">//更新d[x]的值</span></span><br><span class="line">		f[root] = t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f[root];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> rx = search(x);</span><br><span class="line">	<span class="keyword">int</span> ry = search(y);</span><br><span class="line">	<span class="keyword">if</span> (rx == ry) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((d[x] ^ d[y]) != l)	<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//判断是否矛盾</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		f[ry] = rx;</span><br><span class="line">		d[ry] = (d[x] + d[y] + l) % <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//d[ry] = (d[x] ^ d[y] + l) % 2;也可</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * N - <span class="number">5</span>; i++) &#123;</span><br><span class="line">		f[i] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">1</span>, mark = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> x, y, l;</span><br><span class="line">		<span class="keyword">char</span> ch[<span class="number">10</span>];</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; ch;</span><br><span class="line">		<span class="keyword">if</span> (!num[x - <span class="number">1</span>])	num[x - <span class="number">1</span>] = cnt++;<span class="comment">//离散化</span></span><br><span class="line">		<span class="keyword">if</span> (!num[y])	num[y] = cnt++;</span><br><span class="line">		<span class="keyword">if</span> (ch[<span class="number">0</span>] == <span class="string">'e'</span>)	l = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> l = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (!join(num[x - <span class="number">1</span>], num[y], l)) &#123;</span><br><span class="line">			mark = i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!mark)	mark = m + <span class="number">1</span>;<span class="comment">//如果没有冲突，就输出m</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; mark - <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>拓展域</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>杭电多校第七场 1007 Game 题解</title>
    <url>/2020/08/17/%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B8%83%E5%9C%BA-1007-Game-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6850" target="_blank" rel="noopener">题目大意</a></h3><p>给你n个点，你需要从第一个点开始，先任意选择一个点，之后每次需要移动比之前的距离更远，且这个点没有被使用过，a先手，b后手，a和b都采用最佳策略，如果不能移动则算输，求a是否能取胜。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这博弈太难了。。</p>
<p>我们先可以按照边的大小来排序。</p>
<p>按照不同的边的大小，从大到小把点可以分到不同的集合。</p>
<p>按照能组成边的大小，能够构成一个点集。</p>
<p>如果第一个点在最后一个集合，且最后一个集合只有第一个点，则a必输。</p>
<p>否则a必赢。</p>
<p>如果第一个点不在最后一个集合或者集合不止一个数，则先手可以选择同集合的，而后手只能跨集合，则最后后手则会没有集合可以选，就必赢。</p>
<p>如果第一点在最后一个集合且只有一个数，则相当于先手需要不断的跨集合，后手选择同集合，则必输。</p>
<p>第一个点在最后一个集合，则说明能与他构成边的点之前都被用过了，导致第一个点被剩下了。</p>
<p>那我们只需要从大到小枚举所有的边，如果枚举到的边都没被标记，则将两点标记，如果这条边包含了第一点，则必胜。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2020</span>;</span><br><span class="line"><span class="keyword">int</span> vis[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">n</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line">&#125;node[N];</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> a, b;</span><br><span class="line">	ll val;</span><br><span class="line">&#125;s;</span><br><span class="line"><span class="built_in">vector</span>&lt;s&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dis</span><span class="params">(n a, n b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(s a, s b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.val &gt; b.val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\in.txt", "r", stdin);</span></span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\out.txt", "w+", stdout);</span></span><br><span class="line">	<span class="keyword">int</span> t; <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			vis[i] = <span class="number">0</span>; <span class="built_in">cin</span> &gt;&gt; node[i].x &gt;&gt; node[i].y;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">				v.push_back(&#123; i,j,dis(node[i],node[j]) &#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		sort(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), cmp);</span><br><span class="line">		<span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> x : v) &#123;</span><br><span class="line">			s t = x;</span><br><span class="line">			<span class="keyword">if</span> (vis[t.a] || vis[t.b]) <span class="keyword">continue</span>;</span><br><span class="line">			vis[t.a] = vis[t.b] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (t.a == <span class="number">1</span> || t.b == <span class="number">1</span>) &#123;</span><br><span class="line">				flag = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (flag) <span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title>杭电多校第一场 1005 Fibonacci Sum 题解</title>
    <url>/2020/07/22/%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B8%80%E5%9C%BA-1005-Fibonacci-Sum-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6755" target="_blank" rel="noopener">题目大意</a></h3><p>定义一个斐波那契数列</p>
<p>$F_0=0,F_1=1$</p>
<p>$F_n=F_{n-1}+F_{n-2}\ (n&gt;1)$</p>
<p>求$(F_{0})^K+(F_{C})^K+(F_{2C})^K+\dots +(F_{NC})^{K}$。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这题直接让我自闭好吧。</p>
<p>这是啥，基础数论，难度easy。。</p>
<p>我感觉我离退役不远了。</p>
<p>首先我们需要知道斐波那契数列的通项公式（这个我就不知道。。<br>$$<br>F_n=\frac{1}{\sqrt{5}}\left(\left(\frac{1+\sqrt{5}}{2}\right)^{n}-\left(\frac{1-\sqrt{5}}{2}\right)^{n}\right)<br>$$<br>通过暴力，我们可以求出来，在$mod10^9+9$的情况下，与$\sqrt 5$同余的是383008016。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MOD;++i)&#123;</span><br><span class="line">	<span class="keyword">if</span>((<span class="keyword">long</span> <span class="keyword">long</span>)i*i%MOD == <span class="number">5</span>)&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//383008016</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过快速幂，求出$\frac{1} {\sqrt 5}$的逆元是276601605。</p>
<p>然后，通项公式中还含有$ \large\frac{1+\sqrt 5}{2}$和$\large \frac{1-\sqrt 5}{2}$。</p>
<p>为了方便表示，可以令$\large a=\frac{1+\sqrt 5}{2},b = \frac{1-\sqrt 5}{2}$。</p>
<p>这个a和b的值的计算，我不是很懂。。</p>
<p>大致就是把a和b的值用$1+\sqrt 5$和$1-\sqrt 5$的同余乘以2的逆元，得出的结果就是691504013和308495997。</p>
<p>具体的可以去看这位大佬的<a href="https://blog.csdn.net/acdreamers/article/details/23039571" target="_blank" rel="noopener">博客</a>。</p>
<p>讲解的很详细，很好。</p>
<p>总之，可以得出$a=691504013，b=308495997$。</p>
<p>这样，基础准备就已经做好了。</p>
<p>$\begin{align} \text{ans}&amp;=\sum_{i=0}^{N}(F_{iC})^{K}\ &amp;=\sum_{i=0}^{N}\left(\frac{1}{\sqrt{5}}\left(\left(\frac{1+\sqrt{5}}{2}\right)^{iC}-\left(\frac{1-\sqrt{5}}{2}\right)^{iC}\right)\right)^K\ &amp;=\left(\frac{1}{\sqrt{5}}\right)^K\cdot \sum_{i=0}^{N}\left(\left(\frac{1+\sqrt{5}}{2}\right)^{iC}-\left(\frac{1-\sqrt{5}}{2}\right)^{iC}\right)^{K} \end{align}$</p>
<p>为了方便表示，令$A=\left(\frac{1+\sqrt{5}}{2}\right)^C,B=\left(\frac{1-\sqrt{5}}{2}\right)^C$。</p>
<p>这样，答案就变成了$\large \left(\frac{1}{\sqrt{5}}\right)^K\sum_{i=0}^{N}(A^i-B^i)^K$。</p>
<p>前面那一项，我们可以用快速幂求出来。</p>
<p>只需要求出后面那一项即可。</p>
<p>对此可以进行二项式展开。</p>
<p>过程同上面那个大佬博客中的二项式展开类似。</p>
<p>就是从n变成了cn。</p>
<p>$\large (A-B)^k = C_k^0A^k - C_k^1A^{k-1}B^1 + \cdots + (-1)^iC_k^iA^{k-i}B^i + \cdots +(-1)^kC_k^kB^k (n \in N^*)$</p>
<p>这样，对于不同的斐波那契项，相同位置的二次项展开数，构成了一个等比数列。</p>
<p>对于每一项来说，公比$\large q=a^{c(k-i)}b^{ci}$。</p>
<p>其前n项和公式为<br>$$<br>\large S_n=\frac{(-1)^i·c_k^i·a^{c(k-i)}·b^{ci}·(1-a^{cn(k-i)}·b^{cni})}{1-a^{c(k-i)}b^{ci}}<br>$$<br> 接着只需要从0枚举到k，把每项用求和公式求出来相加即可。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">1e5</span> + <span class="number">5</span>, mod = <span class="number">1e9</span> + <span class="number">9</span>, N = <span class="number">1e5</span>;</span><br><span class="line">ll A = <span class="number">691504013</span>, B = <span class="number">308495997</span>;</span><br><span class="line">ll sqrt5 = <span class="number">383008016</span>, invsqrt5 = <span class="number">276601605</span>;</span><br><span class="line">ll fac[maxn], finv[maxn];</span><br><span class="line">ll sac[maxn], sbc[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	a %= mod;</span><br><span class="line">	<span class="keyword">while</span> (b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)	ans = (ans * a % mod) % mod;</span><br><span class="line">		a = (a * a) % mod, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a &lt; b)	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!b || a == b)	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> ((fac[a] * finv[a - b]) % mod * finv[b]) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	fac[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (ll i = <span class="number">2</span>; i &lt;= N; i++)	fac[i] = (fac[i - <span class="number">1</span>] * i)%mod;</span><br><span class="line">	finv[N] = qpow(fac[N], mod - <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">for</span> (ll i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)	finv[i] = (finv[i + <span class="number">1</span>] * (i + <span class="number">1</span>)) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	init();</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		ll n, c, k;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; c &gt;&gt; k;</span><br><span class="line">		ll ans = <span class="number">0</span>, flag = <span class="number">-1</span>;</span><br><span class="line">		ll ac = qpow(A, c), bc = qpow(B, c);</span><br><span class="line">		sac[<span class="number">0</span>] = sbc[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">			sac[i] = sac[i - <span class="number">1</span>] * ac % mod;</span><br><span class="line">			sbc[i] = sbc[i - <span class="number">1</span>] * bc % mod;</span><br><span class="line">		&#125;</span><br><span class="line">		ll acn = qpow(ac, n), bcn = qpow(bc, n), acninv = qpow(acn, mod - <span class="number">2</span>);</span><br><span class="line">		ll now_acn = qpow(acn, k), now_bcn = <span class="number">1</span>;</span><br><span class="line">		ll x, y;</span><br><span class="line">		<span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt;= k; i++) &#123;</span><br><span class="line">			flag *= <span class="number">-1</span>;</span><br><span class="line">			ll q = sac[k - i] * sbc[i] % mod;</span><br><span class="line">			<span class="keyword">if</span> (q == <span class="number">1</span>) &#123;</span><br><span class="line">				ll t = C(k, i) * (n % mod) % mod;</span><br><span class="line">				ans = (ans + (flag * t) % mod + mod) % mod;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				x = ((C(k, i) * sac[k - i]) % mod * sbc[i]) % mod;</span><br><span class="line">				x = (x * (<span class="number">1</span> - (now_acn * now_bcn % mod) + mod) % mod) % mod;</span><br><span class="line">				y = (<span class="number">1</span> - q) % mod;</span><br><span class="line">				y = qpow(y, mod - <span class="number">2</span>);</span><br><span class="line">				ans = (ans + flag * x * y % mod + mod) % mod;</span><br><span class="line">			&#125;</span><br><span class="line">			now_acn = (now_acn * acninv) % mod;</span><br><span class="line">			now_bcn = (now_bcn * bcn) % mod;</span><br><span class="line">		&#125;</span><br><span class="line">		ll mul = qpow(invsqrt5, k);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; (ans * mul) % mod &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>逆元</tag>
      </tags>
  </entry>
  <entry>
    <title>杭电多校第一场 1004 Distinct Sub-palindromes 题解</title>
    <url>/2020/07/21/%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B8%80%E5%9C%BA-1004-Distinct-Sub-palindromes-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/contests/contest_showproblem.php?pid=1004&cid=879" target="_blank" rel="noopener">题目大意</a></h3><p>长度为n的字符串，这个字符串由小写字母构成，求所有长度为n的字符串中，子回文串数量最小的串的数量为多少。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>一开始还以为是$26^n$，结果我们一个队交快速幂wa了三次。。</p>
<p>（我就wa了一次。。</p>
<p>首先，当长度为一的时候，很显然答案是26，因为无论你用哪个字母，子回文串的数量都是1。</p>
<p>当长度为二的时候，可以理解为在长度为一的串中，在空隙中插入其他字母，发现，无论你插入哪个字母，串的子回文串的数量都会加一，所以答案为$26^2$。当长度为三的时候，可以得出同样的结果，答案为$26^3$。</p>
<p>当长度大于三的时候，可以发现，当原长度为三的串中各个元素都不相同的时候，在其空隙中插入与左右两边都不相同的第三个字母，这个时候，串的回文子串的数量是不会增加的，所以答案为$26<em>25</em>24$。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="number">1</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="number">26</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t == <span class="number">2</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="number">676</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="number">3</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="number">17576</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="number">15600</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>拓展欧几里得、逆元、线性同余方程、中国剩余定理和拓展中国剩余定理</title>
    <url>/2020/07/08/%E6%8B%93%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E3%80%81%E9%80%86%E5%85%83%E3%80%81%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B%E3%80%81%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86%E5%92%8C%E6%8B%93%E5%B1%95%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<h3 id="拓欧介绍"><a href="#拓欧介绍" class="headerlink" title="拓欧介绍"></a>拓欧介绍</h3><p>简单来说，拓欧就是求关于x，y的方程$ax+by=gcd(a,b)$的所有整数解。</p>
<p>这里就简单的证一下，详细证明点<a href="https://blog.csdn.net/weixin_39645344/article/details/83615901" target="_blank" rel="noopener">这里</a></p>
<a id="more"></a>

<p>由欧几里得定理可以得出$gcd(a,b)=gcd(b,a \%\ b)$。</p>
<p>由$gcd(b,a \%\ b)=bx_1+(a \%\ b)y_1$</p>
<p>由于$(a\%\ b)$可以表示成$a-(a/b)*b$。</p>
<p>所以表示成$bx_1+ay_1-b(a/b)y_1$。</p>
<p>即$ay_1+b(x_1-(a/b)y_1)$。</p>
<p>由于式子右边相当，所以左边也相等。</p>
<p>所以推出$x==y_1$,$y==x_1-(a/b)y_1$。</p>
<p>当我们推到最后一步的时候，即$b==0$时，显然是存在一组特解$x_1==1,y_1==0$。</p>
<p>那么我们就可以用这个特解来推出其他的解了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ex_gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span>&amp; x, <span class="keyword">int</span>&amp; y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!b) &#123;</span><br><span class="line">		x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">int</span> t = ex_gcd(b, a % b, y, x);</span><br><span class="line">		y -= (a / b)*x;</span><br><span class="line">		<span class="keyword">return</span> t;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="逆元介绍"><a href="#逆元介绍" class="headerlink" title="逆元介绍"></a>逆元介绍</h3><p>若整数$b,m$互质（这点很重要），并且$b|a$（表示b能整除a），则存在一个整数$a/b\equiv a*x(mod  \ m) $</p>
<p>称x为b的逆元。</p>
<p>介绍一下求逆元比较常用的两种方法。</p>
<h4 id="1、快速幂求逆元"><a href="#1、快速幂求逆元" class="headerlink" title="1、快速幂求逆元"></a>1、快速幂求逆元</h4><p>如果模数m为质数，由费马小定理的$b^{p-2}$为b的逆元。</p>
<p>可以用快速幂求出$b^{\ p-2}$。</p>
<h4 id="2、拓欧求逆元"><a href="#2、拓欧求逆元" class="headerlink" title="2、拓欧求逆元"></a>2、拓欧求逆元</h4><p>由定义知，$a\times x\equiv 1(mod\ m)$，这个x就是a的逆元,等价于$a\times x-1$是m的倍数。</p>
<p>将这个倍数令为-y倍。</p>
<p>得到$a\times x+m\times y=1$。</p>
<p>我们只需要用拓展欧几里得求得x，在令x对m取模即可。</p>
<h3 id="线性同余方程介绍"><a href="#线性同余方程介绍" class="headerlink" title="线性同余方程介绍"></a>线性同余方程介绍</h3><p>给定你a和b，以及取余的m，求一个整数x满足$a*x\equiv b(mod\ m)$。</p>
<p>求x的最小值。</p>
<p>这个方程$a*x\equiv b(mod\ m)$就是线性同余方程。</p>
<p>等价于$a\times x+m\times y=b$。</p>
<p>这个方程有解需要满足$gcd(a,m)|b$。（注意）</p>
<p>我们可以用拓欧来求出一组特解$x_0,y_0$。</p>
<p>通解为$x = x_0+(m/t)\times z$，$y = y_0\ +(a/t)\times z$，其中t为$gcd (a,m)$,z为整数。</p>
<p>因为$lcm(a,b) = a*b/gcd(a,b)$。</p>
<p>即每次增加一个最小公倍数。</p>
<p>当我们要求$a\times x+m \times y=b$的解时，我们可以先求出$a \times x +m\times y=gcd(a,m)$的解$x_0$。</p>
<p>那么原方程的解为$x=x_0*b/gcd(a/m)$，其中$b/gcd(a,m)$为扩大的倍数。</p>
<h4 id="典型例题"><a href="#典型例题" class="headerlink" title="典型例题"></a>典型例题</h4><p><a href="https://www.luogu.com.cn/problem/P1082" target="_blank" rel="noopener">洛谷-P1082 同余方程</a></p>
<h5 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h5><p>求关于$x$的同余方程 $a x \equiv 1 \pmod {b} $的最小正整数解。</p>
<h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><p>就是模板题。输入数据保证有解，不需要再去判断是否满足条件。</p>
<h5 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ex_gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span>&amp; x, <span class="keyword">int</span>&amp; y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!b) &#123;</span><br><span class="line">		x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">int</span> t = ex_gcd(b, a % b, y, x);</span><br><span class="line">		y -= (a / b)*x;</span><br><span class="line">		<span class="keyword">return</span> t;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a, b, x, y;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">	ex_gcd(a, b, x, y);</span><br><span class="line">	x = (x%b + b) % b;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="中国剩余定理介绍"><a href="#中国剩余定理介绍" class="headerlink" title="中国剩余定理介绍"></a>中国剩余定理介绍</h3><p>求解同余方程组</p>
<p>$\begin{cases} x \equiv a_1(mod\ m_1) \\ x \equiv a_2(mod\ m_2) \\ x\equiv a_3(mod\ m_3) \\ ……………. \\ x \equiv a_k(mod\ m_k) \end{cases}$</p>
<p>其中$m_1,m_2,m_3,….,m_k$为<strong>两两互质</strong>的整数。（这个区别于拓展中国剩余定理）</p>
<p>求x的最小非负整数解。</p>
<p>令$M=∏^k_{i = 1\ m_i}$，（$∏$这个符号代表连乘），即M是所有$m_i$的最小公倍数。</p>
<p>$t_i$是同余方程$\frac{M}{m_i}\equiv 1(mod\ m_i)$的最小非负整数解。</p>
<p>则解x为$x=∑^k_{i=1}\ a_i\frac{M}{m_i}t_i$。</p>
<p>通解为$x+i*M$。</p>
<p>最小非负整数解为$(x %M+M) %M$。</p>
<p>证明的话，蓝书证明的挺好的，这里就不写了。</p>
<p><img src="https://ae01.alicdn.com/kf/H8e8bd356eb124549bb50cd928bfa94298.jpg" alt=""></p>
<h4 id="典型例题-1"><a href="#典型例题-1" class="headerlink" title="典型例题"></a>典型例题</h4><p><a href="https://www.luogu.com.cn/problem/P3868" target="_blank" rel="noopener">洛谷-P3868 猜数字</a></p>
<h5 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h5><p>现有两组数字，每组 k 个。</p>
<p>第一组中的数字分别用 $a_1,a_2,\cdots ,a_k$ 表示，第二组中的数字分别用 $b_1,b_2,\cdots ,b_k $表示。</p>
<p>其中第二组中的数字是两两互素的。求最小的 $n∈N$，满足对于 $\forall i\in [1,k]，有 b_i | (n-a_i)$。</p>
<h5 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h5><p>把 $b_i | (n-a_i)$变一下型，就变成了$n\equiv a_i(mod \ b)$。</p>
<p>就是一个模板题了。</p>
<p>补充：</p>
<p>如果有$a\equiv b(mod \ m)$，则$a+c\equiv b\ +c(mod\ m)$成立。</p>
<h5 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll a[<span class="number">20</span>], b[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a, ll b, ll&amp; x, ll&amp; y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!b) &#123;</span><br><span class="line">		x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">	ll t = exgcd(b, a % b, y, x);</span><br><span class="line">	y -= (a / b) * x;</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qmul</span><span class="params">(ll a, ll b, ll mod)</span> </span>&#123;<span class="comment">//快速乘</span></span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)	ans = (ans + a) % mod;</span><br><span class="line">		a = (a &lt;&lt; <span class="number">1</span>) % mod;</span><br><span class="line">		b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">china</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll M = <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)	M *= b[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		ll t = M / b[i];</span><br><span class="line">		ll x, y;</span><br><span class="line">		exgcd(t, b[i], x, y);</span><br><span class="line">		x = (x % b[i] + b[i]) % b[i];</span><br><span class="line">		ans = (ans + qmul(qmul(a[i], t, M), x, M)) % M;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (ans%M+M)%M;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = (a[i] % b[i] + b[i]) % b[i];<span class="comment">//题目中的a可能大于b，所以需要取模</span></span><br><span class="line">	ll ans = china();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="拓展中国剩余定理介绍"><a href="#拓展中国剩余定理介绍" class="headerlink" title="拓展中国剩余定理介绍"></a>拓展中国剩余定理介绍</h3><p>求解同余方程组</p>
<p>$\begin{cases} x \equiv a_1(mod\ m_1) \\ x \equiv a_2(mod\ m_2) \\ x \equiv a_3(mod\ m_3) \\ ……………. \\ x \equiv a_k(mod\ m_k) \end{cases}$</p>
<p>其中$m_1,m_2,m_3,….,m_k$为<strong>不一定两两互质</strong>的整数。</p>
<p>求x的最小非负整数解。</p>
<p>我们可以设第i项的解$x_i$为$x_i = x_{i-1}+k_{i-1}*M$​。其中M为前$i-1$项的m的最小公倍数。</p>
<p>将$x_i$带入式子得$k_{i-1}\times m_{i-1}-k_i\times m_i+x_{i-1}\equiv a_i(mod\ m_i)$。</p>
<p>即$k_{i-1}\times M-k_i\times m_i\equiv a_i-x_{i-1}(mod\ m_i)$。</p>
<p>我们可以用拓欧来求出$k_{i-1}$，然后带入到$x_i = x_{i-1}+k_{i-1}*M$中，求得$x_i$。</p>
<h4 id="典型例题-2"><a href="#典型例题-2" class="headerlink" title="典型例题"></a>典型例题</h4><p><a href="https://www.luogu.com.cn/problem/P4777" target="_blank" rel="noopener">洛谷-P4777 【模板】扩展中国剩余定理（EXCRT）</a></p>
<h5 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h5><p>求解同余方程组</p>
<p>$\begin{cases} x \equiv b_1(mod\ a_1) \\ x \equiv b_2(mod\ a_2) \\ x \equiv b_3(mod\ a_3) \\ ……………. \\ x \equiv b_k(mod\ a_k) \end{cases}$</p>
<p>求x的最小非负整数解。</p>
<h5 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h5><p>模板题，套板子即可，注意快(gui)速乘。</p>
<h5 id="完整代码-2"><a href="#完整代码-2" class="headerlink" title="完整代码"></a>完整代码</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line">ll a[N], b[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a, ll b, ll&amp; x, ll&amp; y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!b) &#123;</span><br><span class="line">		x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">	ll t = exgcd(b, a % b, y, x);</span><br><span class="line">	y -= (a / b) * x;</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qmul</span><span class="params">(ll a,ll b,ll mod)</span> </span>&#123;</span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)	ans = (ans + a % mod) % mod;</span><br><span class="line">		a = (a &lt;&lt; <span class="number">1</span>) % mod;</span><br><span class="line">		b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">get_ans</span><span class="params">(ll a, ll b, ll c, ll&amp; x, ll&amp; y, ll&amp; gcd)</span> </span>&#123;</span><br><span class="line">	gcd = exgcd(a, b, x, y);</span><br><span class="line">	ll k = c / gcd, t = b / gcd;</span><br><span class="line">	<span class="keyword">if</span> (c % gcd)	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	x = qmul(x, k, t);</span><br><span class="line">	x = (x % t + t) % t;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">exchina</span><span class="params">(ll&amp; ans)</span> </span>&#123;</span><br><span class="line">	ll x, y,gcd;</span><br><span class="line">	ll M = a[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!get_ans(M, a[i], (b[i] - ans % a[i] + a[i]) % a[i], x, y, gcd))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		ans += M * x;</span><br><span class="line">		M = M / gcd* a[i] ;</span><br><span class="line">		ans = (ans % M + M) % M;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)	<span class="built_in">cin</span> &gt;&gt; a[i] &gt;&gt; b[i];</span><br><span class="line">	ll ans = b[<span class="number">1</span>];</span><br><span class="line">	exchina(ans);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，就差不多把我最近学的数论方面的东西讲完了。。</p>
<p>（数论是真的难啊啊</p>
<p>简直是天书。。</p>
]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>逆元</tag>
        <tag>拓展欧几里得</tag>
        <tag>线性同余方程</tag>
        <tag>中国剩余定理</tag>
        <tag>拓展中国剩余定理</tag>
      </tags>
  </entry>
  <entry>
    <title>杭电多校第三场 1005 Little W and Contest 题解</title>
    <url>/2020/07/30/%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B8%89%E5%9C%BA-1005-Little-W-and-Contest-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6795" target="_blank" rel="noopener">题目大意</a></h3><p>总共有n个人，每个人都有自己的权值1或者2。</p>
<p>组成一个队伍至少需要三个人，最少需要两个2。每个队伍不能存在任意两个互相认识的人。</p>
<p>输入n-1组关系，使两个人熟悉，保证之前是都不认识的。输出每一次熟悉之后剩下的能组成队伍的个数。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这个题目其实看懂了不难。</p>
<p>首先全部个数就是$C_{cnt2}^{3}+C_{cnt1}^1*C_{cnt2}^2$。</p>
<p>（在求这个的时候我又用了取模。。我又忘了除法不能同余。我自裁。。</p>
<p>之后就只需要在这个基础上不断减少就可以了。</p>
<p>用c1和c2两个数组来维持并查集中不同集合中的为1和为2的个数。</p>
<p>因为之前都是互不认识的，所以必定根节点不同。</p>
<p>（之前就没注意到，想了好久要不要判断是否根节点不同。。</p>
<p>之后的就简单了，考虑到四种情况就可以了。</p>
<blockquote>
<p>1、1 2 2</p>
<p>2、2 1 2</p>
<p>3、2 2 1</p>
<p>4、2 2 2</p>
</blockquote>
<p>把这四种情况减去就可以了。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> fa[N];</span><br><span class="line">ll c1[N], c2[N];</span><br><span class="line">ll cnt1, cnt2;</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> son)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> root = son;</span><br><span class="line">	<span class="keyword">while</span> (fa[root] != root)	root = fa[root];</span><br><span class="line">	<span class="keyword">while</span> (son != root) &#123;</span><br><span class="line">		<span class="keyword">int</span> t = fa[son];</span><br><span class="line">		fa[son] = root;</span><br><span class="line">		son = t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> rt1 = <span class="built_in">find</span>(a), rt2 = <span class="built_in">find</span>(b);</span><br><span class="line">	ans -= c2[rt1] * c2[rt2] * (cnt2 - c2[rt1] - c2[rt2]);</span><br><span class="line">	ans -= c2[rt1] * c2[rt2] * (cnt1 - c1[rt1] - c1[rt2]);</span><br><span class="line">	ans -= c1[rt1] * c2[rt2] * (cnt2 - c2[rt1] - c2[rt2]);</span><br><span class="line">	ans -= c2[rt1] * c1[rt2] * (cnt2 - c2[rt1] - c2[rt2]);</span><br><span class="line">	fa[rt1] = rt2;</span><br><span class="line">	c1[rt2] += c1[rt1], c2[rt2] += c2[rt1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t; <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		cnt1 = cnt2 = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> x; <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">			fa[i] = i;</span><br><span class="line">			<span class="keyword">if</span> (x == <span class="number">1</span>)	c1[i] = <span class="number">1</span>, c2[i] = <span class="number">0</span>, cnt1++;</span><br><span class="line">			<span class="keyword">else</span> c1[i] = <span class="number">0</span>, c2[i] = <span class="number">1</span>, cnt2++;</span><br><span class="line">		&#125;</span><br><span class="line">		ans = cnt2 * (cnt2 - <span class="number">1</span>) * (cnt2 - <span class="number">2</span>) / <span class="number">6</span> + cnt2 * (cnt2 - <span class="number">1</span>) * cnt1 / <span class="number">2</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans % mod &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> u, v; <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">			join(u, v);</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; ans % mod &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>杭电多校第七场 1009 Increasing and Decreasing 题解</title>
    <url>/2020/08/13/%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B8%83%E5%9C%BA-1009-Increasing-and-Decreasing-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6852" target="_blank" rel="noopener">题目大意</a></h3><p>给你是三个数字$n,x,y$，问你能否构造1~n的最长上升子序列长度为x，最长下降子序列长度为y的序列。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这场比赛直接爆零了。。</p>
<p>这个签到题都完全没有思路。。</p>
<p>后面看题解，发现原来有个这个定理。</p>
<blockquote>
<p>上升子序列的个数等于最长下降子序列的长度</p>
<p>下降子序列的个数等于最长上升子序列的长度</p>
</blockquote>
<p>人都傻了。。</p>
<p>详解点击这里，大佬的博客，<a href="https://blog.csdn.net/xuzengqiang/article/details/7266034" target="_blank" rel="noopener">偏序集-Dilworth定理</a>。</p>
<p>知道了这个定理，就可以先判断不能构造的条件。</p>
<p>最少的情况是，x-1个下降子序列长度为1，1个下降子序列长度为y，如果$x-1+y&gt;n$，说明数字太多了。</p>
<p>最多的情况是，每个下降子序列长度都为y，如果$x*y&lt;n$说明数字太少了。</p>
<p>由于题目要求字典序要最小，所以越长的应该放在越后面，这个可以用栈来实现。</p>
<p>假设目前需要构造x个下降子序列，最长长度为y。</p>
<p>先判断构造这个y之后，能否满足n能够构造剩下的x-1个最短的下降子序列。</p>
<p>如果可以，则可以进行构造。</p>
<p>如果不行，就需要将y进行减小直到可以构造。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t; <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n, x, y; <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		<span class="keyword">if</span> (x - <span class="number">1</span> + y &gt; n || <span class="number">1L</span>L * x * y &lt; n)	<span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">while</span> (n) &#123;</span><br><span class="line">				<span class="keyword">if</span> (n - y &gt;= x - <span class="number">1</span>) &#123;</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> i = n - y + <span class="number">1</span>; i &lt;= n; i++)	s.push(i);</span><br><span class="line">					n -= y; x--;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">while</span> (n - y &lt; x - <span class="number">1</span>) y--;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">				<span class="keyword">int</span> t = s.top(); s.pop();</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; t;</span><br><span class="line">				<span class="keyword">if</span> (!s.empty())	<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">				<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>LCS</tag>
        <tag>LIS</tag>
      </tags>
  </entry>
  <entry>
    <title>杭电多校第三场 1004 Tokitsukaze and Multiple 题解</title>
    <url>/2020/07/29/%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B8%89%E5%9C%BA-1004-Tokitsukaze-and-Multiple-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6794" target="_blank" rel="noopener">题目大意</a></h3><p>给你一串数字，你可以让任意两个相邻的数字合在一起，使串的个数减一，求串中最多有多少个数是p的倍数。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这个应该是这一场的签到了吧。</p>
<p>但是我没想出来。</p>
<p>好丢人啊。</p>
<p>刚开始以为是dp，想了半天，不知道咋进行状态转移。</p>
<p>就放弃了。</p>
<p>其实之后仔细想想，当时以为是没有重叠的子问题，以为就不是dp了。</p>
<p>（后面题解也提供了dp的做法。。尴尬</p>
<p>其实这个题目想到了就很简单。</p>
<p>可以用set或者map来维护前缀和。</p>
<p>在求前缀和的同时不断的对p取余。</p>
<p>如果这个前缀和在之前没出现过就记录一下。</p>
<p>出现了，则说明必然中间加了一个p的倍数，所以ans++。</p>
<p>之后清空set或者map。</p>
<p>注意，0是必须要在里面的，因为0就是刚好是p的倍数。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n, p;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; p;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> t = <span class="number">0</span>,ans = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">		s.<span class="built_in">clear</span>(), s.insert(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			t += a[i] % p, t %= p;</span><br><span class="line">			<span class="keyword">if</span> (s.count(t)) &#123;</span><br><span class="line">				ans++;</span><br><span class="line">				t = <span class="number">0</span>;</span><br><span class="line">				s.<span class="built_in">clear</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			s.insert(t);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>杭电多校第二场 1001 Total Eclipse 题解</title>
    <url>/2020/07/25/%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%BA%8C%E5%9C%BA-1001-Total-Eclipse-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6763" target="_blank" rel="noopener">题目大意</a></h3><p>给你一个n个点m边的双向图，你可以进行一个操作，选择一个数字k，选择k个互相联通的点，使这些点的权值减一，问最少需要多少次操作。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>刚开始打的时候，看到这个题过得还挺多的，又过的快。</p>
<p>以为是签到题。。</p>
<p>结果完全没思路。。</p>
<p>杭电多校还是难啊，补题都很困难。</p>
<p>对于任何一个图来说，最优解肯定是优先最大连通块，减去连通块中最小的值，然后对于分裂之后的所有连通块再进行相同的操作。</p>
<p>所以我们可以倒过来看，选择权值由大到小的点，每个点的贡献为前一个点的的权值减去现在的点的权值乘以目前连通块的数量，就是将大的点减小成目前点所需要的次数。</p>
<p>在从第二个点开始枚举的过程中，需要枚举这个点的边，如果连接的是以前被标记的点，就可以判断这两点是不是属于同一个连通块的，以此来控制连通块的数量。</p>
<p>最后还需要加上最后一个点的权值乘以连通块的数量。</p>
<p>说实话，这个题目还挺难想的。。。</p>
<p>不愧是杭电多校。</p>
<p>就没啥简单的题目。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> cnt, fa[N], p[N], flag[N];</span><br><span class="line">ll num[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; e[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> son)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> root = son;</span><br><span class="line">	<span class="keyword">while</span> (fa[root] != root)	root = fa[root];</span><br><span class="line">	<span class="keyword">while</span> (root != son) &#123;</span><br><span class="line">		<span class="keyword">int</span> t = son;</span><br><span class="line">		fa[son] = root;</span><br><span class="line">		son = fa[t];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> root1 = <span class="built_in">find</span>(a), root2 = <span class="built_in">find</span>(b);</span><br><span class="line">	<span class="keyword">if</span> (root1 != root2)	fa[root1] = root2, cnt--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> num[a] &gt; num[b];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n, m;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">			flag[i] = <span class="number">0</span>, e[i].<span class="built_in">clear</span>(), fa[i] = p[i] = i, <span class="built_in">cin</span> &gt;&gt; num[i];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> l, r;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">			e[l].push_back(r), e[r].push_back(l);</span><br><span class="line">		&#125;</span><br><span class="line">		sort(p + <span class="number">1</span>, p + <span class="number">1</span> + n, cmp);</span><br><span class="line">		cnt = <span class="number">1</span>;</span><br><span class="line">		ll ans = <span class="number">0</span>;</span><br><span class="line">		flag[p[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			ans += (ll)cnt * (num[p[i - <span class="number">1</span>]] - num[p[i]]);</span><br><span class="line">			cnt++;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> x : e[p[i]]) &#123;</span><br><span class="line">				<span class="keyword">int</span> u = p[i];</span><br><span class="line">				<span class="keyword">if</span> (!flag[x])	<span class="keyword">continue</span>;</span><br><span class="line">				join(u, x);</span><br><span class="line">			&#125;</span><br><span class="line">			flag[p[i]] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ans += (ll)cnt * num[p[n]];</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>杭电多校第三场 1009 Parentheses Matching 题解</title>
    <url>/2020/07/29/%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B8%89%E5%9C%BA-1009-Parentheses-Matching-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6799" target="_blank" rel="noopener">题目大意</a></h3><p>给你一个只含有$*,(,)$三种字符的字符串。</p>
<p>你可以将*变成空字符串或者左右括号，你需要使左右括号匹配，并且使这个字符串字典序最小，输出最后的字符串。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>我是真的不是很会写字符串。</p>
<p>比赛发现自己一身都是弱点。。</p>
<p>之前打cf时也差不多，只要碰上字符串的题目，稍微难一点就不会写了。</p>
<p>难受。</p>
<p>其实只是单纯的匹配到还挺简单的，只需要按照可以统计左括号的数量，每遇到一个右括号，就使左括号的数量减一，并且统计之前的*数量。</p>
<p>如果匹配到右括号发现左括号没了，就可以让*变成左括号。</p>
<p>如果匹配到最后，发现左括号多了，就可以让*变成右括号。</p>
<p>多出来就删掉。</p>
<p>关键是需要字典序最小。</p>
<p>这里可以使用贪心，尽可能在最左边变成左括号，在最右边变成右括号。</p>
<p>最后需要判断是否满足匹配的字符串即可。</p>
<p>可以用pos数组来记录一下*的位置，优先使用最前面的。</p>
<p>这里记录一下，本来都过了的，因为用了memset，导致超时了，还特别严重。</p>
<p>ac代码400+ms，用了memset2sT了。</p>
<p>查了一下，发现memset效率和for循环差不多。</p>
<p>下次还是按照题目大小来用for吧。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> pos[N];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="comment">//string s;</span></span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">		<span class="keyword">int</span> l = <span class="built_in">strlen</span>(s);</span><br><span class="line">		<span class="keyword">int</span> cnt = <span class="number">0</span>, pre = <span class="number">0</span>, now = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//memset(pos, -1, sizeof(pos));</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= l; i++)	pos[i] = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (s[i] == <span class="string">'('</span>) cnt++;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">')'</span>) &#123;</span><br><span class="line">				cnt--;</span><br><span class="line">				<span class="keyword">if</span> (cnt &lt; <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">if</span> (pos[now]==<span class="number">-1</span>)	<span class="keyword">break</span>;</span><br><span class="line">					now = pos[now];</span><br><span class="line">					s[now - <span class="number">1</span>] = <span class="string">'('</span>;</span><br><span class="line">					cnt = <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> pos[pre] = i+<span class="number">1</span>, pre = i+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (cnt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = l - <span class="number">1</span>; i&gt;=<span class="number">0</span> &amp;&amp; cnt; i--) &#123;</span><br><span class="line">				<span class="keyword">if</span> (s[i] == <span class="string">'*'</span>)	cnt--,s[i] = <span class="string">')'</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (s[i] == <span class="string">'('</span>) cnt++;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">')'</span>) &#123;</span><br><span class="line">				cnt--;</span><br><span class="line">				<span class="keyword">if</span> (cnt &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (cnt!=<span class="number">0</span>)	<span class="built_in">cout</span> &lt;&lt; <span class="string">"No solution!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (s[i] != <span class="string">'*'</span>)	<span class="built_in">cout</span> &lt;&lt; s[i];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>杭电多校第二场 1006 The Oculus 题解</title>
    <url>/2020/07/25/%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%BA%8C%E5%9C%BA-1006-The-Oculus-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6768" target="_blank" rel="noopener">题目大意</a></h3><p>给你一个从1,2开始的斐波那契数列，给你三个数$a,b,c$，以及三个数用斐波那契数列的表示形式，这个c是修改后的c，原本c等于a*b，但是将其中一位的1替换成了0，问你是哪一位替换了。</p>
<p>$\large b_1\times F_1+b_2\times F_2+\dots+b_n\times F_n=x$</p>
<p>其中的$b_n\in {0,1}$。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>说实话，这个题目原题好吓人。</p>
<p>看了一下没看懂，就没去做这个题目了。</p>
<p>补题的时候发现其实这个应该是签到题。</p>
<p>我们已经知道了a和b的值，只需要用这两个数的乘积减去c，然后判断这个差值是等于哪一位斐波那契数列的值即可。</p>
<p>即需要找到满足使斐波那契数列两两不相同的模数P，使$F_kmodp=(a*b-c)modP$。</p>
<p>这一步应该是这个题的难点了。</p>
<p>（反正我是没想到。。</p>
<p>看了一个大佬的题解，貌似可以用暴力枚举，求出一个值3799912185593857。</p>
<p>但是其他题解都是用的$2^{64}$，即ull的自然溢出。</p>
<p>但是我不知道为啥$2^{64}$就能满足这个条件。。</p>
<p>可能对于大佬来说这就是常识吧。。</p>
<p>像上场比赛的1005一样，一开始不知道为啥n可以摸mod-1，后来一查才发现，是用了欧拉降幂。。</p>
<p>我太弱了。。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e6</span> + <span class="number">5</span>;</span><br><span class="line">ull F[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	F[<span class="number">1</span>] = <span class="number">1</span>, F[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; maxn; i++)</span><br><span class="line">		F[i] = F[i - <span class="number">1</span>] + F[i - <span class="number">2</span>];</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> A, B, C;</span><br><span class="line">		ull a, b, c;</span><br><span class="line">		a = b = c = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; A;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= A; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> x;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">			<span class="keyword">if</span> (x)	a += F[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; C;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= C; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> x;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">			<span class="keyword">if</span> (x)	b += F[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; C;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= C; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> x;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">			<span class="keyword">if</span> (x)	c += F[i];</span><br><span class="line">		&#125;</span><br><span class="line">		ull ans = a * b;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (ans - c != F[i])	i++;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title>杭电多校第五场 1008 Set2 题解</title>
    <url>/2020/08/07/%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%BA%94%E5%9C%BA-1008-Set2-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6821" target="_blank" rel="noopener">题目大意</a></h3><p>有一个大小为n的集合，${1,…,n}$，你需要每次删除其中最小的那个元素，以及另外随机删除k个元素，求每个元素的剩下来的概率。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>本来应该是先写Set1的，但是Set2的dp思路可以适合Set1，就先写Set2了。</p>
<p>看了官方的题解，看了半天看不懂，太长了。</p>
<p>百度到了一个大佬的博客，代码很简单。</p>
<p>但是这个思路很难理解，太难想了。</p>
<p>设$ans[i]$为倒数第i个数的存活概率。</p>
<p>首先求出剩余多少个数，$last=n%(k+1)$。</p>
<p>把剩下的个数的存活概率初始化为1。</p>
<p>然后将过程倒过来，每次加一个人，然后如果这个人不是必须要被删除的，就可以更新状态。</p>
<p>如果这个数及右边的数被$(k+1)$取余后剩余1，则说明这个数是会被作为最小的那个数删除的。</p>
<p>如果不是必须删除的，则从大到小更新状态。</p>
<p>如果删除的是第i个数之后的数，则对$ans[i]$无影响，继承$ans[i]$。</p>
<p>如果删除的是第i个数之前的数，则相当于是让i向前移动了一位，继承$ans[i-1]$。</p>
<p>在继承的时候乘上概率即可。</p>
<p>需要初始化inv数组。</p>
<p>这个dp让我自己想，估计一辈子想不出来。。</p>
<p>看题解就看了好久。</p>
<!--more-->

<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>, maxn = <span class="number">5050</span>;</span><br><span class="line">ll inv[maxn], ans[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)	ans = (ans * a % mod) % mod;</span><br><span class="line">		a = (a * a) % mod, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t; <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= <span class="number">5000</span>; i++) inv[i] = qpow(i, mod - <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n, k;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">		<span class="keyword">int</span> last = n % (k + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= last; i++)	ans[i] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = last + <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			ans[i] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> ((n - i + <span class="number">1</span>) % (k + <span class="number">1</span>) == <span class="number">1</span>)	<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">				ans[j] = (ans[j] * (i - j)%mod * inv[i]%mod + ans[j - <span class="number">1</span>] * (j - <span class="number">1</span>)%mod * inv[i]%mod) % mod;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--)	<span class="built_in">printf</span>(<span class="string">"%lld%c"</span>, ans[i], i == <span class="number">1</span> ? <span class="string">'\n'</span> : <span class="string">' '</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>杭电多校第九场 1003 Slime and Stones 题解</title>
    <url>/2020/08/19/%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B9%9D%E5%9C%BA-1003-Slime-and-Stones-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6869" target="_blank" rel="noopener">题目大意</a></h3><p>有两堆石头，每个人每回合可以在任意一堆取任意个或者从第一堆取x个，第二堆取y个，$|x-y|\leq k$，每人采取最佳策略，问先手是否必胜。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这个题目就是扩展威佐夫博弈。</p>
<p>听都没听过。。</p>
<p>威佐夫博弈点<a href="https://zhuanlan.zhihu.com/p/149621032" target="_blank" rel="noopener">这里</a>。</p>
<p>威佐夫博弈就是这个题目k为0的情况。</p>
<p>当k不等于0的时候，可以得到式子，详解见这个<a href="https://blog.csdn.net/qq_43814654/article/details/108086427" target="_blank" rel="noopener">博客</a>。</p>
<p>懒得推了（其实是不会。。</p>
<p>得到正解之后的式子之后，二分b，如果没找到，则说明不在数列中，必赢，如果找到了，如果a也满足，则必输，否则必赢。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line">ll a, b, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    k++;</span><br><span class="line">    ll l, r;</span><br><span class="line">    l = <span class="number">0</span>, r = <span class="number">1e8</span> + <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        ll mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        ll tmp = mid * ((<span class="built_in">sqrt</span>((k - <span class="number">2</span>) * (k - <span class="number">2</span>) + <span class="number">4</span> * k) - k + <span class="number">2</span>) / <span class="number">2</span>) + k * mid;</span><br><span class="line">        <span class="keyword">if</span> (tmp &gt; b)    r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tmp &lt; b)    l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span>  a == (ll)(mid * ((<span class="built_in">sqrt</span>((k - <span class="number">2</span>) * (k - <span class="number">2</span>) + <span class="number">4</span> * k) - k + <span class="number">2</span>) / <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> t; <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; k;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; b) swap(a, b);</span><br><span class="line">        <span class="keyword">int</span> ans = solve();</span><br><span class="line">        <span class="keyword">if</span> (ans == <span class="number">-1</span> || !ans)    <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title>杭电多校第九场 1001 Tree 题解</title>
    <url>/2020/08/19/%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B9%9D%E5%9C%BA-1001-Tree-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6867" target="_blank" rel="noopener">题目大意</a></h3><p>给你一颗n个节点的树，树的序号为1~n，你可以在其中加入任意一条有向边，求树中任意两个可到达的节点的对数。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以发现，当某个节点x加条边到树的根节点的时候，是增加的最多的。</p>
<p>相当于把x节点与除了自己的子节点以外的节点都连了起来。</p>
<p>增加的数量为$n-num[x]$。</p>
<p>其中$num[i]$为i节点的子节点数量。</p>
<p>当你加入了这条边之后，同时他的父节点都会受到影响。</p>
<p>所以增加的数量为$n-num[x]+f[fa]$。</p>
<p>$f[i]$为加入i到根节点的边新增的对数。</p>
<p>取其中的最大值，在加上所有节点的子节点数量，就是最终答案。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v[N];</span><br><span class="line">ll f[N], ans, sum, num[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	num[x] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> t : v[x]) &#123;</span><br><span class="line">		dfs(t), num[x] += num[t];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">	sum += num[x];</span><br><span class="line">	f[x] = <span class="number">1L</span>L * n - num[x] + f[fa];</span><br><span class="line">	ans = <span class="built_in">max</span>(ans, f[x]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> t : v[x]) &#123;</span><br><span class="line">		Dfs(t, x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t; <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)	v[i].<span class="built_in">clear</span>(), f[i] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> x; <span class="built_in">cin</span> &gt;&gt; x; v[x].push_back(i);</span><br><span class="line">		&#125;</span><br><span class="line">		dfs(<span class="number">1</span>);</span><br><span class="line">		ans = sum = <span class="number">0</span>;</span><br><span class="line">		Dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans + sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>杭电多校第二场 1010 Lead of Wisdom 题解</title>
    <url>/2020/07/24/%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%BA%8C%E5%9C%BA-1010-Lead-of-Wisdom-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6772" target="_blank" rel="noopener">题目大意</a></h3><p>有n件装备，总共有k种。每种装备最多选一件，每件装备都有abcd四个属性$\large DMG=\left(100+\sum_\limits{i\in S} a_i\right)\left(100+\sum_\limits{i\in S} b_i\right)\left(100+\sum_\limits{i\in S} c_i\right)\left(100+\sum_\limits{i\in S} d_i\right)$</p>
<p>求这个式子的最大值。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>刚开始看到这个题目的时候，发现这个数据不大，就想着应该可以暴力搜索。</p>
<p>但是t了好几遍，就没写了。</p>
<p>后面比完了看题解，？怎么和我的思路一模一样。</p>
<p>但是我的t了。</p>
<p>结果发现我vector忘初始化了。</p>
<p>吐了，被自己蠢哭了。</p>
<p>后面初始化之后就过了。</p>
<p>唉。。希望自己不要再犯这么低级的错误了。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line">ll ans;</span><br><span class="line"><span class="keyword">int</span> flag[<span class="number">55</span>];</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> a, b, c, d;</span><br><span class="line">&#125;T;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="built_in">vector</span>&lt;T&gt; e[<span class="number">55</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">cal</span><span class="params">(ll a, ll b, ll c, ll d)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="number">100</span> + a) * (<span class="number">100</span> + b) * (<span class="number">100</span> + c) * (<span class="number">100</span> + d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> j,ll a,ll b,ll c,ll d)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> x : e[t]) &#123;</span><br><span class="line">		a += x.a, b += x.b, c += x.c, d += x.d;</span><br><span class="line">		<span class="keyword">if</span> (j==v.<span class="built_in">size</span>()<span class="number">-1</span>) &#123;</span><br><span class="line">			ans = <span class="built_in">max</span>(ans, cal(a, b, c, d));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			slove(v[j+<span class="number">1</span>],j+<span class="number">1</span>, a, b, c, d);</span><br><span class="line">		&#125;</span><br><span class="line">		a -= x.a, b -= x.b, c -= x.c, d -= x.d;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(flag, <span class="number">0</span>, <span class="keyword">sizeof</span>(flag));</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">		v.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)	e[i].<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> ty;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; ty;</span><br><span class="line">			<span class="keyword">if</span> (!flag[ty])	v.push_back(ty);</span><br><span class="line">			flag[ty] = <span class="number">1</span>;</span><br><span class="line">			T a;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; a.a &gt;&gt; a.b &gt;&gt; a.c &gt;&gt; a.d;</span><br><span class="line">			e[ty].push_back(a);</span><br><span class="line">		&#125;</span><br><span class="line">		ans = <span class="number">0</span>;</span><br><span class="line">		slove(v[<span class="number">0</span>],<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>杭电多校第五场 1009 Paperfolding 题解</title>
    <url>/2020/08/05/%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%BA%94%E5%9C%BA-1009-Paperfolding-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6822" target="_blank" rel="noopener">题目大意</a></h3><p>有一张纸，你有n次对折的机会，有两种方式，向左折和向右折，两种方式等概率出现，折完之后，沿中心切十字，求切完剩下的纸片数量的期望值。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>刚开始看到这个题目的时候，看到n这么大，应该是有公式的，不可能递推。</p>
<p>想了半天，蒙了个公式，wa了。。</p>
<p>看到大佬的博客，一个很好的方法。</p>
<p>假设上下对折a次，左右对折b次，图中的虚线为对折线，实线为裁剪线。</p>
<p><img src="https://ae01.alicdn.com/kf/H8f05daf994af45c09bebc1d475874b97J.jpg" alt=""></p>
<p>对着最终的纸裁剪，就相当于是对折痕的每一个纸片都十字裁剪。</p>
<p>可以得出最终纸片数量为$(2^a+1)(2^b+1)$。</p>
<p>如该图，左右对折两次，上下对折两次，纸片数量为5*5=25。</p>
<p>官方题解是说，原本是横竖裁一次，每对折一次是相当于每次增加了$2^n$次。</p>
<p>其实差不多，这俩思路。</p>
<p>可以得出期望为$ \large E(x) = \frac{1}{2^n}\sum_{i=0}^n C_n^i(2^i + 1)(2^{n-i} + 1)$</p>
<p>可以拆成$\large \sum_{i=0}^n C_n^i(2^n + 1+2^{n-i} + 2^i)$。</p>
<p>因为$\large \sum_{i=0}^n C_n^i$是等于$2^n$，所以$ \large E(x) = 1+2^n+\frac{1}{2^n}\sum_{i=0}^n C_n^i(2^i+2^{n-i})$。</p>
<p>对最后那一项，由$\large3^n=(2+1)^n=\sum_{i=0}^nC_n^i2^i1^{n-i}=\sum_{i=0}^nC_n^i2^i$。</p>
<p>同理可得，$\large3^n=\sum_{i=0}^nC_n^i2^{n-i}$。</p>
<p>所以$ \large E(x) = 1+2^n+\frac{2\times 3^n}{2^n}$。</p>
<p>用快速幂求解即可。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)	ans = (ans * a % mod) % mod;</span><br><span class="line">		a = (a * a % mod) % mod, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		ll n;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		ll ans = (<span class="number">1</span> + qpow(<span class="number">2</span>, n) % mod + <span class="number">2</span> * (qpow(<span class="number">3</span>, n) % mod * qpow(qpow(<span class="number">2</span>, n), mod - <span class="number">2</span>) % mod)) % mod;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>期望</tag>
        <tag>数论</tag>
        <tag>规律</tag>
      </tags>
  </entry>
  <entry>
    <title>杭电多校第五场 1001 Tetrahedron 题解</title>
    <url>/2020/08/05/%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%BA%94%E5%9C%BA-1001-Tetrahedron-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6814" target="_blank" rel="noopener">题目大意</a></h3><p>给你一个n，abc三个数为$[1,n]$中等概率出现的数，求$\large \frac{1}{h^2}$的期望。</p>
<p><img src="https://ae01.alicdn.com/kf/Hc696fb9943bc4a2aafa626f9afa5843aq.jpg" alt=""></p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>不得不说，这场是真的变态。</p>
<p>这题有很多解法，建系，向量，海伦公式都可以。</p>
<p>这边就选用向量法来做。</p>
<p>（因为稍微简单一点。。</p>
<p>由体积可以推出，$\large \frac{abc}{6}=\frac{Sh}{3}$。</p>
<p>即$abc=2Sh$。</p>
<p>而$S = |\vec{AB} \times \vec{BC}|$。</p>
<p>设$\vec{a}=\vec{DA}，\vec{b}=\vec{DB}，\vec{c}=\vec{DC}$。<br>$$<br>\vec{AB} \times \vec{BC} = (\vec{b} - \vec{a}) \times (\vec{c} - \vec{b})=\vec{b} \times \vec{c} - \vec{a} \times \vec{c} - \vec{a} \times \vec{b}<br>$$<br>因为上面三个面互相垂直，所以他们的平面的法向量也是互相垂直的。</p>
<p>所以，平方得<br>$$<br>|\vec{AB} \times \vec{BC}|^2 = |\vec{b} \times \vec{c} - \vec{a} \times \vec{c} - \vec{a} \times \vec{b}|^2=|\vec{b} \times \vec{c}|^2+|\vec{a} \times \vec{c}|^2+|\vec{a} \times \vec{b}|^2=\frac{b^2c^2}{4}+\frac{a^2c^2}{4}+\frac{a^2b^2}{4}<br>$$<br>带入$abc = 2Sh$得，$\large \frac{1}{h^2}=\frac{1}{a^2} + \frac{1}{b^2} +\frac{1}{c^2}$。</p>
<p>因为abc三个数可以任意取，之间没有关系，所以三个数的期望是一样的，得$E(\large \frac{1}{h^2})=3 E(\large \frac{1}{a^2})$。</p>
<p>之后的期望就好求了，需要预处理逆元的前缀和。</p>
<p>但是这个逆元的前缀和不能用快速幂来求，会T。</p>
<p>（但是比赛的时候是能过的。</p>
<p>所以需要用递推来求逆元。</p>
<p>详解见大佬<a href="https://blog.csdn.net/Frods/article/details/53868810" target="_blank" rel="noopener">博客</a>。</p>
<p>（用的递推都差点超了。。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>, maxn = <span class="number">6e6</span> + <span class="number">5</span>;</span><br><span class="line">ll fiv[maxn], sum[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t; <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">	fiv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">6e6</span>; i++) &#123;</span><br><span class="line">		fiv[i] = (mod - mod / i) * fiv[mod % i] % mod;<span class="comment">//递推求逆元</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6e6</span>; i++) &#123;</span><br><span class="line">		sum[i] = (sum[i - <span class="number">1</span>] + fiv[i]*fiv[i]) % mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">		ll ans = (<span class="number">3</span> * (sum[n] % mod * fiv[n]) % mod) % mod;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>杭电多校第五场 1012 Set1 题解</title>
    <url>/2020/08/07/%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%BA%94%E5%9C%BA-1012-Set1-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6825" target="_blank" rel="noopener">题目大意</a></h3><p>有一个大小为n的集合，${1,…,n}$，你需要每次删除其中最小的那个元素，以及另外随机删除1个元素，求每个元素的剩下来的概率。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这题和Set2差不多，Set2代码可以求出这个题目的正解，但是会T。</p>
<p>然后这题就是找规律。</p>
<p>（不知道那些人怎么找出来的。。</p>
<p>显然，前$\large \frac{n}{2}$个数都是0。</p>
<p>可以用Set2的代码跑案例，得出规律。</p>
<p>当n等于7的时候，跑出来是$\large \frac{4}{2},\frac{5}{4}$。</p>
<p>分母加二，分子加一。</p>
<p>$\large dp[\frac{n+1}{2}]=\frac{1}{2^{\frac{n}{2}}} $。</p>
<p>$\large dp[i+1]=dp[i]\times \frac{\frac{n}{2}+i}{2i}\ (1\leq i&lt;n-1)$。</p>
<p>$\large dp[n]=dp[n-1]$。</p>
<p>按照这个规律写代码即可。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)	ans = (ans * a % mod) % mod;</span><br><span class="line">		a = (a * a) % mod, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t; <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n / <span class="number">2</span>; i++)	<span class="built_in">cout</span> &lt;&lt; <span class="string">"0 "</span>;</span><br><span class="line">		ll ans = qpow(qpow(<span class="number">2</span>, n / <span class="number">2</span>), mod - <span class="number">2</span>);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n / <span class="number">2</span>; i++) &#123;</span><br><span class="line">			ans = ans * (n / <span class="number">2</span> + i) % mod * qpow(<span class="number">2</span> * i, mod - <span class="number">2</span>) % mod;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>规律</tag>
      </tags>
  </entry>
  <entry>
    <title>杭电多校第八场 1008 Hexagon 题解</title>
    <url>/2020/08/15/%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E7%AC%AC%E5%85%AB%E5%9C%BA-1008-Hexagon-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6862" target="_blank" rel="noopener">题目大意</a></h3><p>给你一个半径为n的六边形网格，需要你在走满网格的同时，尽量相邻的每一步的方向不同，输出路径。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>一眼就可以看出来是一个构造题。。</p>
<p>但是我不是很喜欢写这种题啊。</p>
<p>写起来好麻烦。</p>
<p>直接看图来构造吧。</p>
<p>图来自于大佬的<a href="https://blog.csdn.net/lylzsx20172018/article/details/107997289" target="_blank" rel="noopener">博客</a>。</p>
<p>当半径为偶数时。</p>
<p><img src="https://ae01.alicdn.com/kf/H089f5aadf6284629bec8173a591a536co.jpg" alt=""></p>
<p>$3[42424][53535][64646][15151][26262][313]4$</p>
<p>当半径为奇数时。</p>
<p><img src="https://ae01.alicdn.com/kf/H7b17d977626d4aa7a89f7eb2748d898bS.jpg" alt=""></p>
<p>$3[4242424][5353535][6464646][1515151][2626262][31313]4$</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t; <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		<span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">1</span>; i -= <span class="number">2</span>) &#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line">				<span class="keyword">int</span> a = <span class="number">4</span>, b = <span class="number">2</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">5</span>; j++) &#123;</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= i; k++)	<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; b;</span><br><span class="line">					<span class="built_in">cout</span> &lt;&lt; a;</span><br><span class="line">					(a %= <span class="number">6</span>)++, (b %= <span class="number">6</span>)++;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; a;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i - <span class="number">1</span>; j++)	<span class="built_in">cout</span> &lt;&lt; b &lt;&lt; a;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i -= <span class="number">2</span>) &#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line">				<span class="keyword">int</span> a = <span class="number">4</span>, b = <span class="number">2</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">5</span>; j++) &#123;</span><br><span class="line">					<span class="keyword">if</span> (i == <span class="number">1</span> &amp;&amp; j == <span class="number">5</span>)	<span class="keyword">break</span>;</span><br><span class="line">					<span class="built_in">cout</span> &lt;&lt; a;</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= i - <span class="number">1</span>; k++)	<span class="built_in">cout</span> &lt;&lt; b &lt;&lt; a;</span><br><span class="line">					(a %= <span class="number">6</span>)++, (b %= <span class="number">6</span>)++;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (i != <span class="number">1</span>) &#123;</span><br><span class="line">					<span class="built_in">cout</span> &lt;&lt; a;</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i - <span class="number">2</span>; j++) <span class="built_in">cout</span> &lt;&lt; b &lt;&lt; a;</span><br><span class="line">					<span class="built_in">cout</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>规律</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>杭电多校第六场 1006 A Very Easy Graph Problem 题解</title>
    <url>/2020/08/09/%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E7%AC%AC%E5%85%AD%E5%9C%BA-1006-A-Very-Easy-Graph-Problem-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6832" target="_blank" rel="noopener">题目大意</a></h3><p>给你一个n个点的无向图，每个点分为0和1两类，每条边的长度为$\large2^i$，求所有不同类型的点对最短路之和。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>由于每条边的长度为$2^i$，所以前面所有的边长度加起来都没有这条边长。</p>
<p>所以在第i条边加进来的时候，之前联通的点必然是最短路，所以不用管已经联通的点了，剩下的可以用并查集来构成一棵树。</p>
<p>接下来就是对树进行dfs。</p>
<p>定义节点类型，有ty，dp数组和sum。</p>
<blockquote>
<p>ty代表该节点的类型。</p>
<p>dp[0] [0]表示以该节点为根节点的子树中所有ty=0的节点到根节点的距离和。</p>
<p>dp[0] [1]表示以该节点为根节点的子树中所有ty=0的节点数量。</p>
<p>dp[1] [0]表示以该节点为根节点的子树中所有ty=1的节点到根节点的距离和。</p>
<p>dp[1] [1]表示以该节点为根节点的子树中所有ty=1的节点数量。</p>
<p>sum为以该节点为根节点的子树中所有不同类型的点对距离和。</p>
</blockquote>
<p>dp数组的转移为</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; ~i; i = edge[i].next) &#123;</span><br><span class="line">		<span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">		ll w = edge[i].val;</span><br><span class="line">		<span class="keyword">if</span> (v == f)	<span class="keyword">continue</span>; dfs(v, x);</span><br><span class="line">		node[x].dp[<span class="number">0</span>][<span class="number">0</span>] = (node[x].dp[<span class="number">0</span>][<span class="number">0</span>] + (node[v].dp[<span class="number">0</span>][<span class="number">0</span>] + w * node[v].dp[<span class="number">0</span>][<span class="number">1</span>] % mod) % mod) % mod;</span><br><span class="line">		node[x].dp[<span class="number">1</span>][<span class="number">0</span>] = (node[x].dp[<span class="number">1</span>][<span class="number">0</span>] + (node[v].dp[<span class="number">1</span>][<span class="number">0</span>] + w * node[v].dp[<span class="number">1</span>][<span class="number">1</span>] % mod) % mod) % mod;</span><br><span class="line">		node[x].dp[<span class="number">0</span>][<span class="number">1</span>] += node[v].dp[<span class="number">0</span>][<span class="number">1</span>], node[x].dp[<span class="number">1</span>][<span class="number">1</span>] += node[v].dp[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>距离的统计为，到同类型到子节点的距离加上其他所有的同类型的点乘以这条边的距离。</p>
<p>数量的统计则直接相加就可以了。</p>
<p>sum的转移为</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; ~i; i = edge[i].next) &#123;</span><br><span class="line">		<span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">		ll w = edge[i].val;</span><br><span class="line">		<span class="keyword">if</span> (v == f)	<span class="keyword">continue</span>;</span><br><span class="line">		node[x].sum = (node[x].sum + node[v].sum) % mod;</span><br><span class="line">		node[x].sum = (node[x].sum + (node[x].dp[<span class="number">0</span>][<span class="number">1</span>] - node[v].dp[<span class="number">0</span>][<span class="number">1</span>]) * (node[v].dp[<span class="number">1</span>][<span class="number">0</span>] + w * node[v].dp[<span class="number">1</span>][<span class="number">1</span>]) % mod) % mod;</span><br><span class="line">		node[x].sum = (node[x].sum + (node[x].dp[<span class="number">1</span>][<span class="number">1</span>] - node[v].dp[<span class="number">1</span>][<span class="number">1</span>]) * (node[v].dp[<span class="number">0</span>][<span class="number">0</span>] + w * node[v].dp[<span class="number">0</span>][<span class="number">1</span>]) % mod) % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sum的转移比较麻烦。</p>
<p>首先加上子节点的距离。</p>
<p>之后为除去以该子节点为根节点的树中的ty为0的数量乘上以该子节点为根节点的ty为1的点到x的距离。</p>
<p>后面的则为ty=1的转移。</p>
<p>刚开始卡了我好久，认为ty=0乘上ty=1的距离还少了一段ty=0到根节点的距离。</p>
<p>后来仔细想了想，才发现，这里的ty=0到ty=1与后面的ty=1到ty=0两段合起来，就是完整的距离了。</p>
<p>好妙啊。。</p>
<p>其实这题还有其他的做法，像点分治，最小生成树等。</p>
<p>但我没学点分治，就用的这个了。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt, head[N], fa[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> to, next;</span><br><span class="line">	ll val;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> ty;</span><br><span class="line">	ll dp[<span class="number">2</span>][<span class="number">2</span>], sum;</span><br><span class="line">&#125;node[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, ll val)</span> </span>&#123;</span><br><span class="line">	edge[++cnt].to = v, edge[cnt].val = val;</span><br><span class="line">	edge[cnt].next = head[u], head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)	ans = (ans * a % mod) % mod;</span><br><span class="line">		a = (a * a) % mod, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> son)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> root = son, t;</span><br><span class="line">	<span class="keyword">while</span> (fa[root] != root)	root = fa[root];</span><br><span class="line">	<span class="keyword">while</span> (son != root) &#123;</span><br><span class="line">		t = fa[son];</span><br><span class="line">		fa[son] = root;</span><br><span class="line">		son = t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">	node[x].dp[node[x].ty][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; ~i; i = edge[i].next) &#123;</span><br><span class="line">		<span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">		ll w = edge[i].val;</span><br><span class="line">		<span class="keyword">if</span> (v == f)	<span class="keyword">continue</span>; dfs(v, x);</span><br><span class="line">		node[x].dp[<span class="number">0</span>][<span class="number">0</span>] = (node[x].dp[<span class="number">0</span>][<span class="number">0</span>] + (node[v].dp[<span class="number">0</span>][<span class="number">0</span>] + w * node[v].dp[<span class="number">0</span>][<span class="number">1</span>] % mod) % mod) % mod;</span><br><span class="line">		node[x].dp[<span class="number">1</span>][<span class="number">0</span>] = (node[x].dp[<span class="number">1</span>][<span class="number">0</span>] + (node[v].dp[<span class="number">1</span>][<span class="number">0</span>] + w * node[v].dp[<span class="number">1</span>][<span class="number">1</span>] % mod) % mod) % mod;</span><br><span class="line">		node[x].dp[<span class="number">0</span>][<span class="number">1</span>] += node[v].dp[<span class="number">0</span>][<span class="number">1</span>], node[x].dp[<span class="number">1</span>][<span class="number">1</span>] += node[v].dp[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; ~i; i = edge[i].next) &#123;</span><br><span class="line">		<span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">		ll w = edge[i].val;</span><br><span class="line">		<span class="keyword">if</span> (v == f)	<span class="keyword">continue</span>;</span><br><span class="line">		node[x].sum = (node[x].sum + node[v].sum) % mod;</span><br><span class="line">		node[x].sum = (node[x].sum + (node[x].dp[<span class="number">0</span>][<span class="number">1</span>] - node[v].dp[<span class="number">0</span>][<span class="number">1</span>]) * (node[v].dp[<span class="number">1</span>][<span class="number">0</span>] + w * node[v].dp[<span class="number">1</span>][<span class="number">1</span>]) % mod) % mod;</span><br><span class="line">		node[x].sum = (node[x].sum + (node[x].dp[<span class="number">1</span>][<span class="number">1</span>] - node[v].dp[<span class="number">1</span>][<span class="number">1</span>]) * (node[v].dp[<span class="number">0</span>][<span class="number">0</span>] + w * node[v].dp[<span class="number">0</span>][<span class="number">1</span>]) % mod) % mod;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t; <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n, m;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">		cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			head[i] = <span class="number">-1</span>; fa[i] = i; <span class="built_in">cin</span> &gt;&gt; node[i].ty;</span><br><span class="line">			node[i].sum = <span class="number">0</span>; <span class="built_in">memset</span>(node[i].dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(node[i].dp));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> u, v; <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">			<span class="keyword">if</span> (u &gt; v)	swap(u, v);</span><br><span class="line">			<span class="keyword">int</span> rt1 = <span class="built_in">find</span>(u), rt2 = <span class="built_in">find</span>(v);</span><br><span class="line">			<span class="keyword">if</span> (rt1 == rt2)	<span class="keyword">continue</span>;</span><br><span class="line">			ll w = qpow(<span class="number">2</span>, i);</span><br><span class="line">			build(u, v, w), build(v, u, w), fa[rt2] = rt1;</span><br><span class="line">		&#125;</span><br><span class="line">		dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; node[<span class="number">1</span>].sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>并查集</tag>
        <tag>树上统计</tag>
      </tags>
  </entry>
  <entry>
    <title>杭电多校第六场 1009 Divisibility 题解</title>
    <url>/2020/08/08/%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E7%AC%AC%E5%85%AD%E5%9C%BA-1009-Divisibility-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6835" target="_blank" rel="noopener">题目大意</a></h3><p>给你两个数，b和x，问在b进制下，将任意一个数y的每一位不断加起来，直到只有一位，问是否满足这一位数能被x整除，则y被x整除，否则则不能整除的理论。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>其实这个也不算难证，比赛的时候脑抽了，卡了好久。。</p>
<p>证明就懒得证了，直接上官方题解吧。</p>
<p>（证的又详细还比我好。。</p>
<p><img src="http://inews.gtimg.com/newsapp_ls/0/12584395355/0" alt=""></p>
<p>由这个定理可知，$f(a)=f(a\ mod\ m)$。</p>
<p>所以只要$\displaystyle f(y) = \sum_{i=1}^n c_i\equiv 0 \pmod{x}$则$\underbrace{f( f( \cdots f(y) \cdots ))}_{\infty} \equiv 0 \pmod{x}$</p>
<p>那么原命题等价于：对于任意的 $b$ 进制正整数 $y = \overline{c_1 c_2 \cdots c_n}$，如果 $c_1 + c_2 + \cdots + c_n \equiv 0 \pmod{x}$，那么 $y \equiv 0 \pmod{x}$，否则 $y \not\equiv 0 \pmod{x}$。</p>
<p>上述命题成立当且仅当 $b \equiv 1 \pmod{x}$。</p>
<p>证明：</p>
<ul>
<li>当 $b \equiv 1 \pmod{x}$ 时，有 $y \equiv c_1 b^{n-1} + c_2 b^{n-2} + \cdots + c_n b^0 \equiv c_1 + c_2 + \cdots + c_n \pmod{x}$，于是上述命题成立。</li>
<li>当 $b \not\equiv 1 \pmod{x}$ 时，假设上述命题成立，有：<ul>
<li>若 $x \leq b$，令 $y = 1 \cdot b^1 + (x-1) b^0$，则应有 $y \equiv b + x - 1 \equiv 0 \pmod{x}$，即 $b \equiv 1 \pmod{x}$，但此时 $b \not\equiv 1 \pmod{x}$，出现矛盾，于是上述命题不成立。</li>
<li>若 $x &gt; b$，令 $y = x = \overline{c_1 c_2 \cdots c_n}$，显然 $c_1 + c_2 + \cdots + c_n \not\equiv 0 \pmod{x}$，于是 $y \not\equiv 0 \pmod{x}$，但 $y \equiv 0 \pmod{x}$，出现矛盾，于是上述命题不成立。</li>
</ul>
</li>
</ul>
<p>综上，上述命题成立当且仅当 $b \equiv 1 \pmod{x}$。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">slove</span><span class="params">(ll a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; <span class="number">10</span>)    <span class="keyword">return</span> a;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (a) &#123;</span><br><span class="line">        ans += a % <span class="number">10</span>, a /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    slove(ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        ll n;</span><br><span class="line">        ll x;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span> ((n<span class="number">-1</span>)%x==<span class="number">0</span>)    <span class="built_in">cout</span> &lt;&lt; <span class="string">"T"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"F"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>杭电多校第六场 1001 Road To The 3rd Building 题解</title>
    <url>/2020/08/08/%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E7%AC%AC%E5%85%AD%E5%9C%BA-1001-Road-To-The-3rd-Building-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6827" target="_blank" rel="noopener">题目大意</a></h3><p>输入n个可爱值，在1到n中任取起点和终点，定义可爱水平为起点到终点每个点的可爱值之和除以区间长度，随机选择一种方案，求可爱水平的期望值。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>真的不会写。。太难了。</p>
<p>看了几个题解，要么就是看不懂，要么就是没讲解。我太难了。。</p>
<p>最后终于找到了一个看懂了的题解，不容易啊。</p>
<p>首先，方案数为1到n的等差数列，和为$\Large \frac{n(n+1)}{2}$。</p>
<p>拿样例举例（咋样例都这么臭。。</p>
<blockquote>
<p>对于:  1 1 4 5 1 4每个点的出现次数<br>len=1:1 1 1 1 1 1<br>len=2:1 2 2 2 2 1<br>len=3:1 2 3 3 2 1<br>−−−−−−−−−−−−−−<br>len=4:1 2 3 3 2 1<br>len=5:1 2 2 2 2 1<br>len=6:1 1 1 1 1 1</p>
</blockquote>
<p>设$ans[i]$为长度为i的贡献，$sum[i]$为前缀和数组。</p>
<p>可以得出，前一半$ans[i]=ans[i-1]+sum[n-i+1]-sum[i-1]$。</p>
<p>后一半$ans[i]=ans[i-1]+sum[i]-sum[n-i]$。</p>
<p>初始化$ans[1]=ans[n]=sum[n]$。</p>
<p>如果n是偶数，单独考虑$\Large \frac{n}{2}+1$即可。</p>
<p>注意，在递推的时候，取余的时候需要加一个mod，虽然我知道是为了防止出现负数，但是我不知道为啥会出现负数。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>, maxn = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll sum[maxn], ans[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    a %= mod;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)    ans = (ans * a % mod) % mod;</span><br><span class="line">        a = (a * a) % mod, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> t; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        ll n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;sum[i]);</span><br><span class="line">            sum[i] = (sum[i] + sum[i - <span class="number">1</span>]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            ans[<span class="number">1</span>] = sum[n];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n / <span class="number">2</span>; i++)    ans[i] = (ans[i - <span class="number">1</span>] + sum[n - i + <span class="number">1</span>] - sum[i - <span class="number">1</span>] + mod) % mod;</span><br><span class="line">            ans[n / <span class="number">2</span> + <span class="number">1</span>] = (ans[n / <span class="number">2</span>] + sum[n / <span class="number">2</span> + <span class="number">1</span>] - sum[n / <span class="number">2</span>]) % mod;</span><br><span class="line">            ans[n] = sum[n];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; n / <span class="number">2</span> + <span class="number">1</span>; i--)    ans[i] = (ans[i + <span class="number">1</span>] + sum[i] - sum[n - i] + mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ans[<span class="number">1</span>] = sum[n];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n / <span class="number">2</span>; i++)    ans[i] = (ans[i - <span class="number">1</span>] + sum[n - i + <span class="number">1</span>] - sum[i - <span class="number">1</span>] + mod) % mod;</span><br><span class="line">            ans[n] = sum[n];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; n / <span class="number">2</span>; i--)    ans[i] = (ans[i + <span class="number">1</span>] + sum[i] - sum[n - i] + mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        ll res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    res = (res + (ans[i] * qpow(i, mod - <span class="number">2</span>)) % mod) % mod;</span><br><span class="line">        res = ((res * <span class="number">2</span>) % mod * qpow(n * (n + <span class="number">1</span>), mod - <span class="number">2</span>) % mod) % mod;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>期望</tag>
        <tag>规律</tag>
      </tags>
  </entry>
  <entry>
    <title>杭电多校第八场 1006 Fluctuation Limit 题解</title>
    <url>/2020/08/14/%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E7%AC%AC%E5%85%AB%E5%9C%BA-1006-Fluctuation-Limit-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6860" target="_blank" rel="noopener">题目大意</a></h3><p>给定你n个范围，$[l_i,r_i]$，每个范围之间可以波动k，即$[a_i-k,a_i+k]$，问是否存在某个序列，使得每个数都在范围之内。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>比赛的时候试了一下，wa了两发就溜了。。</p>
<p>本来想是先从i推到i+1，然后用这个约束的范围，再倒推到i的范围，然后wa了。。</p>
<p>后面看题解发现有点类似，但是还是不同。</p>
<p>从第i个范围推到第i+1个范围，只是得到第i个能够到达的范围，但是第i+1个范围还会需要受到后面第i+2的影响。</p>
<p>从第i+2范围推到第i+1个范围，得到的是为了满足第i+2的范围，有哪些是第i+1范围能实现的。</p>
<p>所以需要正着推一遍，把条件往后面推，再用后面的条件来限制前面，就能得到最后的可行域。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; v;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, k, l[N], r[N];</span><br><span class="line"><span class="keyword">int</span> a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t; <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">		v.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> a, b; <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">			v.push_back(&#123; a,b &#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		l[<span class="number">0</span>] = v[<span class="number">0</span>].first, r[<span class="number">0</span>] = v[<span class="number">0</span>].second;</span><br><span class="line">		<span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">			l[i] = <span class="built_in">max</span>(v[i].first, l[i - <span class="number">1</span>] - k);</span><br><span class="line">			r[i] = <span class="built_in">min</span>(v[i].second, r[i - <span class="number">1</span>] + k);</span><br><span class="line">			<span class="keyword">if</span> (r[i] &lt; l[i]) &#123;</span><br><span class="line">				flag = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">			l[i] = <span class="built_in">max</span>(l[i], l[i + <span class="number">1</span>] - k);</span><br><span class="line">			r[i] = <span class="built_in">min</span>(r[i], r[i + <span class="number">1</span>] + k);</span><br><span class="line">			<span class="keyword">if</span> (r[i] &lt; l[i]) &#123;</span><br><span class="line">				flag = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!flag)	<span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; l[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>杭电多校第十场 1011 Task Scheduler 题解</title>
    <url>/2020/08/25/%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E7%AC%AC%E5%8D%81%E5%9C%BA-1011-Task-Scheduler-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6887" target="_blank" rel="noopener">题目大意</a></h3><p>有m个工人在线，k个工人不在线，有n个任务需要分配，每个任务需要$t_i$个工人，工人是随机选择的，选择到不在线的工人会重新选择，求最小分配期望的分配方案，且满足字典序最小。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>怎么总是出这种题啊。。</p>
<p>很烦，不怎么会写。</p>
<p>解题方法，如果k不等于0，则把1~n按照$t_i$大小，按照降序排列。</p>
<p>如果k为0，则直接输出1~n。</p>
<p>需要注意，需要用stable_sort，保证大小相同的值的相对位置不变，这样才能使字典序最小。</p>
<p>补充链接，<a href="http://www.voidcn.com/article/p-whagxzgz-gt.html" target="_blank" rel="noopener">排序并保留索引</a>。</p>
<p>证明不会证了。。（丢人。</p>
<p>直接上大佬的<a href="https://blog.csdn.net/xuxiaobo1234/article/details/108140387" target="_blank" rel="noopener">博客</a>。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;  t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> t[a] &gt; t[b];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//freopen("D:\\测试用\\in.txt", "r", stdin);</span></span><br><span class="line">    <span class="comment">//freopen("D:\\测试用\\out.txt", "w+", stdout);</span></span><br><span class="line">	<span class="keyword">int</span> T; <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n, m, k; <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">		t.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> x; <span class="built_in">cin</span> &gt;&gt; x; t.push_back(x); ans[i] = i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (k)	stable_sort(ans, ans + n, cmp);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; ans[i] + <span class="number">1</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans[n - <span class="number">1</span>] + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>期望</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>杭电多校第十场 1004 Permutation Counting 题解</title>
    <url>/2020/08/23/%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E7%AC%AC%E5%8D%81%E5%9C%BA-1004-Permutation-Counting-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6880" target="_blank" rel="noopener">题目大意</a></h3><p>定义相邻数列，当$a_i&lt;a_{i+1}$时，$b_i=0$，当$a_i&gt;a_{i+1}$时，$b_i=1$。给你一个长度为n-1的相邻数列，问满足这个相邻数列的a数列有多少种。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>说实话，这个题目相当狠啊。</p>
<p>首先你可以构造一个数列c，从1开始按顺序填数字。</p>
<p>如果$b[i]$为1，则把这个数字放到左边。</p>
<p>如果$b[i]$为0，则把这个数字放到右边。</p>
<p>这样就可以构造出一个a数列，满足$\Large a_{c_i}=i$。</p>
<p>因为是从1开始从小到大开始填，所以这个数字的序列比之前的要大，放在左边的就一定小，放在右边的就一定大。</p>
<p>a数列与c数列是一一对应的，所以只需要求出c数列的种类，就是满足b数列的a数列的种类。</p>
<p>定义$dp[i][j]$为第i位填的数字是j的种类数。</p>
<p>如果$b[i]$是1，$dp[i+1][j]=dp[i+1][j+1]+dp[i][j]$。</p>
<p>因为第i+1位需要比第i位要小，所以这一位不能填i+1，只能填入1<del>i，所以他可以继承左边的所有情况，即$dp[i][j]$，因为左边只有1</del>i，同时也能继承比他大的情况，即$dp[i+1][j+1]$。</p>
<p>如果$b[i]$是1，$dp[i+1][j]=dp[i+1][j-1]+dp[i][j-1]$。</p>
<p>因为第i+1位需要比第i位要大，所以这一位不能填1，只能填入2~i+1，所以他只能继承左边比他小的情况，即$dp[i][j-1]$，同时也能继承比他小的情况，即$dp[i+1][j-1]$。</p>
<p>需要注意枚举的方向。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5050</span>, mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> b[N];</span><br><span class="line">ll dp[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> t; <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)    <span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)  dp[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!b[i]) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= i + <span class="number">1</span>; j++)</span><br><span class="line">                    dp[i + <span class="number">1</span>][j] = (dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + dp[i][j - <span class="number">1</span>]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= <span class="number">1</span>; j--)</span><br><span class="line">                    dp[i + <span class="number">1</span>][j] = (dp[i + <span class="number">1</span>][j + <span class="number">1</span>] + dp[i][j]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans = (ans + dp[n][i])%mod;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>杭电多校第四场 1005 Equal Sentences 题解</title>
    <url>/2020/07/30/%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E7%AC%AC%E5%9B%9B%E5%9C%BA-1005-Equal-Sentences-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6806" target="_blank" rel="noopener">题目大意</a></h3><p>把一个单词串定义为与原本单词串s几乎相等，当且仅当单词串只是由原本单词串相邻的单词交换所形成的，求原本单词串有多少个几乎相等的单词串。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>服了这翻译。</p>
<p>我看题看了半天没看懂。</p>
<p>直接跳了。</p>
<p>结果发现这个题目就是简单的dp。。</p>
<p>定义dp[i]为从第一个单词到第i个单词所形成的单词串有多少几乎相等的单词串。</p>
<p>如果第i个单词与第i-1个单词相同，则不需要交换，$dp[i] = dp[i-1]$。</p>
<p>如果第i个单词与第i-1个单词不相同，则不交换时贡献为$dp[i-1]$，交换时贡献为$dp[i-2]$，所以状态转移为$dp[i] = dp[i-1]+dp[i-2]$。</p>
<p>注意初始化$dp[0]=dp[1]=1$。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dp[N];</span><br><span class="line"><span class="built_in">string</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t; <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; s[i];</span><br><span class="line">		dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (s[i] == s[i - <span class="number">1</span>])	dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">			<span class="keyword">else</span> dp[i] = (dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>])%mod;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; dp[n]%mod  &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>杭电多校第十场 1003 Mine Sweeper 题解</title>
    <url>/2020/08/24/%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E7%AC%AC%E5%8D%81%E5%9C%BA-1003-Mine-Sweeper-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6879" target="_blank" rel="noopener">题目大意</a></h3><p>给你一个数字s，求出满足地图上所有数字和为s的扫雷地图。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这个应该算是签到题吧。</p>
<p>想到了应该挺简单的。</p>
<p>这个构造还不算难。</p>
<p>如果$s\leq 24$，只需要构造出一条“$.X$”，满足长度为s+1。</p>
<p>如果$s&gt;24$，可以表示成$8a+3b$，首先，一个单独的X，可以提供8点，在第一行放下连续的X，每个可以提供3点，接下来对余数分析。</p>
<p>如果余数为1，4，7，可以表示成$b+=last/3+3,a–$。</p>
<p>可以减去一个8，加上一个9。</p>
<p>如果余数为2，5，可以表示成$b+=last/3+6,a-=2$。</p>
<p>可以减去一个16，加上一个18。</p>
<p>如果余数为3，6，可以表示成$b+=last/3$。</p>
<p>所以所有情况都是满足的，不存在不满足的情况。</p>
<p>第一行输出b个连续X，后面输出a个单独的X即可。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">char</span> Map[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t; <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> s; <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">		<span class="keyword">if</span> (s &lt;= <span class="number">24</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">			s++;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">while</span> (s--) &#123;</span><br><span class="line">				<span class="keyword">if</span> (flag == <span class="number">1</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">'.'</span>;</span><br><span class="line">				<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">'X'</span>;</span><br><span class="line">				flag *= <span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">int</span> a = s / <span class="number">8</span>, last = s % <span class="number">8</span>, b = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (last == <span class="number">1</span> || last == <span class="number">4</span> || last == <span class="number">7</span>)    b += last / <span class="number">3</span> + <span class="number">3</span>, a--;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (last == <span class="number">2</span> || last == <span class="number">5</span>)    b += last / <span class="number">3</span> + <span class="number">6</span>, a -= <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">else</span>   b += last / <span class="number">3</span>;</span><br><span class="line">			<span class="keyword">int</span> i;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">25</span>; i++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (b)	Map[<span class="number">1</span>][i] = <span class="string">'X'</span>,b--;</span><br><span class="line">				<span class="keyword">else</span> Map[<span class="number">1</span>][i] = <span class="string">'.'</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= <span class="number">25</span> &amp;&amp; a; i++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (i &amp; <span class="number">1</span>) &#123;</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">25</span>; j++) &#123;</span><br><span class="line">						<span class="keyword">if</span> (j &amp; <span class="number">1</span> || !a)	Map[i][j] = <span class="string">'.'</span>;</span><br><span class="line">						<span class="keyword">else</span> <span class="keyword">if</span> ((j &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp; a)	Map[i][j] = <span class="string">'X'</span>, a--;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">25</span>; j++)	Map[i][j] = <span class="string">'.'</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">25</span>; j++)	Map[i][j] = <span class="string">'.'</span>;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span> &lt;&lt; <span class="number">25</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> g = <span class="number">1</span>; g &lt;= i; g++) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">25</span>; j++)	<span class="built_in">cout</span> &lt;&lt; Map[g][j];</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>树形DP</title>
    <url>/2020/07/08/%E6%A0%91%E5%BD%A2DP/</url>
    <content><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>树形dp顾名思义就是在“树”上进行动态规划，通过遍历树等一些操作来完成题目要求。</p>
<p>在树形动态规划中是建立在树上的，由树中的父节点和子节点的关系推出来的。</p>
<p>一般有两种。</p>
<p> 1、就是由子节点推到父节点，即根的子节点传递有用的信息给父节点，最终有父节点再求出最优解。（此形式较为常用）</p>
<p> 2、从父节点推至子节点，这种情况的意思是需要取所有点来求出父节点的值，再减去要除的子节点的dp状态，再将其转移，这样就可由根节点推至叶节点。</p>
<p>通常使用链式前向星来建树。</p>
<a id="more"></a>

<h3 id="实现形式"><a href="#实现形式" class="headerlink" title="实现形式"></a>实现形式</h3><p>树形dp与其他的dp存在一些区别。</p>
<p>他没有固定的形式，很多时候会与其他的算法结合，像背包等等。</p>
<p>与其说是一种算法，说是一种思想更加恰当。</p>
<p>因为自己也不是很理解，也就不详细讲了。。</p>
<p>以后慢慢学习吧，还有很长的路要走。</p>
<p>那这里贴一下链式前向星模板。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">6060</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],cnt,in[N];<span class="comment">//head数组通常初始化为-1，可以用in数组来求一棵树的根节点</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> to, val, next;</span><br><span class="line">&#125;Map[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">	Map[++cnt].to = v;</span><br><span class="line">    Map[cnt].val = val;</span><br><span class="line">	Map[cnt].next = head[u];</span><br><span class="line">	head[u] = cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="典型例题"><a href="#典型例题" class="headerlink" title="典型例题"></a>典型例题</h3><h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1520" target="_blank" rel="noopener">题目大意</a></h4><p>在公司中，老板和员工构成了一个树形结构，每个人有自己的开心值，有一天举办了一个聚会，但是每个人很讨厌和自己的上司一起去，所以上司去他就不会去。问公司最大开心值。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>先用链式前向星构树。</p>
<p>我们可以用$dp[i][0]$来表示，以i为根节点的子树中，i不去的最大开心值。</p>
<p>$dp[i][1]$来表示，以i为根节点的子树中，i去的最大开心值。</p>
<p>可以得出状态转移方程。</p>
<p>设i的某一个子节点为x。</p>
<p>$dp[i][0] += max(dp[x][0],dp[x][1])$。</p>
<p>$dp[i][1] += dp[x][0]$。</p>
<p>最后答案为$max(dp[root][0],dp[root][1])$。</p>
<h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">6060</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],cnt,dp[N][<span class="number">3</span>],h[N],in[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> to, next;</span><br><span class="line">&#125;Map[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">	Map[++cnt].to = v;</span><br><span class="line">	Map[cnt].next = head[u];</span><br><span class="line">	head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">	dp[p][<span class="number">0</span>] = <span class="number">0</span>, dp[p][<span class="number">1</span>] = h[p];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = head[p]; ~i; i = Map[i].next) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = Map[i].to;</span><br><span class="line">		dfs(x);</span><br><span class="line">		dp[p][<span class="number">0</span>] += <span class="built_in">max</span>(dp[x][<span class="number">0</span>], dp[x][<span class="number">1</span>]);</span><br><span class="line">		dp[p][<span class="number">1</span>] += dp[x][<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n) &#123;</span><br><span class="line">		cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(Map, <span class="number">0</span>, <span class="keyword">sizeof</span>(Map));</span><br><span class="line">		<span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">		<span class="built_in">memset</span>(in, <span class="number">0</span>, <span class="keyword">sizeof</span>(in));</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; h[i];</span><br><span class="line">		<span class="keyword">int</span> l, k;</span><br><span class="line">		<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; l &gt;&gt; k &amp;&amp; l || k) &#123;</span><br><span class="line">			build(k, l);</span><br><span class="line">			in[l]++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> root = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!in[i]) &#123;</span><br><span class="line">				root = i;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		dfs(root);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">max</span>(dp[root][<span class="number">1</span>], dp[root][<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title>杭电多校第四场 1004 Deliver the Cake 题解</title>
    <url>/2020/07/31/%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E7%AC%AC%E5%9B%9B%E5%9C%BA-1004-Deliver-the-Cake-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6805" target="_blank" rel="noopener">题目大意</a></h3><p>给你一个n个点m条边的双向图，告诉你起点和终点，以及每个点对左右手的要求，如果是M的话，则既可以左手，又可以右手，但是交换手是需要时间的，求起点到终点的最短距离。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这题比赛的时候毫无思路。</p>
<p>结束的时候直接看的题解。</p>
<p>没做过这种题的真的写的出吗。。</p>
<p>这个拆点的想法也太神奇了吧。</p>
<p>对于M的点，我们可以把i点当做是用左手，i+n当做是用右手。</p>
<p>这样就相当于多加了边。</p>
<p>如果是从不同的手切换来的，边的权值就等于原本路的权值加上换手的权值。</p>
<p>相同的话，就等于原本路的权值。</p>
<p>需要注意，如果起点和终点是M的话，就会出现两个起点和终点。</p>
<p>可以令0和$2n+1$作为真正的起点和终点。</p>
<p>只是需要在原本的基础上，加上0到两个起点，和$2n+1$到两个终点的边即可。</p>
<p>（找了一下午bug。。结果发现是return0在while循环里面。。吐了。。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>, M = <span class="number">2e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">int</span> head[N], vis[N], n, m, s, e, x, cnt;</span><br><span class="line">ll dis[N];</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, val;</span><br><span class="line">&#125;Map[M];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    ll c;</span><br><span class="line">    node(<span class="keyword">int</span> a = <span class="number">0</span>, ll b = <span class="number">0</span>) :v(a), c(b) &#123;&#125;;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> node&amp; a) <span class="keyword">const</span> &#123; <span class="keyword">return</span> c &gt; a.c; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    Map[cnt].to = v, Map[cnt].val = val;</span><br><span class="line">    Map[cnt].next = head[u], head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">    priority_queue&lt;node&gt;q;</span><br><span class="line">    <span class="keyword">if</span> (str[s] == <span class="string">'M'</span>) dis[<span class="number">0</span>] = <span class="number">0</span>,q.push(node(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">else</span> dis[s] = <span class="number">0</span>,q.push(node(s, <span class="number">0</span>));</span><br><span class="line">    node t;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        t = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">int</span> u = t.v;</span><br><span class="line">        <span class="keyword">if</span> (vis[u])    <span class="keyword">continue</span>;</span><br><span class="line">        vis[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = Map[i].next) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = Map[i].to, c = Map[i].val;</span><br><span class="line">            <span class="keyword">if</span> (!vis[v] &amp;&amp; dis[v] &gt; dis[u] + c)</span><br><span class="line">                dis[v] = dis[u] + c, q.push(node(v, dis[v]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (str[e] == <span class="string">'M'</span>)    <span class="keyword">return</span> dis[<span class="number">2</span> * n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> dis[e];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> t; <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; e &gt;&gt; x &gt;&gt; str + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)), cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (str[s] == <span class="string">'M'</span>) &#123;</span><br><span class="line">            build(<span class="number">0</span>, s, <span class="number">0</span>), build(s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            build(<span class="number">0</span>, s + n, <span class="number">0</span>), build(s + n, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (str[e] == <span class="string">'M'</span>) &#123;</span><br><span class="line">            build(e, <span class="number">2</span> * n + <span class="number">1</span>, <span class="number">0</span>), build(<span class="number">2</span> * n + <span class="number">1</span>, e, <span class="number">0</span>);</span><br><span class="line">            build(e + n, <span class="number">2</span> * n + <span class="number">1</span>, <span class="number">0</span>), build(<span class="number">2</span> * n + <span class="number">1</span>, e + n, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> u, v, c;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; c;</span><br><span class="line">            <span class="keyword">if</span> ((str[u] == <span class="string">'L'</span> &amp;&amp; str[v] == <span class="string">'R'</span>) || (str[u] == <span class="string">'R'</span> &amp;&amp; str[v] == <span class="string">'L'</span>))</span><br><span class="line">                build(u, v, c + x), build(v, u, c + x);</span><br><span class="line">            <span class="keyword">if</span> ((str[u] == <span class="string">'L'</span> &amp;&amp; str[v] == <span class="string">'L'</span>) || (str[u] == <span class="string">'R'</span> &amp;&amp; str[v] == <span class="string">'R'</span>))</span><br><span class="line">                build(u, v, c), build(v, u, c);</span><br><span class="line">            <span class="keyword">if</span> (str[u] == <span class="string">'L'</span> &amp;&amp; str[v] == <span class="string">'M'</span>) &#123;</span><br><span class="line">                build(u, v, c), build(u, v + n, c + x);</span><br><span class="line">                build(v, u, c), build(v + n, u, c + x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (str[u] == <span class="string">'M'</span> &amp;&amp; str[v] == <span class="string">'L'</span>) &#123;</span><br><span class="line">                swap(u, v);</span><br><span class="line">                build(u, v, c), build(u, v + n, c + x);</span><br><span class="line">                build(v, u, c), build(v + n, u, c + x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (str[u] == <span class="string">'R'</span> &amp;&amp; str[v] == <span class="string">'M'</span>) &#123;</span><br><span class="line">                build(u, v, c + x), build(u, v + n, c);</span><br><span class="line">                build(v, u, c + x), build(v + n, u, c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (str[u] == <span class="string">'M'</span> &amp;&amp; str[v] == <span class="string">'R'</span>) &#123;</span><br><span class="line">                swap(u, v);</span><br><span class="line">                build(u, v, c + x), build(u, v + n, c);</span><br><span class="line">                build(v, u, c + x), build(v + n, u, c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (str[u] == <span class="string">'M'</span> &amp;&amp; str[v] == <span class="string">'M'</span>) &#123;</span><br><span class="line">                build(u, v, c), build(u, v + n, c + x), build(u + n, v, c + x), build(u + n, v + n, c);</span><br><span class="line">                swap(u, v);</span><br><span class="line">                build(u, v, c), build(u, v + n, c + x), build(u + n, v, c + x), build(u + n, v + n, c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; Dijkstra() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>拆点</tag>
      </tags>
  </entry>
  <entry>
    <title>杭电多校第四场 1012 Last Problem 题解</title>
    <url>/2020/08/01/%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E7%AC%AC%E5%9B%9B%E5%9C%BA-1012-Last-Problem-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6813" target="_blank" rel="noopener">题目大意</a></h3><p>在一个无穷大的画板上，你有n种颜色，编号从1到n，你需要涂第n种颜色，当你涂第i种颜色的时候，他的四周相邻的格子必须有他前面的四种颜色，即n-1到n-4，输出正确的步骤。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>刚开始的时候看到这个题目，就知道应该是构造，然后递归。</p>
<p>结果我倒推了半天没推出来。</p>
<p>首先你需要涂n，就需要这样。</p>
<p><img src="https://ae01.alicdn.com/kf/H6287a38f0b134438904a970bf1a8835fh.jpg" alt=""></p>
<p>为了能涂出n-1到n-4，你就需要这样。</p>
<p><img src="https://ae01.alicdn.com/kf/Hea390a3b93e04d92873c33adf4460167o.jpg" alt=""></p>
<p>你会发现，对于每个灰色的颜色，他们都满足上面的n的颜色分布。</p>
<p>这样，我们就能根据第一张图的颜色分布，构造出正确的涂色的情况了。</p>
<p>只需要dfs出步骤即可。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mp[<span class="number">2020</span>][<span class="number">2020</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (val &lt;= <span class="number">0</span>)	<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (mp[x][y - <span class="number">1</span>] != val - <span class="number">1</span>)	dfs(x, y - <span class="number">1</span>, val - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (mp[x - <span class="number">1</span>][y] != val - <span class="number">2</span>)	dfs(x - <span class="number">1</span>, y, val - <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span> (mp[x + <span class="number">1</span>][y] != val - <span class="number">3</span>)	dfs(x + <span class="number">1</span>, y, val - <span class="number">3</span>);</span><br><span class="line">	<span class="keyword">if</span> (mp[x][y + <span class="number">1</span>] != val - <span class="number">4</span>)	dfs(x, y + <span class="number">1</span>, val - <span class="number">4</span>);</span><br><span class="line">	mp[x][y] = val;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; x &lt;&lt;<span class="string">" "</span>&lt;&lt; y &lt;&lt;<span class="string">" "</span>&lt;&lt; mp[x][y] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="built_in">memset</span>(mp, <span class="number">0</span>, <span class="keyword">sizeof</span>(mp));</span><br><span class="line">	dfs(<span class="number">1000</span>, <span class="number">1000</span>, n);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客课后1.2  糖糖别胡说，我真的不是签到题目 题解</title>
    <url>/2020/10/03/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981.2-%E7%B3%96%E7%B3%96%E5%88%AB%E8%83%A1%E8%AF%B4%EF%BC%8C%E6%88%91%E7%9C%9F%E7%9A%84%E4%B8%8D%E6%98%AF%E7%AD%BE%E5%88%B0%E9%A2%98%E7%9B%AE-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://www.nowcoder.com/study/live/373/1/2" target="_blank" rel="noopener">题目大意</a></h3><p>有n个人，分成两队，排成一条，从小到大选人，选到第i个人的时候，可以杀死他前面所有和他不是同一个队的小于他能力值的人。恰巧有人会发功，在选到第i人之后，会让1~i的人的能力值加一，求最后剩下的人数。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>刚开始想到用暴力二分搜加差分写，虽然知道应该会T，但是还是试着写了一下。</p>
<p>果不其然。。</p>
<p>后面想了好久，真的想不到了，看的题解。</p>
<p>（我太菜了。。</p>
<p>发现有一个很重要的点，就是对于某个点来说，用这个点的能力与在这个点之前发功修改的能力去比和用这两个点在所有发功结束的能力之比，是一样的。</p>
<p>所以就只需要求出所有修改之后的值，从后往前枚举，维护两个组的最小值即可。</p>
<p>不得不说，某些时候，思维题比算法题难多了。</p>
<p>（是真的想不到。。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ty</span> &#123;</span></span><br><span class="line">	ll x, e;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> h[<span class="number">500500</span>], sum[<span class="number">500500</span>];</span><br><span class="line">ty num[<span class="number">500500</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t; <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n, m; <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">		<span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span>(sum));</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			ll a, b; <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">			num[i] = &#123; a,b &#125;;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; h[i];</span><br><span class="line">			sum[<span class="number">1</span>]++, sum[h[i] + <span class="number">1</span>]--;</span><br><span class="line">		&#125;</span><br><span class="line">		ll ans = n, max0, max1;</span><br><span class="line">		max0 = max1 = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			sum[i] += sum[i - <span class="number">1</span>];</span><br><span class="line">			num[i].e += sum[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">			<span class="keyword">if</span> (num[i].x) &#123;</span><br><span class="line">				<span class="keyword">if</span> (num[i].e &lt;= max0) ans--;</span><br><span class="line">				max1 = <span class="built_in">max</span>(max1, num[i].e);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (num[i].e &lt;= max1) ans--;</span><br><span class="line">				max0 = <span class="built_in">max</span>(max0, num[i].e);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客多校第四场 B Basic Gcd Problem 题解</title>
    <url>/2020/07/23/%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1%E7%AC%AC%E5%9B%9B%E5%9C%BA-B-Basic-Gcd-Problem-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://ac.nowcoder.com/acm/contest/5669/B" target="_blank" rel="noopener">题目大意</a></h3><p>定义函数$\large f_c(x) = max(1-&gt;x-1) c·f_c(gcd(i,x)) \quad x &gt; 1$</p>
<p>$\large f_c(x) = 1 \quad x=1$。</p>
<p>求$\large f_c(n)$。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>很明显，答案肯定是$c^n$，所以我们需要使这个n尽可能的大。</p>
<p>由于质数与其他数的gcd都是1，所以我们不需要考虑质数。</p>
<p>那么对于其他的数来说，我们可以将他们分解成质因数相乘，每一个质因数就是相当于乘以一个c。</p>
<p>那么答案就只需要统计其质因数的数量然后用快速幂即可。</p>
<p>（我统计的时候乘就TLE了。。乘这么慢的吗。。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> num[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)    ans = ans*a%mod;</span><br><span class="line">        a = a*a%mod,b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">slove</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i*i &lt;= a; i++) &#123;</span><br><span class="line">		<span class="keyword">while</span> (a % i == <span class="number">0</span>) &#123;</span><br><span class="line">			ans++;</span><br><span class="line">			a /= i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;<span class="number">1</span>)    ans++;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n, c;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; c;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; qpow((ll)c,slove(n)) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>gcd</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客寒假算法基础集训营1C-红和蓝 题解</title>
    <url>/2021/02/14/%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E9%9B%86%E8%AE%AD%E8%90%A51C-%E7%BA%A2%E5%92%8C%E8%93%9D-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://ac.nowcoder.com/acm/contest/9981/C" target="_blank" rel="noopener">题目大意</a></h3><p>你拿到了一棵树，请你给每个顶点染成红色或蓝色。要求每个红点相邻的点有且仅有一个红点，每个蓝点相邻的点有且仅有一个蓝点。   </p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这个题其实做法很暴力，就是看你能不能想到了。</p>
<p>想通了就很简单。</p>
<p>首先dfs一次这棵树。</p>
<p>从叶子节点开始，每个点与他的父节点认定为一组。</p>
<p>如果某个点的父节点是被标记了，那就肯定不行。</p>
<p>标记完之后，再dfs一遍。</p>
<p>如果是一组的就相同的颜色，否则就相反。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for (int i=a;i&lt;=n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,n) for (int i=a;i&gt;=n;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bg begin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rbg rbegin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ed end</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dbg(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">"==="</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">1</span>, cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> head[N], gp[N], ans[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> t, next;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">	edge[++cnt].t = w, edge[cnt].next = head[u];</span><br><span class="line">	head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; ~i; i = edge[i].next) &#123;</span><br><span class="line">		<span class="keyword">int</span> t = edge[i].t;</span><br><span class="line">		<span class="keyword">if</span> (t == fa) <span class="keyword">continue</span>;</span><br><span class="line">		dfs1(t, x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!gp[x]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (gp[fa]) &#123;</span><br><span class="line">			flag = <span class="number">0</span>; <span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		gp[x] = gp[fa] = ++cnt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; ~i; i = edge[i].next) &#123;</span><br><span class="line">		<span class="keyword">int</span> t = edge[i].t;</span><br><span class="line">		<span class="keyword">if</span> (t == fa) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span> (gp[x] == gp[t])	ans[t] = ans[x];</span><br><span class="line">		<span class="keyword">else</span> ans[t] = ans[x] ^ <span class="number">1</span>;</span><br><span class="line">		dfs2(t, x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b, ll mod)</span> </span>&#123;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)	ans = (ans * a) % mod;</span><br><span class="line">		a = (a * a) % mod, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\in.txt", "r", stdin);</span></span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\out.txt", "w+", stdout);</span></span><br><span class="line">	<span class="keyword">int</span> n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">	rep(i, <span class="number">2</span>, n) &#123;</span><br><span class="line">		<span class="keyword">int</span> u, v; <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">		build(u, v), build(v, u);</span><br><span class="line">	&#125;</span><br><span class="line">	gp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	dfs1(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	dfs2(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ans[i])	<span class="built_in">cout</span> &lt;&lt; <span class="string">'R'</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">'B'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客七夕 B 王母娘娘又双叒叕来难为茶山牛了 题解</title>
    <url>/2020/08/26/%E7%89%9B%E5%AE%A2%E4%B8%83%E5%A4%95-B-%E7%8E%8B%E6%AF%8D%E5%A8%98%E5%A8%98%E5%8F%88%E5%8F%8C%E5%8F%92%E5%8F%95%E6%9D%A5%E9%9A%BE%E4%B8%BA%E8%8C%B6%E5%B1%B1%E7%89%9B%E4%BA%86-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://ac.nowcoder.com/acm/contest/7009/B" target="_blank" rel="noopener">题目大意</a></h3><p>给你n和m，求$(n!!!)% m$。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>昨天七夕玩了一天，回家都累死了。</p>
<p>晚上就简单的看了看，wa了几次，就没写了。</p>
<p>后来仔细想了想，发现思路没错，最后忘求阶乘了。</p>
<p>太丢人了。。</p>
<p>首先我们可以把$(n!!)$看做$t$，就变成了$t!% m$。</p>
<p>如果$t\ge m$，那么答案必定是0。</p>
<p>所以我们只需要计算前两次，判断会不会大于等于m，注意，可能会爆ll，所以，还需要考虑溢出为负数的情况。</p>
<p>如果大于等于m，就输出0。</p>
<p>否则，最后计算$(t!)% m$即可。</p>
<p>补充：看了题解之后，才发现这个题目有更简单的方法，$0!!!=1,1!!!=1,2!!!=2,3!!=720,4!!&gt;1e9$，大于3之后就必定是0了，其他情况就自己算即可。</p>
<p>（更丢人了。。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//freopen("D:\\测试用\\in.txt", "r", stdin);</span></span><br><span class="line">    <span class="comment">//freopen("D:\\测试用\\out.txt", "w+", stdout);</span></span><br><span class="line">	<span class="keyword">int</span> t; <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n,m; <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        ll ans = n,g = n;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>%m&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = ans <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(tmp)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ans&lt;<span class="number">0</span>||ans&gt;=m)&#123;</span><br><span class="line">                    flag = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ans*=tmp--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag)    <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)    <span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = ans - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(tmp)&#123;</span><br><span class="line">                ans%=m;</span><br><span class="line">                ans*=tmp--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;ans%m&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客多校第四场 F Finding the Order 题解</title>
    <url>/2020/07/22/%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1%E7%AC%AC%E5%9B%9B%E5%9C%BA-Finding-the-Order-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://ac.nowcoder.com/acm/contest/5669/F" target="_blank" rel="noopener">题目大意</a></h3><p>有两条平行线，上面一根有ab两点，下面一根有cd两点，问是ab//cd，还是ab//dc。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>其实这个题目就是一个签到水题。</p>
<p>题目并不难，就连接四根线，取左右两个三角形。</p>
<p>由两个三角形边长关系之和，可以得出ad+bc&gt;ac+ad。</p>
<p>题目不难，关键是我一下子没想到这个思路。</p>
<p>思维很重要，写这个题解就是需要告诉自己这一点，acm是需要多思考的。</p>
<p>希望自己以后思维更加灵活吧。</p>
<p>至少这种题目是不应该写不出的。</p>
<p>（其实给我乱凑凑出来了。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> a, b, c, d;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line">		<span class="keyword">if</span> (a+d&lt;b+c)	<span class="built_in">cout</span> &lt;&lt; <span class="string">"AB//CD"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"AB//DC"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客寒假算法基础集训营1D-点一成零 题解</title>
    <url>/2021/02/17/%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E9%9B%86%E8%AE%AD%E8%90%A51D-%E7%82%B9%E4%B8%80%E6%88%90%E9%9B%B6-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://ac.nowcoder.com/acm/contest/9981/D" target="_blank" rel="noopener">题目大意</a></h3><p>给你一个01矩阵，每次操作可以点击一个写着1的格子，将这个格子所在的1连通块全部变成0。 </p>
<p>有k次永久修改，将一个格子变成1，求每次修改之后有多少种不同的方案，可以把全部格子的1都变成0？</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>说实话，我都不知道并查集可以这么用。</p>
<p>首先要知道没有修改情况的答案是多少。</p>
<p>对于每个连通块，存在着$x!$种选择情况。</p>
<p>对于每个连通块内部，存在着$size[i]$种选择情况。</p>
<p>所以答案为$x!\times size[i]$。</p>
<p>对于修改之后。</p>
<p>先假设增加了一个连通块，cnt++。</p>
<p>然后遍历这个点的上下左右。</p>
<p>如果周围存在相邻的联通块，直接合并。</p>
<p>合并的时候，$\Large ans = \frac{ans\times (size[a]+size[b])}{cnt\times size[a]\times size[b]}$。</p>
<p>同时需要cnt–，注意使用逆元。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for (int i=a;i&lt;=n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,n) for (int i=a;i&gt;=n;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bg begin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rbg rbegin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ed end</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dbg(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">"==="</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span>, maxn = <span class="number">550</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> father[N], siz[N];</span><br><span class="line"><span class="keyword">char</span> Map[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span> &#125;, dy[] = &#123; <span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b, ll mod)</span> </span>&#123;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)	ans = (ans * a) % mod;</span><br><span class="line">		a = (a * a) % mod, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> father[x] == x ? x : father[x] = <span class="built_in">find</span>(father[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> rt1, <span class="keyword">int</span> rt2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fa1 = <span class="built_in">find</span>(rt1), fa2 = <span class="built_in">find</span>(rt2);</span><br><span class="line">	<span class="keyword">if</span> (fa1 != fa2)	siz[fa1] += siz[fa2], father[fa2] = fa1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\in.txt", "r", stdin);</span></span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\out.txt", "w+", stdout);</span></span><br><span class="line">	ll n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	rep(i, <span class="number">0</span>, (n + <span class="number">1</span>) * (n + <span class="number">1</span>))	father[i] = i, siz[i] = <span class="number">1</span>;</span><br><span class="line">	rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">		rep(j, <span class="number">1</span>, n)	<span class="built_in">cin</span> &gt;&gt; Map[i][j];</span><br><span class="line">	&#125;</span><br><span class="line">	rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">		rep(j, <span class="number">1</span>, n) &#123;</span><br><span class="line">			rep(k, <span class="number">0</span>, <span class="number">3</span>) &#123;</span><br><span class="line">				<span class="keyword">int</span> tx = j + dx[k], ty = i + dy[k];</span><br><span class="line">				<span class="keyword">if</span> (Map[i][j] == <span class="string">'1'</span> &amp;&amp; Map[ty][tx] == <span class="string">'1'</span>)	join(i * n + j, ty * n + tx);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">		rep(j, <span class="number">1</span>, n)	<span class="keyword">if</span> (Map[i][j] == <span class="string">'1'</span> &amp;&amp; father[i * n + j] == i * n + j)	cnt++, ans = (ans * siz[i * n + j]) % mod;</span><br><span class="line">	&#125;</span><br><span class="line">	rep(i, <span class="number">1</span>, cnt)	ans = (ans * i) % mod;</span><br><span class="line">	<span class="keyword">int</span> k; <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">	<span class="keyword">while</span> (k--) &#123;</span><br><span class="line">		<span class="keyword">int</span> x, y; <span class="built_in">cin</span> &gt;&gt; y &gt;&gt; x;</span><br><span class="line">		x++, y++;</span><br><span class="line">		<span class="keyword">if</span> (Map[y][x] == <span class="string">'1'</span>) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Map[y][x] = <span class="string">'1'</span>;</span><br><span class="line">		cnt++;</span><br><span class="line">		ans = (ans * cnt) % mod;</span><br><span class="line">		rep(i, <span class="number">0</span>, <span class="number">3</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> tx = x + dx[i], ty = y + dy[i];</span><br><span class="line">			<span class="keyword">int</span> rt1 = <span class="built_in">find</span>(y * n + x), rt2 = <span class="built_in">find</span>(ty * n + tx);</span><br><span class="line">			<span class="keyword">if</span> (Map[ty][tx] == <span class="string">'1'</span> &amp;&amp; rt1 != rt2) &#123;</span><br><span class="line">				ans = (ans * qpow(cnt, mod - <span class="number">2</span>, mod)) % mod;</span><br><span class="line">				ans = (ans * qpow(siz[rt1], mod - <span class="number">2</span>, mod)) % mod;</span><br><span class="line">				ans = (ans * qpow(siz[rt2], mod - <span class="number">2</span>, mod)) % mod;</span><br><span class="line">				ans = (ans * (siz[rt1] + siz[rt2])) % mod;</span><br><span class="line">				cnt--;</span><br><span class="line">				join(rt1, rt2);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客寒假算法基础集训营1A-串 题解</title>
    <url>/2021/02/04/%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E9%9B%86%E8%AE%AD%E8%90%A51A-%E4%B8%B2-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://ac.nowcoder.com/acm/contest/9981/A" target="_blank" rel="noopener">题目大意</a></h3><p>长度不超过n，且包含子序列“us”的、只由小写字母构成的字符串有多少个？ 答案对$10^9+7$取模。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>刚开始就觉得这题应该就是推个公式。</p>
<p>但是推了半天没推出来。</p>
<p>我们可以对于第i位来讨论。</p>
<p>ans[i]代表长度为i的字符串个数。</p>
<p>假如前面i-1位中存在子序列us，则这一位可以任意填，$ans[i]+=26\times ans[i-1]$。</p>
<p>假如前面i-1位中只有u，不存在s。</p>
<p>这一种情况答案为所有情况-不包含u的情况-既包含u也包含s的情况，$ans[i]+=26^{i-1}-25^{i-1}-ans[i-1]$。</p>
<p>综合起来，答案为$ans[i] = 26^{i-1}-25^{i-1}+25\times ans[i-1]$。</p>
<p>注意，当答案中存在减法时，应该加一个mod防止答案为负！！！</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for (ll i=a;i&lt;=n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,n) for (int i=a;i&gt;=n;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bg begin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rbg rbegin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ed end</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dbg(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">"==="</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>, mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">ll ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b, ll mod)</span> </span>&#123;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)	ans = (ans * a) % mod;</span><br><span class="line">		a = (a * a) % mod, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\in.txt", "r", stdin);</span></span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\out.txt", "w+", stdout);</span></span><br><span class="line">	<span class="keyword">int</span> n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	ans[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">	rep(i, <span class="number">3</span>, n) &#123;</span><br><span class="line">		ll a = qpow(<span class="number">26</span>, i - <span class="number">1</span>, mod) % mod, b = qpow(<span class="number">25</span>, i - <span class="number">1</span>, mod) % mod, c = <span class="number">25</span> * ans[i - <span class="number">1</span>] % mod;</span><br><span class="line">		ans[i] = ((qpow(<span class="number">26</span>, i - <span class="number">1</span>, mod) % mod - qpow(<span class="number">25</span>, i - <span class="number">1</span>, mod) % mod + mod)%mod + <span class="number">25</span> * ans[i - <span class="number">1</span>] % mod) % mod;</span><br><span class="line">	&#125;</span><br><span class="line">	ll sum = <span class="number">0</span>;</span><br><span class="line">	rep(i, <span class="number">2</span>, n)	sum = (sum % mod + ans[i] % mod) % mod;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客寒假算法基础集训营1I-限制不互素对的排列 题解</title>
    <url>/2021/02/04/%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E9%9B%86%E8%AE%AD%E8%90%A51I-%E9%99%90%E5%88%B6%E4%B8%8D%E4%BA%92%E7%B4%A0%E5%AF%B9%E7%9A%84%E6%8E%92%E5%88%97-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://ac.nowcoder.com/acm/contest/9981/I" target="_blank" rel="noopener">题目大意</a></h3><p>输入一个数n，请构造一个长度为n的排列，使得其中正好有k对相邻的数gcd大于1。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>题目难度面向小白，就邪门，我应该还没到小白的水平。</p>
<p>刚开始根本没想到可以用2的倍数来构造。</p>
<p>主要是没想到怎么构造相邻的gcd大于1的数，很明显，2的倍数是最优解。</p>
<p>那么就可以分为两种情况。</p>
<p>一个长度为n的排列中，最多有$\frac{n}{2}$个偶数，即最多有$\frac{n}{2}-1$对。</p>
<p>如果$k\leq \frac{n}{2}-1 $，只需要输出前$k+1$个偶数，然后后面跟着全部输出，最后输出之前漏掉的奇数。</p>
<p>如果$k=\frac{n}{2}$，就需要多出一个对，显然3和6是最优解，所以只需要输出全部的偶数，并且把6放到最后来输出，然后输出3，最后输出之前的奇数。</p>
<p>所以如果当$k=\frac{n}{2}$时，需要满足$n\ge6$。</p>
<p>在上面的构造中用到了两个定理，一个是相邻两个数gcd一定为1，一个是相邻奇数gcd一定为1。</p>
<p>简单的证明一下。</p>
<blockquote>
<p>假设相邻奇数gcd不为1。</p>
<p>假设小的那个奇数为a，大的为a+2。</p>
<p>a可以表示为$p_1\times p_2\times \cdots p_n$，其中p为奇数。</p>
<p>a+2可以表示为$p’_1 \times p’_2 \times \cdots p’_n$，其中p‘为奇数。</p>
<p>设gcd为$p_1$。</p>
<p>那么$(a+2)-a=p_1\times(p_2\times \cdots p_n-p’_2 \times \cdots p’_n)=2$。</p>
<p>显然不成立。</p>
<p>得证。</p>
</blockquote>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for (int i=a;i&lt;=n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,n) for (int i=a;i&gt;=n;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bg begin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rbg rbegin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ed end</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dbg(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">"==="</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b, ll mod)</span> </span>&#123;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)	ans = (ans * a) % mod;</span><br><span class="line">		a = (a * a) % mod, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\in.txt", "r", stdin);</span></span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\out.txt", "w+", stdout);</span></span><br><span class="line">	<span class="keyword">int</span> n, k; <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	<span class="keyword">if</span> (k == n / <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n &lt; <span class="number">6</span>) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i += <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">6</span>) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="number">6</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i += <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">3</span>)  <span class="keyword">continue</span>;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">2</span> * (k + <span class="number">1</span>); i += <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		rep(i, <span class="number">2</span> * (k + <span class="number">1</span>) + <span class="number">1</span>, n)	<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * (k + <span class="number">1</span>); i += <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; i;</span><br><span class="line">			<span class="keyword">if</span> (i + <span class="number">2</span> &gt;= <span class="number">2</span> * (k + <span class="number">1</span>))	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客寒假算法基础集训营1J-一群小青蛙呱蹦呱蹦呱 题解</title>
    <url>/2021/02/06/%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E9%9B%86%E8%AE%AD%E8%90%A51J-%E4%B8%80%E7%BE%A4%E5%B0%8F%E9%9D%92%E8%9B%99%E5%91%B1%E8%B9%A6%E5%91%B1%E8%B9%A6%E5%91%B1-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://ac.nowcoder.com/acm/contest/9981/J" target="_blank" rel="noopener">题目大意</a></h3><p>有n个格子，每个格子里有一个数，1,2,3,4…n   </p>
<p>牛牛放出无穷只青蛙。   </p>
<p>第一只青蛙的路线是：1-&gt;2-&gt;4-&gt;8-&gt;16-&gt;….   </p>
<p>第二只青蛙的路线是：1-&gt;3-&gt;9-&gt;27-&gt;81-&gt;….   </p>
<p>第三只青蛙的路线是：1-&gt;5-&gt;25-&gt;125-&gt;….   </p>
<p>第四只青蛙的路线是：1-&gt;7-&gt;49-&gt;….   </p>
<p>。。。。。。   </p>
<p>用数学语言描述，第i只青蛙的路线是首项为1，公比为$p(i)$的等比数列，其中$p(i)$代表第i个素数。   </p>
<p>当青蛙跳到一个格子上，如果这个格子上面有一个数，青蛙就会把这个数吃掉。  </p>
<p>牛牛想知道，所有没有被吃掉的数的lcm是多少？   </p>
<p>由于这个lcm可能非常大，请输出它对$10^9+7$取模的值。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们需要求所有没有被吃掉的数的lcm。</p>
<p>对于没有被吃掉的数来说，他们的lcm必然是所有数的因子的最大指数相乘。</p>
<p>那么由题目知道，被吃掉的数是小于n的质因子的次方。</p>
<p>如果某个数不被吃掉，那么他至少是两个质因子的乘积。</p>
<p>那么我们只需要求对于某个质因子来说，n以内的最大的次方，最后把乘积输出即可。</p>
<p>对于2来说，他本身就是最小的，所以最大的数是$3*2^k$，k就是最大的次方。</p>
<p>对于其他的质数来说，最大的数就是$2*p^k$。</p>
<p>然后答案就是$p_1^{k_1}\times p_2^{k_2} \times \cdots \times p_n^{k_n}$。</p>
<p>因为不被吃掉的数至少是两个质因数相乘，所以质数筛只要筛到$\frac{n}{2}$就行，不然会超时。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for (int i=a;i&lt;=n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,n) for (int i=a;i&gt;=n;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bg begin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rbg rbegin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ed end</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dbg(x) cout &lt;&lt; #x &lt;&lt; <span class="meta-string">"==="</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e8</span>, N = <span class="number">1e7</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> vis[maxn], prime[N], cnt = <span class="number">0</span>, n;</span><br><span class="line">ll ans = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b, ll mod)</span> </span>&#123;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)	ans = (ans * a) % mod;</span><br><span class="line">		a = (a * a) % mod, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">cal</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	ll k;</span><br><span class="line">	<span class="keyword">if</span> (x == <span class="number">2</span>) k = <span class="built_in">log</span>(n / <span class="number">3</span>) / <span class="built_in">log</span>(<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">else</span> k = <span class="built_in">log</span>(n / <span class="number">2</span>) / <span class="built_in">log</span>(x);</span><br><span class="line">	<span class="keyword">return</span> qpow(x, k, mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	rep(i, <span class="number">2</span>, n/<span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">			prime[cnt++] = i;</span><br><span class="line">			ans = (ans % mod * cal(i) % mod) % mod;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt &amp;&amp; i * prime[j] &lt;= n; j++) &#123;</span><br><span class="line">			vis[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>)	<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\in.txt", "r", stdin);</span></span><br><span class="line">	<span class="comment">//freopen("D:\\测试用\\out.txt", "w+", stdout);</span></span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	init();</span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">6</span>) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"empty"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>质数筛</tag>
      </tags>
  </entry>
  <entry>
    <title>福州大学第十七届程序设计大赛 1009 排列小球 题解</title>
    <url>/2020/08/27/%E7%A6%8F%E5%B7%9E%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E4%B8%83%E5%B1%8A%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B-1009-%E6%8E%92%E5%88%97%E5%B0%8F%E7%90%83-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.fzu.edu.cn/problem.php?pid=2318" target="_blank" rel="noopener">题目大意</a></h3><p>有三种颜色的球各n个，排成一行，求所有相邻小球颜色各不相同的排列方式种类。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>首先用第二种小球将第一种小球分为k段，相当于在$n-1$个位置中，插入$k-1$个挡板。</p>
<p>分法为$\Large C_{n-1}^{k-1}$。</p>
<p>在将第一种分类的同时，第二种小球也会分成$k-1$段（第一个和最后一个都是第一种小球）,$k$（第一个和最后一个小球，一个是第一种，一个是第二种）,$k+1$（第一个和最后一个都是第二种）。</p>
<p>设第二种小球被分成t段，由第一种小球的分法知，答案为$\Large C_{n-1}^{t-1}$。</p>
<p>对于前面两种小球的分法，当t为$k-1$的时候，答案为$\Large C_{n-1}^{k-1}\times \Large C_{n-1}^{t-1}$，当t为$k$的时候，第一种和第二种的分配存在两种可能，答案为$\Large 2\times C_{n-1}^{k-1}\times \Large C_{n-1}^{t-1}$，同理，当t为$k+1$的时候，答案为$\Large C_{n-1}^{k-1}\times \Large C_{n-1}^{t-1}$，总结答案为$\Large(1+(t==k))\times  C_{n-1}^{k-1}\times \Large C_{n-1}^{t-1}$。</p>
<p>把第一种小球和第二种小球混在一起，存在相邻颜色不同的位置，也存在相邻颜色相同的位置，两种小球被分为$t+k$段，颜色不同的位置为$t+k-1$个，加上第一个和最后一个位置，颜色不同的位置就是$t+k+1$个，总共$2n$个小球，有$2n+1$个位置，那么就有剩下$2n+1-t-k-1=2n-t-k$个位置是必须要填入第三种颜色的小球的，</p>
<p>那么剩下的$n-2n+t+k=t+k-n$个小球就可以任意填入颜色不同的位置，答案为$\Large C_{t+k+1}^{t+k-n}=C_{t+k+1}^{(t+k+1)-(t+k-n)}=C_{t+k+1}^{n+1}$。</p>
<p>所以答案为$\Large(1+(t==k))\times  C_{n-1}^{k-1}\times \Large C_{n-1}^{t-1}\times C_{t+k+1}^{n+1}$。</p>
<p>枚举k从1~n，t从$k-1$到$k+1$，注意预处理阶乘和逆元。</p>
<p>排列数$\Large C_n^m=\frac{n!}{m!(n-m)!}$。</p>
<p>本来是还应该乘上不同的颜色排列$\Large A_3^3$的，但是可以理解为3n个球分成n，n，n三组，存在重复情况，需要除上$\Large 3!=A_3^3$，相当于约掉了。</p>
<p>（这种题太考数学了。。欺负我数学渣。。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;unordered_map&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e6</span>+<span class="number">5</span>,maxn = <span class="number">3e6</span>+<span class="number">10</span>, mod = <span class="number">998244353</span>;</span><br><span class="line">ll frac[maxn], inv[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">c</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a &gt; b || a &lt; <span class="number">0</span>)	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> frac[b] * inv[b - a] % mod * inv[a] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)	ans = (ans * a) % mod;</span><br><span class="line">		a = (a * a) % mod, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	frac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) frac[i] = (i * frac[i - <span class="number">1</span>]) % mod;</span><br><span class="line">	inv[N] = qpow(frac[N], mod - <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = N; i &gt;= <span class="number">1</span>; i--)	inv[i - <span class="number">1</span>] = (i * inv[i]) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//freopen("D:\\测试用\\in.txt", "r", stdin);</span></span><br><span class="line">    <span class="comment">//freopen("D:\\测试用\\out.txt", "w+", stdout);</span></span><br><span class="line">	init();</span><br><span class="line">	ll n;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n) &#123;</span><br><span class="line">		ll ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (ll j = i - <span class="number">1</span>; j &lt;= i + <span class="number">1</span>; j++) &#123;</span><br><span class="line">				ans = (ans + (<span class="number">1</span> + (i == j)) * c(i - <span class="number">1</span>, n - <span class="number">1</span>) % mod * c(j - <span class="number">1</span>, n - <span class="number">1</span>) % mod * c(n + <span class="number">1</span>, i + j + <span class="number">1</span>)) % mod;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>排列组合</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客课后1.4 数学考试 题解</title>
    <url>/2020/10/25/%E7%89%9B%E5%AE%A2%E8%AF%BE%E5%90%8E1.4-%E6%95%B0%E5%AD%A6%E8%80%83%E8%AF%95-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://www.nowcoder.com/study/live/373/1/4" target="_blank" rel="noopener">题目大意</a></h3><p>给你n个数，求两个不重合且长度为k的两个区间的最大和。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>首先肯定需要用前缀和，然后直接暴力一发，T了。</p>
<p>后面想可以用一个前缀数组来表示前i的最大和，一个后缀数组表示i后最大和，结果wa了。</p>
<p>看了题解，发现只需要定一个就行了，另外一个表示这个区间之前满足要求的最大区间和。</p>
<p>注意答案初始化为-1e18。</p>
<p>（wa了一发，气死了。。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">ll num[N], sum[N], ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t; <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n, k; <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)	<span class="built_in">cin</span> &gt;&gt; num[i];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			sum[i] = sum[i - <span class="number">1</span>] + num[i];</span><br><span class="line">		&#125;</span><br><span class="line">		ll ans = <span class="number">-1e9</span>, pre = <span class="number">-1e9</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> l = k + <span class="number">1</span>;l + k - <span class="number">1</span> &lt;= n; l++) &#123;</span><br><span class="line">			pre = <span class="built_in">max</span>(pre, sum[l - <span class="number">1</span>] - sum[l - k - <span class="number">1</span>]);</span><br><span class="line">			ans = <span class="built_in">max</span>(ans, pre + sum[l + k - <span class="number">1</span>] - sum[l - <span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>第十七届“科大讯飞杯” D 车辆调度 题解</title>
    <url>/2020/07/08/%E7%AC%AC%E5%8D%81%E4%B8%83%E5%B1%8A%E2%80%9C%E7%A7%91%E5%A4%A7%E8%AE%AF%E9%A3%9E%E6%9D%AF%E2%80%9D-D-%E8%BD%A6%E8%BE%86%E8%B0%83%E5%BA%A6-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://ac.nowcoder.com/acm/contest/5477/D" target="_blank" rel="noopener">题目大意</a></h3><p>张老师设计了一个智能调度系统来控制他的遥控车队，今天，他带着他的车队来到黄渡理工大学的一块空地上测试这个系统。<br> 这块空地可以描述为一个 w * h 大小的长方形，广场上有一些障碍物，几个目标点，当然，还有张老师的车队。<br> 每分钟，调度系统会智能地向其中的一辆遥控车发送以下指令的其中一条： </p>
<ol>
<li><p>​    向北走，直到撞到空地的边界、障碍物或其他遥控车；   </p>
</li>
<li><p>​    向南走，直到撞到空地的边界、障碍物或其他遥控车；   </p>
</li>
<li><p>​    向西走，直到撞到空地的边界、障碍物或其他遥控车；   </p>
</li>
<li><p>​    向东走，直到撞到空地的边界、障碍物或其他遥控车；   </p>
<p>​    每条指令都会在一分钟之内完成，也就是说，空地上最多只有一辆遥控车在运动。此外，当遥控车无法向相应的方向移动时，它会停在原地。   </p>
<p>你想知道，在第 k 分钟时，有没有可能有任意一辆遥控车处在任意一个目标点上。</p>
</li>
</ol>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>很明显的搜索，模拟这个车的行动。</p>
<p>（但是。。我真的不是很会搜索。。</p>
<p>其实想到了DFS但是没想到怎么去模拟，卡了半天。</p>
<p>（还是需要再去学一下。。刚开始学的时候可能没学懂。</p>
<p>其实BFS也是可以的。。不想写了</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> Map[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> n, m, k, flag;</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">5</span>] = &#123; <span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span> &#125;, dy[<span class="number">5</span>] = &#123; <span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; <span class="number">1</span> || x &gt; n || y &lt; <span class="number">1</span> || y &gt; m || Map[y][x] == <span class="string">'X'</span> || Map[y][x] == <span class="string">'R'</span>)	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (t &gt;= k)	<span class="keyword">return</span>;<span class="comment">//搜索步数，这点永远想不到。。</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (Map[i][j] == <span class="string">'R'</span>) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> g = <span class="number">0</span>; g &lt; <span class="number">4</span>; g++) &#123;</span><br><span class="line">					<span class="keyword">int</span> x = j, y = i;</span><br><span class="line">					<span class="keyword">while</span> (check(x + dx[g], y + dy[g]))	x += dx[g], y += dy[g];</span><br><span class="line">					<span class="keyword">if</span> (Map[y][x] == <span class="string">'D'</span>)	flag = <span class="number">1</span>;</span><br><span class="line">					<span class="keyword">if</span> (flag)	<span class="keyword">return</span>;</span><br><span class="line">					swap(Map[i][j], Map[y][x]);</span><br><span class="line">					dfs(t + <span class="number">1</span>);</span><br><span class="line">					swap(Map[i][j], Map[y][x]);<span class="comment">//注意还原，也经常想不到</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; Map[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	flag = <span class="number">0</span>;</span><br><span class="line">	dfs(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (flag)	<span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>福州大学第十七届程序设计大赛 1003 棋盘 题解</title>
    <url>/2020/08/26/%E7%A6%8F%E5%B7%9E%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E4%B8%83%E5%B1%8A%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B-1003-%E6%A3%8B%E7%9B%98-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="http://acm.fzu.edu.cn/problem.php?pid=2319" target="_blank" rel="noopener">题目大意</a></h3><p>给你$n\times m $的棋盘，现在任意挖走两个位置，剩下的需要你用$1\times 2$或者$2\times 1$的方块填满，求满足这个条件的挖法有多少种。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们假设是这样一个棋盘。</p>
<p><img src="https://ae01.alicdn.com/kf/Had79c51b65d84fd98d28d04059bc7a428.jpg" alt=""></p>
<p>总共是有$n\times m$个格子。</p>
<p>假如$n\times m$为奇数，则所有情况都不可能实现，因为你每次都会需要填两个，而剩下的是奇数个。</p>
<p>如果$n\times m$为偶数，则答案为黑块选择情况乘上白块选择情况，即$\Large \frac{(n\times m)}{2}\times \frac {(n\times m)}{2}$。</p>
<p>因为黑块和白块的数量是相同的，所以只能选择一个黑块一个白块。</p>
<p>我们把这两个任意选择的黑块和白块当做一个矩形的对角。</p>
<p>很显然，除了这个矩形之外的地方是可以填满的。</p>
<p>那么对这个矩形进行分析，易知，这个矩形的边长一定是一个奇数，一个偶数，减去两个之后，会变成一个偶数，一个奇数。</p>
<p>可以将偶数的边填满，这样中间就只剩下一个边长减了2的矩形了，很明显，这个矩形是一定能被填满的。</p>
<p>所以答案为$\Large \frac{(n\times m)}{2}\times \frac {(n\times m)}{2}$。</p>
<p>需要注意只有一行（列）的情况，枚举所有的黑块，答案为黑块右边的白块数量。</p>
<p>（福州大学的这个OJ是真的菜，跑的时间巨长，且不支持万能头，连unordered_map都不能用。。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">char</span> Map[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((n * m) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">1</span> || m == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> t = <span class="built_in">max</span>(n, m);</span><br><span class="line">			<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i+=<span class="number">2</span>)	ans += (t - i + <span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; (n * m / <span class="number">2</span>) * (n * m / <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥模拟2第八题题解</title>
    <url>/2020/07/08/%E8%93%9D%E6%A1%A5%E6%A8%A1%E6%8B%9F2%E7%AC%AC%E5%85%AB%E9%A2%98%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​         如果一个序列的奇数项都比前一项大，偶数项都比前一项小，则称为一个摆动序列。即 a[2i]&lt;a[2i-1], a[2i+1]&gt;a[2i]。<br>　　小明想知道，长度为 m，每个数都是 1 到 n 之间的正整数的摆动序列一共有多少个。</p>
<a id="more"></a>

<p>输入格式</p>
<p>　　输入一行包含两个整数 m，n。</p>
<p>输出格式</p>
<p>　　输出一个整数，表示答案。答案可能很大，请输出答案除以10000的余数。</p>
<p>样例输入</p>
<p>3 4</p>
<p>样例输出</p>
<p>14</p>
<p>样例说明</p>
<p>　　以下是符合要求的摆动序列：<br>　　2 1 2<br>　　2 1 3<br>　　2 1 4<br>　　3 1 2<br>　　3 1 3<br>　　3 1 4<br>　　3 2 3<br>　　3 2 4<br>　　4 1 2<br>　　4 1 3<br>　　4 1 4<br>　　4 2 3<br>　　4 2 4<br>　　4 3 4</p>
<p>评测用例规模与约定</p>
<p>　　对于 20% 的评测用例，1 &lt;= n, m &lt;= 5；<br>　　对于 50% 的评测用例，1 &lt;= n, m &lt;= 10；<br>　　对于 80% 的评测用例，1 &lt;= n, m &lt;= 100；<br>　　对于所有评测用例，1 &lt;= n, m &lt;= 1000。</p>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>就是一串数列，要求偶数项要小于前面那项的值，奇数项要大于前面那项的值，长度为m，数字为1~n。求这串数列的最多组成方案。</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>因为奇数项和偶数项的要求不同，所以需要分开来考虑。</p>
<p>奇数项的方案数等于前面一项的所有小于该项值的方案数之和。</p>
<p>偶数项的方案数等于前面一项的所有大于该项值的方案数之和。</p>
<p>于是可以得出定义:<br>dp[i] [j] (i为奇数)等于第i项大于等于j的方案数。</p>
<p>dp[i] [j] (i为偶数)等于第i项小于等于j的方案数。</p>
<p>所以状态转移方程为:</p>
<blockquote>
<p>1、dp[i] [j] = dp[i - 1] [j + 1] + dp[i] [j - 1];</p>
<p>2、dp[i] [j] = dp[i - 1] [j - 1] + dp[i] [j + 1];</p>
</blockquote>
<p>初始化为dp[1] [j] =n - j +1;</p>
<p>如果m为奇数的话，答案为dp[i] [1];</p>
<p>m为偶数的话，答案为dp[i] [n];</p>
<p>(哎。。DP是真的难。。主要是特别难想</p>
<p>基本DP题都能杀我，还是不会DP。</p>
<p>需要多去学习啊。。</p>
<p>别问，问就是题量不够。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		dp[<span class="number">1</span>][i] = n - i + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;<span class="comment">//这里推荐用i&amp;1来判断，比取余要更快</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">				dp[i][j] = (dp[i - <span class="number">1</span>][j + <span class="number">1</span>] + dp[i][j - <span class="number">1</span>]) % <span class="number">10000</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">				dp[i][j] = (dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i][j + <span class="number">1</span>]) % <span class="number">10000</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (m % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; dp[m][n];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; dp[m][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
        <category>蓝桥</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>约瑟夫环问题</title>
    <url>/2020/07/08/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>约瑟夫环问题都很熟悉了，这里也就不多赘述了。</p>
<p>主要是来记录一下，约瑟夫环的一些解法。</p>
<a id="more"></a>

<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>这里我就不详细写推理的过程了。。（其实我也不会。。</p>
<p>网上应该一搜一大片。</p>
<p>1、迭代</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cir</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		p=(p+m)%i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、公式</p>
<p>我不知道这个公式是哪个鬼才想出来的。。</p>
<p>我在网上都没有找到。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">S</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n&amp;<span class="number">1</span>)	<span class="keyword">return</span> S((n<span class="number">-1</span>)/<span class="number">2</span>)*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>	<span class="keyword">return</span> S(n/<span class="number">2</span>)*<span class="number">2</span><span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用这个可以过掉1e9的题。。</p>
<p>上面那个会TLE。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>约瑟夫环</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥模拟2第十题题解</title>
    <url>/2020/07/08/%E8%93%9D%E6%A1%A5%E6%A8%A1%E6%8B%9F2%E7%AC%AC%E5%8D%81%E9%A2%98%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​        2015年，全中国实现了户户通电。作为一名电力建设者，小明正在帮助一带一路上的国家通电。<br>　　这一次，小明要帮助 n 个村庄通电，其中 1 号村庄正好可以建立一个发电站，所发的电足够所有村庄使用。<br>　　现在，这 n 个村庄之间都没有电线相连，小明主要要做的是架设电线连接这些村庄，使得所有村庄都直接或间接的与发电站相通。<br>　　小明测量了所有村庄的位置（坐标）和高度，如果要连接两个村庄，小明需要花费两个村庄之间的坐标距离加上高度差的平方，形式化描述为坐标为 $(x_1, y_1)$ 高度为$ h_1$ 的村庄与坐标为 $(x_2, y_2)$ 高度为 $h_2$ 的村庄之间连接的费用为<br>　　$sqrt((x_1-x_2)* (x_1-x_2)+(y_1-y_2)* (y_1-y_2))+(h_1-h_2)*(h_1-h_2)$。<br>　　在上式中 sqrt 表示取括号内的平方根。请注意括号的位置，高度的计算方式与横纵坐标的计算方式不同。<br>　　由于经费有限，请帮助小明计算他至少要花费多少费用才能使这 n 个村庄都通电。</p>
<a id="more"></a>

<p>输入格式</p>
<p>　　输入的第一行包含一个整数 n ，表示村庄的数量。<br>　　接下来 n 行，每个三个整数 x, y, h，分别表示一个村庄的横、纵坐标和高度，其中第一个村庄可以建立发电站。</p>
<p>输出格式</p>
<p>　　输出一行，包含一个实数，四舍五入保留 2 位小数，表示答案。</p>
<p>样例输入</p>
<p>4<br>1 1 3<br>9 9 7<br>8 8 6<br>4 5 4</p>
<p>样例输出</p>
<p>17.41</p>
<p>评测用例规模与约定</p>
<p>　　对于 30% 的评测用例，1 &lt;= n &lt;= 10；<br>　　对于 60% 的评测用例，1 &lt;= n &lt;= 100；<br>　　对于所有评测用例，1 &lt;= n &lt;= 1000，0 &lt;= x, y, h &lt;= 10000。</p>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>求以1节点为起点，连接其他节点的最短距离。就是求出以1为起点的最小生成树。</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>可以用Kruskal算法和Prim算法。</p>
<p>(还好今年没报蓝桥，啥也不会。。。去了就是送钱了</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p>1、Prim算法(写起来比较简单)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">int</span> y;</span><br><span class="line">	<span class="keyword">int</span> h;</span><br><span class="line">&#125;a[<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">double</span> d[<span class="number">1010</span>][<span class="number">1010</span>], dis[<span class="number">1010</span>], ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n, mark[<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;<span class="comment">//求出当前的最短距离的节点</span></span><br><span class="line">			<span class="keyword">if</span> (!mark[j] &amp;&amp; (t == <span class="number">0</span> || dis[j] &lt; dis[t])) </span><br><span class="line">				t = j;</span><br><span class="line">		&#125;</span><br><span class="line">		mark[t] = <span class="number">1</span>;</span><br><span class="line">		ans += dis[t];<span class="comment">//更新答案</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(!mark[j])</span><br><span class="line">			dis[j] = <span class="built_in">min</span>(dis[j], d[t][j]);<span class="comment">//更新距离</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">			d[i][j] = INF;</span><br><span class="line">		dis[i] = INF;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a[i].x &gt;&gt; a[i].y &gt;&gt; a[i].h;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">			d[i][j] = d[j][i] = <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(a[i].x - a[j].x, <span class="number">2</span>) + <span class="built_in">pow</span>(a[i].y - a[j].y, <span class="number">2</span>)) + <span class="built_in">pow</span>(a[i].h - a[j].h, <span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	prim();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、Kruskal(并查集)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e9</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">int</span> y;</span><br><span class="line">	<span class="keyword">int</span> h;</span><br><span class="line">&#125;a[<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">int</span> y;</span><br><span class="line">	<span class="keyword">double</span> d;</span><br><span class="line">&#125;D;</span><br><span class="line"><span class="keyword">double</span>  ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n, f[<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(D a, D b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.d &lt; b.d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> son = root, t;</span><br><span class="line">	<span class="keyword">while</span> (root != f[root])	root = f[root];</span><br><span class="line">	<span class="keyword">while</span> (son != root) &#123;</span><br><span class="line">		t = f[son];</span><br><span class="line">		f[son] = root;</span><br><span class="line">		son = t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> node1, <span class="keyword">int</span> node2, <span class="keyword">double</span> num)</span> </span>&#123;</span><br><span class="line">	node1 = search(node1);</span><br><span class="line">	node2 = search(node2);</span><br><span class="line">	<span class="keyword">if</span> (node1 != node2) &#123;<span class="comment">//如果不成环就加上这条边</span></span><br><span class="line">		f[node1] = node2;</span><br><span class="line">		ans += num;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	D d[<span class="number">1010</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) 	f[i] = i;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a[i].x &gt;&gt; a[i].y &gt;&gt; a[i].h;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">			d[cnt].d = <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(a[i].x - a[j].x, <span class="number">2</span>) + <span class="built_in">pow</span>(a[i].y - a[j].y, <span class="number">2</span>)) + <span class="built_in">pow</span>(a[i].h - a[j].h, <span class="number">2</span>);</span><br><span class="line">			d[cnt].x = i;</span><br><span class="line">			d[cnt++].y = j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(d, d + cnt, cmp);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) join(d[i].x, d[i].y, d[i].d);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
        <category>蓝桥</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>计蒜客-A2227 轻重搭配 题解</title>
    <url>/2020/10/02/%E8%AE%A1%E8%92%9C%E5%AE%A2-A2227-%E8%BD%BB%E9%87%8D%E6%90%AD%E9%85%8D-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://nanti.jisuanke.com/t/A2227" target="_blank" rel="noopener">题目大意</a></h3><p>总共有n个人去参观，每个人需要一张门票，但是体重为x的人可以和体重大于等于2x的人共用一张门票，求最小的门票数量。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>为啥我的贪心就是不会啊。。。</p>
<p>哭了。</p>
<p>本来的我想的思路是，如果能匹配，那就选尽量小的，也就是恰好的。</p>
<p>但是这个思路不好写，而且应该会T。</p>
<p>正解应该是按体重从小到大排序后用双指针，一个从$\Large \frac {n}{2}$开始，一个从$n$开始。</p>
<p>因为他们最多匹配$\Large \frac {n}{2}$对，所以只需要从$\Large \frac {n}{2}$开始。</p>
<p>满足条件就双指针向前移动，否则只有第一个指针移动。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> flag[N],cnt[N],num[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; num[i];</span><br><span class="line">	&#125;</span><br><span class="line">	sort(num + <span class="number">1</span>, num + <span class="number">1</span> + n);</span><br><span class="line">	<span class="keyword">int</span> ans = n;</span><br><span class="line">	<span class="keyword">int</span> l = n / <span class="number">2</span>, r = n;</span><br><span class="line">	<span class="keyword">while</span> (l) &#123;</span><br><span class="line">		<span class="keyword">if</span> (num[l] * <span class="number">2</span> &gt; num[r])	l--;</span><br><span class="line">		<span class="keyword">else</span> ans--, l--, r--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>西邮第五届ACM-ICPC B 烦人的依赖 题解</title>
    <url>/2020/07/08/%E8%A5%BF%E9%82%AE%E7%AC%AC%E4%BA%94%E5%B1%8AACM-ICPC-B-%E7%83%A6%E4%BA%BA%E7%9A%84%E4%BE%9D%E8%B5%96-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://ac.nowcoder.com/acm/contest/5678/B" target="_blank" rel="noopener">题目大意</a></h3><p>给你n个字符串，给你其中m个的优先关系，需要先输出字典序小的字符串，问你能否成立，能的话输出序列。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>由于需要按照字典序的顺序来输出，所以需要使用优先队列（小顶堆）。</p>
<p>告诉了我们每对的优先关系，可以构造出一个图，用拓扑排序来判断是否有环来判断是否成立。</p>
<p>字符串与位置的对应关系需要使用unorder_map，map会超时。。</p>
<p>用一个vector来记录路径。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;M;</span><br><span class="line">priority_queue&lt;<span class="built_in">string</span>,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;,greater&lt;<span class="built_in">string</span>&gt;&gt; q;</span><br><span class="line"><span class="built_in">string</span> ss[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;Map[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; p;</span><br><span class="line"><span class="keyword">int</span> in[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t,c = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n, m;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">		<span class="built_in">string</span> s1,s2;</span><br><span class="line">		<span class="built_in">memset</span>(in, <span class="number">0</span>, <span class="keyword">sizeof</span>(in));</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			Map[i].<span class="built_in">clear</span>();</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; ss[i];</span><br><span class="line">		&#125;</span><br><span class="line">		sort(ss + <span class="number">1</span>, ss + <span class="number">1</span> + n);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			M[ss[i]] = i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">			<span class="keyword">int</span> n1 = M[s1], n2 = M[s2];</span><br><span class="line">			Map[n1].push_back(n2);</span><br><span class="line">			in[n2]++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!in[M[ss[i]]])	q.push(ss[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> f = M[q.top()];</span><br><span class="line">			p.push_back(ss[f]);</span><br><span class="line">			q.pop();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> x = Map[f].<span class="built_in">begin</span>(); x != Map[f].<span class="built_in">end</span>(); x++) &#123;</span><br><span class="line">				in[*x]--;</span><br><span class="line">				<span class="keyword">if</span>(!in[*x])	q.push(ss[*x]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; c++ &lt;&lt; <span class="string">":"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">if</span> (p.<span class="built_in">size</span>() == n) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> x : p)<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Impossible"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		p.<span class="built_in">clear</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title>计蒜客-A1633 程序设计：蒜头君的数轴 题解</title>
    <url>/2020/10/21/%E8%AE%A1%E8%92%9C%E5%AE%A2-A1633-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%9A%E8%92%9C%E5%A4%B4%E5%90%9B%E7%9A%84%E6%95%B0%E8%BD%B4-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a><a href="https://nanti.jisuanke.com/t/A1633" target="_blank" rel="noopener">题目大意</a></h3><p>一个数轴上有n个点，需要满足相邻两点的距离只能有一个不同，如果不满足，可以加点，使满足要求，求最小加点的数量。</p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这题好难想啊。。</p>
<p>首先需要想到n个距离相等，必然是他们累计gcd的倍数。</p>
<p>那么只需要枚举不需要的那一条边即可。</p>
<p>于是就可以用gcd前缀和gcd后缀来简便运算。</p>
<p>推导公式，所需要加点的个数为$(l/gcd)-n+2$。</p>
<p>区间中的点数为$l/gcd-1$，区间中已有的点为n-3，所以公式为$(l/gcd)-n+2$。</p>
<p>之后特判一下起点和终点即可。</p>
<p>注意当$n\leq 2$时，直接输出0，不然会除以0。。（蓝桥的数据还是太水了。。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> pos[N], dis[N], pre1[N], pre2[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)	<span class="built_in">cin</span> &gt;&gt; pos[i];</span><br><span class="line">	sort(pos + <span class="number">1</span>, pos + <span class="number">1</span> + n);</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)	dis[i] = pos[i+<span class="number">1</span>] - pos[i], sum += dis[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++)	pre1[i] = gcd(pre1[i - <span class="number">1</span>], dis[i]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)	pre2[i] = gcd(pre2[i + <span class="number">1</span>], dis[i]);</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">2e9</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> l = sum - dis[i];</span><br><span class="line">		<span class="keyword">int</span> t;</span><br><span class="line">		<span class="keyword">if</span> (i == <span class="number">1</span>)	t = (l / pre2[<span class="number">2</span>]) - n + <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (i == n - <span class="number">1</span>) t = (l / pre1[n - <span class="number">2</span>]) - n + <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">else</span> t = (l / gcd(pre1[i - <span class="number">1</span>], pre2[i + <span class="number">1</span>])) - n + <span class="number">2</span>;</span><br><span class="line">		ans = <span class="built_in">min</span>(ans, t);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>前缀</tag>
        <tag>后缀</tag>
        <tag>gcd</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树</title>
    <url>/2020/07/08/%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    <content><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>1、线段树是一棵二叉搜索树，它储存的是一个区间的信息。</p>
<p>2、每个节点以结构体的方式存储，结构体包含以下几个信息：</p>
<p>   区间左端点、右端点；（这两者必有）</p>
<p>   这个区间要维护的信息（事实际情况而定，数目不等）。</p>
<p>3、线段树的基本思想：<strong>二分</strong>。</p>
<p>4、线段树一般结构如图所示：</p>
<p><img src="https://ae01.alicdn.com/kf/H81ea5477dc55444399dd94d0e43f00633.jpg" alt=""></p>
<p>5、特殊性质：</p>
<p>由上图可得，</p>
<p>1、每个节点的左孩子区间范围为$[l,mid]$，右孩子为$[mid+1,r]$。</p>
<p>2、对于结点k，左孩子结点为$2\times k$，右孩子为$2\times k+1$，这符合完全二叉树的性质。</p>
<a id="more"></a>

<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>要实现线段树，首先需要构造一颗树。</p>
<p>这里以结构体为例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> l;<span class="comment">//该节点的左边界</span></span><br><span class="line">    <span class="keyword">int</span> r;<span class="comment">//该节点的右边界</span></span><br><span class="line">    <span class="keyword">int</span> sum;<span class="comment">//该节点的值</span></span><br><span class="line">    <span class="keyword">int</span> lz;<span class="comment">//之后说的lazytage</span></span><br><span class="line">&#125;tree[N&lt;&lt;<span class="number">2</span>];<span class="comment">//N为最大节点数量，需要开四倍大小。</span></span><br></pre></td></tr></table></figure>

<h4 id="1、建树"><a href="#1、建树" class="headerlink" title="1、建树"></a>1、建树</h4><p>我们可以用递归的方式来建树。</p>
<p>给每个节点记录他的左边界和右边界。</p>
<p>然后递归左子树和右子树。</p>
<p>如果该节点左右边界相等，则说明是子节点，赋值后结束递归。</p>
<p>建树之后记得更新自身的值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> i=<span class="number">1</span>,<span class="keyword">int</span> l=<span class="number">1</span>,<span class="keyword">int</span> r=n)</span> </span>&#123;</span><br><span class="line">	tree[i].l = l, tree[i].r = r;</span><br><span class="line">	<span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">		tree[i].sum = num[l];</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	build(i &lt;&lt; <span class="number">1</span>, l, mid);<span class="comment">//建左子树</span></span><br><span class="line">	build(i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);<span class="comment">//建右子树</span></span><br><span class="line">	tree[i].sum = tree[i &lt;&lt; <span class="number">1</span>].sum + tree[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、区间修改"><a href="#2、区间修改" class="headerlink" title="2、区间修改"></a>2、区间修改</h4><p>为了实现区间修改的功能，我们需要引入一个叫做“lazytage”的东西，就是懒标记。</p>
<p>正如他的名字所说，最大的特点就是懒，只有需要用到他的时候才需要他。</p>
<p>当需要他的时候，就需要一个操作，“pushdown”。</p>
<p>其实意思很好理解，就是将该节点的标记进行下传。</p>
<p>他的左子树和右子树加上该节点的懒标记，同时更新左右子树的值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (tree[i].lz != <span class="number">0</span>) &#123;</span><br><span class="line">		tree[i &lt;&lt; <span class="number">1</span>].lz += tree[i].lz;<span class="comment">//标记下传</span></span><br><span class="line">		tree[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].lz += tree[i].lz;</span><br><span class="line">		<span class="keyword">int</span> mid = (tree[i].l + tree[i].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		tree[i &lt;&lt; <span class="number">1</span>].sum += tree[i].lz * (mid - tree[i].l + <span class="number">1</span>);<span class="comment">//标记乘上区间长度</span></span><br><span class="line">		tree[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum += tree[i].lz * (tree[i].r - mid);</span><br><span class="line">		tree[i].lz = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在修改的时候，如果某一个节点的区间完全被包含在需要修改的区间中，我们只需要修改这个节点的值，也就是加上标记乘以区间长度的值，并且给他的标记数量加上$k$。</p>
<p>如果不是完全包含在其中的，也就意味我们需要继续的搜索，也意味着我们需要用到这个节点的子节点。</p>
<p>还记得懒标记的定义吗——“只有需要用到他的时候才需要他”。</p>
<p>所以我们需要将懒标记下传。</p>
<p>（这里很重要，我搞懂这里想了好久。。</p>
<p>如果不下传的话，就会导致查询到的值不真实。</p>
<p>如果左子树与这个区间有交集，就搜索左子树。</p>
<p>如果右子树与这个区间有交集，就搜索右子树。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (tree[i].l &gt;= l &amp;&amp; tree[i].r &lt;= r) &#123;<span class="comment">//如果完全被包含，就直接修改</span></span><br><span class="line">		tree[i].sum += k * (tree[i].r - tree[i].l + <span class="number">1L</span>L);</span><br><span class="line">		tree[i].lz += k;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	pushdown(i);<span class="comment">//下传标记</span></span><br><span class="line">	<span class="keyword">if</span> (tree[i &lt;&lt; <span class="number">1</span>].r &gt;= l)	add(i &lt;&lt; <span class="number">1</span>, l, r, k);<span class="comment">//搜索左子树</span></span><br><span class="line">	<span class="keyword">if</span> (tree[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].l &lt;= r)	add(i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, k);<span class="comment">//搜索右子树</span></span><br><span class="line">	tree[i].sum = tree[i &lt;&lt; <span class="number">1</span>].sum + tree[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、区间查询"><a href="#3、区间查询" class="headerlink" title="3、区间查询"></a>3、区间查询</h4><p>从根节点开始搜索。</p>
<p>如果该节点的区域完全被包含在查询的区间中，返回该节点的值即可。</p>
<p>如果该节点的区域在查询的区间外，则直接返回0。</p>
<p>如果我们还需要向下搜索的话，同样是需要pushdown的。</p>
<p>原因同上，我们仍然需要使用到该节点的子节点。</p>
<p>接下来就是类似的了。</p>
<p>如果左子树与这个区间有交集，就搜索左子树。</p>
<p>如果右子树与这个区间有交集，就搜索右子树。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">quiry</span><span class="params">(<span class="keyword">int</span> i ,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (tree[i].l &gt;= l &amp;&amp; tree[i].r &lt;= r)	<span class="keyword">return</span> tree[i].sum;<span class="comment">//如果完全在其中，则直接返回值</span></span><br><span class="line">	<span class="keyword">if</span> (tree[i].r&lt;l || tree[i].l&gt;r)	<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//超出区间外，直接返回0</span></span><br><span class="line">	pushdown(i);</span><br><span class="line">	<span class="keyword">if</span> (tree[i &lt;&lt; <span class="number">1</span>].r &gt;= l)	ans += quiry(i &lt;&lt; <span class="number">1</span>, l, r);<span class="comment">//加上左子树</span></span><br><span class="line">	<span class="keyword">if</span> (tree[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].l &lt;= r)	ans += quiry(i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);<span class="comment">//加上右子树</span></span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（其实线段树还有很多内容，像基础的单点修改，区间查询，区间修改，单点查询，这些完全可以用区间修改和区间查询替代，所以就不讲了。</p>
<p>在区间修改中，懒标记不止有加法，还存在乘法和根号，这些不会。。</p>
<p>（以后可能会补。。大概</p>
<p>想要了解的话，可以<a href="https://www.cnblogs.com/jason2003/p/9676729.html" target="_blank" rel="noopener">点击这里</a>。</p>
<p>因为自己了解的也不是很深，可能没有讲明白。。</p>
<p>不懂的话可以点击上面那个链接。</p>
<h3 id="典型例题"><a href="#典型例题" class="headerlink" title="典型例题"></a>典型例题</h3><p>1、<a href="https://www.luogu.com.cn/problem/P3372" target="_blank" rel="noopener">洛谷P3372 【模板】线段树 1</a></p>
<h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h4><p>如题，已知一个数列，你需要进行下面两种操作：</p>
<ol>
<li>将某区间每一个数加上 $k$。</li>
<li>求出某区间每一个数的和。</li>
</ol>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>典型的区间修改加区间查询。</p>
<p>线段树模板。</p>
<h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> num[N],n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> sum, lz;</span><br><span class="line">	<span class="keyword">int</span> l, r;</span><br><span class="line">&#125;tree[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> i=<span class="number">1</span>,<span class="keyword">int</span> l=<span class="number">1</span>,<span class="keyword">int</span> r=n)</span> </span>&#123;</span><br><span class="line">	tree[i].l = l, tree[i].r = r;</span><br><span class="line">	<span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">		tree[i].sum = num[l];</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	build(i &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">	build(i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">	tree[i].sum = tree[i &lt;&lt; <span class="number">1</span>].sum + tree[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (tree[i].lz != <span class="number">0</span>) &#123;</span><br><span class="line">		tree[i &lt;&lt; <span class="number">1</span>].lz += tree[i].lz;</span><br><span class="line">		tree[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].lz += tree[i].lz;</span><br><span class="line">		<span class="keyword">int</span> mid = (tree[i].l + tree[i].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		tree[i &lt;&lt; <span class="number">1</span>].sum += tree[i].lz * ((<span class="keyword">long</span> <span class="keyword">long</span>)mid - tree[i].l + <span class="number">1</span>);</span><br><span class="line">		tree[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum += tree[i].lz * (tree[i].r - (<span class="keyword">long</span> <span class="keyword">long</span>)mid);</span><br><span class="line">		tree[i].lz = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (tree[i].l &gt;= l &amp;&amp; tree[i].r &lt;= r) &#123;</span><br><span class="line">		tree[i].sum += k * (tree[i].r - tree[i].l + <span class="number">1L</span>L);</span><br><span class="line">		tree[i].lz += k;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	pushdown(i);</span><br><span class="line">	<span class="keyword">if</span> (tree[i &lt;&lt; <span class="number">1</span>].r &gt;= l)	add(i &lt;&lt; <span class="number">1</span>, l, r, k);</span><br><span class="line">	<span class="keyword">if</span> (tree[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].l &lt;= r)	add(i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, k);</span><br><span class="line">	tree[i].sum = tree[i &lt;&lt; <span class="number">1</span>].sum + tree[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">quiry</span><span class="params">(<span class="keyword">int</span> i ,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (tree[i].l &gt;= l &amp;&amp; tree[i].r &lt;= r)	<span class="keyword">return</span> tree[i].sum;</span><br><span class="line">	<span class="keyword">if</span> (tree[i].r&lt;l || tree[i].l&gt;r)	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	pushdown(i);</span><br><span class="line">	<span class="keyword">if</span> (tree[i &lt;&lt; <span class="number">1</span>].r &gt;= l)	ans += quiry(i &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">	<span class="keyword">if</span> (tree[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].l &lt;= r)	ans += quiry(i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num[i]);</span><br><span class="line">	build();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> g;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; g;</span><br><span class="line">		<span class="keyword">if</span> (g == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> x,y, k;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x, &amp;y,&amp;k);</span><br><span class="line">			add(<span class="number">1</span>, x, y, k);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">int</span> x, y;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; quiry(<span class="number">1</span>, x, y) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、<a href="http://codeforces.com/problemset/problem/12/D" target="_blank" rel="noopener">CF-12D Ball</a> </p>
<p>因为这道题我已经写过题解了，这里就不再赘述。</p>
<p>想要了解的可以去看我之前写的题解。</p>
<p><a href="https://sakurakarma.github.io/2020/07/08/CF-12D-Ball-%E9%A2%98%E8%A7%A3/">点击这里</a></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥模拟2第九题题解</title>
    <url>/2020/07/08/%E8%93%9D%E6%A1%A5%E6%A8%A1%E6%8B%9F2%E7%AC%AC%E4%B9%9D%E9%A2%98%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>　　小明和朋友们一起去郊外植树，他们带了一些在自己实验室精心研究出的小树苗。<br>　　小明和朋友们一共有 n 个人，他们经过精心挑选，在一块空地上每个人挑选了一个适合植树的位置，总共 n 个。他们准备把自己带的树苗都植下去。<br>　　然而，他们遇到了一个困难：有的树苗比较大，而有的位置挨太近，导致两棵树植下去后会撞在一起。<br>　　他们将树看成一个圆，圆心在他们找的位置上。如果两棵树对应的圆相交，这两棵树就不适合同时植下（相切不受影响），称为两棵树冲突。<br>　　小明和朋友们决定先合计合计，只将其中的一部分树植下去，保证没有互相冲突的树。他们同时希望这些树所能覆盖的面积和（圆面积和）最大。</p>
<a id="more"></a>

<p>输入格式</p>
<p>　　输入的第一行包含一个整数 n ，表示人数，即准备植树的位置数。<br>　　接下来 n 行，每行三个整数 x, y, r，表示一棵树在空地上的横、纵坐标和半径。</p>
<p>输出格式</p>
<p>　　输出一行包含一个整数，表示在不冲突下可以植树的面积和。由于每棵树的面积都是圆周率的整数倍，请输出答案除以圆周率后的值（应当是一个整数）。</p>
<p>样例输入</p>
<p>6<br>1 1 2<br>1 4 2<br>1 7 2<br>4 1 2<br>4 4 2<br>4 7 2</p>
<p>样例输出</p>
<p>12</p>
<p>评测用例规模与约定</p>
<p>　　对于 30% 的评测用例，1 &lt;= n &lt;= 10；<br>　　对于 60% 的评测用例，1 &lt;= n &lt;= 20；<br>　　对于所有评测用例，1 &lt;= n &lt;= 30，0 &lt;= x, y &lt;= 1000，1 &lt;= r &lt;= 1000。</p>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>每棵树都占有一定的面积，求出如何种树，在面积不冲突的情况下，占有的最大面积。</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>比赛的时候根本没想到用DFS。。。</p>
<p>看了学长的代码才发现可以用DFS。</p>
<p>用dfs遍历每一颗树，求出最大值，数据不是很大。</p>
<p>(DFS，BFS。。。技术盲区啊</p>
<p>还是要去多学学搜索，多写写题。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">int</span> y;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">&#125;a[<span class="number">35</span>];</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>, n, flag[<span class="number">35</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i != node &amp;&amp; flag[i]) &#123;</span><br><span class="line">			<span class="keyword">double</span> d = <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(a[node].x - a[i].x, <span class="number">2</span>) + <span class="built_in">pow</span>(a[node].y - a[i].y, <span class="number">2</span>));</span><br><span class="line">			<span class="keyword">if</span> (d &lt; (<span class="keyword">double</span>)a[node].r + a[i].r)	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (num == n) &#123;</span><br><span class="line">		ans = <span class="built_in">max</span>(ans, sum);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!flag[i]) &#123;</span><br><span class="line">				flag[i] = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span> (check(i)) &#123;</span><br><span class="line">					dfs(num + <span class="number">1</span>, sum + <span class="built_in">pow</span>(a[i].r, <span class="number">2</span>));</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					dfs(num + <span class="number">1</span>, sum);</span><br><span class="line">				&#125;</span><br><span class="line">				flag[i] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a[i].x &gt;&gt; a[i].y &gt;&gt; a[i].r;</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
        <category>蓝桥</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
</search>
